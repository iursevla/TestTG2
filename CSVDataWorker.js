/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/GisplayDefaults.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.GisplayDefaults = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _defaults = __webpack_require__(/*! ./defaults.json */ 9);\n\nvar _defaults2 = _interopRequireDefault(_defaults);\n\nvar _GisplayError = __webpack_require__(/*! ./GisplayError */ 2);\n\nvar _CategoricalVariable = __webpack_require__(/*! ./VVs/CategoricalVariable */ 3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class that exports the Gisplay default values.\r\n * @export\r\n * @class GisplayDefaults\r\n */\nvar GisplayDefaults = exports.GisplayDefaults = function () {\n    function GisplayDefaults() {\n        _classCallCheck(this, GisplayDefaults);\n    }\n\n    _createClass(GisplayDefaults, null, [{\n        key: 'getAvailableClassBreaksMethods',\n\n\n        /**\r\n         * Returns the available class break methods.\r\n         * @returns {string[]} - All available class break methods under Gisplay API.\r\n         * @memberOf GisplayOptions\r\n         */\n        value: function getAvailableClassBreaksMethods() {\n            return _defaults2.default.availableClasssBreakMethods; //[\"quantiles\", \"equalintervals\", \"k-means\"];\n        }\n\n        /**\r\n         * Returns a list of available background map providers.\r\n         * @returns {string[]} - All available background map providers under Gisplay API.\r\n         * @memberof GisplayOptions\r\n         */\n\n    }, {\n        key: 'getAvailableBackgroundProviders',\n        value: function getAvailableBackgroundProviders() {\n            return _defaults2.default.bgmapsProviders; /*['Google Maps', 'GM', //All variants of Google Maps\r\n                                                       'Mapbox', 'MB', //All variants of Mapbox\r\n                                                       'Here Maps', 'HM',\r\n                                                       'Bing Maps', 'BM'];*/\n        }\n\n        /**\r\n         * Returns the default class method to calculate classes for continuous variables.\r\n         * @static\r\n         * @returns {string} - Returns quantiles, the default method for class calculation.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultClassBreakMethod',\n        value: function getDefaultClassBreakMethod() {\n            return _defaults2.default.defaultClassBreakMethod; //'equalintervals';\n        }\n\n        /**\r\n         * Returns the list of available granularities.\r\n         * @static\r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getAvailableGranularities',\n        value: function getAvailableGranularities() {\n            return ['monthOfYear', 'dayOfYear', 'dayOfMonth', 'hourOfDay', 'minuteOfHour', 'year', 'month', 'day', 'value'];\n        }\n\n        /**\r\n         * Returns the available color brewer methods.\r\n         * @returns {Array<string>} - the available color brewer methods.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getAvailableColorBrewerMethods',\n        value: function getAvailableColorBrewerMethods() {\n            return ['colorbrewer-' + GisplayDefaults.SEQUENTIAL().toLocaleLowerCase(), 'colorbrewer-' + GisplayDefaults.DIVERGENT().toLocaleLowerCase(), 'colorbrewer-' + GisplayDefaults.QUALITATIVE().toLocaleLowerCase()];\n        }\n\n        /**\r\n         * Convert the time string to the granularity we want.\r\n         * @param {string} timeString - The time as it was read from the file. \r\n         * @returns {number} - The granul\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'getGranule',\n        value: function getGranule(timeString) {\n            var value = void 0;\n            // console.warn(timeString, this.timeGranularity);\n            /*\r\n                //if cyclic then ...\r\n                day of year -> dayOfYear (n temos )\r\n                month of year -> monthOfYear (temos)\r\n                day of month -> dayOfMonth (temos)\r\n                hour of day -> hourOfDay (temos)\r\n                minute of hour -> minuteOfHour (temos)\r\n                \r\n                //else continuous\r\n                year -> 2015, 2016 ...\r\n                month -> 2015_01, 2015_02 ... 2016_01 etc\r\n                day -> 2015_01_01, 2015_01_02 ...\r\n                hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n                minute\r\n                value\r\n            */\n            switch (this.timeGranularity) {\n                //CYCLIC\n                case 'monthOfYear':\n                    //Mes do ano\n                    value = new Date(timeString).getMonth() + 1; //GOOD\n                    break;\n                case 'dayOfYear':\n                    value = -1; //CHANGE to calculate day of year\n                    break;\n                case 'dayOfMonth':\n                    value = new Date(timeString).getDate(); //GOOD\n                    break;\n                case 'hourOfDay':\n                    value = new Date(timeString).getHours(); //GOOD\n                    break;\n                case 'minuteOfHour':\n                    value = new Date(timeString).getMinutes(); //GOOD\n                    break;\n\n                //CONTINUOUS\n                case 'year':\n                    value = new Date(timeString).getFullYear();\n                    break;\n                case 'month':\n                    //Mes do ano\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\n                    break;\n                case 'day':\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\n                    // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\n                    break;\n                case 'value':\n                    value = +timeString;\n                    break;\n            }\n            // console.log(value);\n            return value;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     VISUAL VARIABLES   ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * The color visual variable.\r\n         * @static\r\n         * @returns {string} - the string 'color'.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'COLOR',\n        value: function COLOR() {\n            return _defaults2.default.visualVariables.COLOR;\n        }\n\n        /**\r\n         * The saturation visual variable.\r\n         * @static \r\n         * @returns {string} - The saturation visual variable string. \r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'OPACITY',\n        value: function OPACITY() {\n            return _defaults2.default.visualVariables.OPACITY;\n        }\n\n        /**\r\n         * The shape visual variable.\r\n         * @static\r\n         * @returns {string} - The shape visual  variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'SHAPE',\n        value: function SHAPE() {\n            return _defaults2.default.visualVariables.SHAPE;\n        }\n\n        /**\r\n         * The position visual variable.\r\n         * @static\r\n         * @returns {string} - The position visual variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'POSITION',\n        value: function POSITION() {\n            return _defaults2.default.visualVariables.POSITION;\n        }\n\n        /**\r\n         * The variable that is used to hold the matrix projection \r\n         * @static\r\n         * @returns {string} - the projection matrix variable name on all shaders.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'MPROJ',\n        value: function MPROJ() {\n            return _defaults2.default.defaultShadersVariables.projectionMatrix;\n        }\n\n        /**\r\n         * The texture visual variable.\r\n         * @static\r\n         * @returns {string} - The texture visual variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'TEXTURE',\n        value: function TEXTURE() {\n            return _defaults2.default.visualVariables.TEXTURE;\n        }\n\n        /**\r\n         * The size visual variable.\r\n         * @static\r\n         * @returns {string} - The size visual variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'SIZE',\n        value: function SIZE() {\n            return _defaults2.default.visualVariables.SIZE;\n        }\n\n        /**\r\n         * The orientation visual variable.\r\n         * @static\r\n         * @returns {string} - The orientation visual  variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'ORIENTATION',\n        value: function ORIENTATION() {\n            return _defaults2.default.visualVariables.ORIENTATION;\n        }\n\n        /**\r\n         * Returns the index of the given shape.\r\n         * @static\r\n         * @param {string} shapeName - The name of the given shape.\r\n         * @returns {number} - the index of the given shape.\r\n         * @throws {GisplayError} - If the given shape does not exist.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'findShapeIndex',\n        value: function findShapeIndex(shapeName) {\n            // console.warn(shapeTextureName);\n            var shapeIndex = _defaults2.default.shapes[shapeName];\n            if (shapeIndex >= 0) return shapeIndex;\n            throw new _GisplayError.GisplayError('Shape with name: ' + shapeName + ', not found.');\n        }\n\n        /**\r\n         * Returns the index of the given pattern.\r\n         * @static\r\n         * @param {string} patternName - The name of the given pattern.\r\n         * @returns {number} - the index of the given pattern.\r\n         * @throws {GisplayError} - If the given pattern does not exist.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'findPatternIndex',\n        value: function findPatternIndex(patternName) {\n            var patternIndex = _defaults2.default.patterns[patternName];\n            if (patternIndex >= 0) return patternIndex;\n            throw new _GisplayError.GisplayError('Pattern with name: ' + patternName + ', not found.');\n        }\n\n        /**\r\n         * Returns the index of the given figure name.\r\n         * @static\r\n         * @param {string} figureName - The figure name. \r\n         * @returns {number} - the index of the given figure name.\r\n         * @throws {GisplayError} - If the given figure does not exist.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'findFigureIndex',\n        value: function findFigureIndex(figureName) {\n            var figureIndex = _defaults2.default.figures[figureName];\n            if (figureIndex >= 0) return figureIndex;\n            throw new _GisplayError.GisplayError('Figure with name: ' + figureName + ', not found.');\n        }\n\n        /**\r\n         * Returns the default color.\r\n         * @static\r\n         * @returns {Array<number>}  - the default color. \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultColor',\n        value: function getDefaultColor() {\n            return _defaults2.default.defaultColor;\n        }\n\n        /**\r\n         * Returns the index of the default shape.\r\n         * @static\r\n         * @returns {number} - the index of the default shape .\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultShapeIndex',\n        value: function getDefaultShapeIndex() {\n            return this.findShapeIndex(_defaults2.default.defaultShape); //GisplayDefaults.CIRCLE_FULL.name);\n        }\n\n        /**\r\n         * Returns the index of the default texture.\r\n         * @static\r\n         * @returns {number} - the index of the default texture.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultTextureIndex',\n        value: function getDefaultTextureIndex() {\n            return this.findShapeIndex(_defaults2.default.defaultTexture);\n        }\n\n        /**\r\n         * Returns the index of the default figure.\r\n         * @static\r\n         * @returns {number} - the index of the default figure.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultFigureIndex',\n        value: function getDefaultFigureIndex() {\n            return this.findFigureIndex(_defaults2.default.defaultFigure);\n        }\n\n        /**\r\n         * Returns the default size of a point for the Gisplay API.\r\n         * @static\r\n         * @returns {number=15} - the default size of a point for the Gisplay API.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultSizeValue',\n        value: function getDefaultSizeValue() {\n            return _defaults2.default.defaultSize;\n        }\n\n        /**\r\n         * Returns the minimum size for points.\r\n         * @static\r\n         * @returns {number} -  the minimum size for points.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMinSizeValue',\n        value: function getMinSizeValue() {\n            return _defaults2.default.minSize;\n        }\n\n        /**\r\n         * Returns the maximum size for points.\r\n         * @static\r\n         * @returns {number} -  the maximum size for points.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMaxSizeValue',\n        value: function getMaxSizeValue() {\n            return _defaults2.default.maxSize;\n        }\n\n        /**\r\n         * Returns the default orientation of a figure or shape in the Gisplay API.\r\n         * @static\r\n         * @returns {number=0} - the default orientation of a figure or shape in the Gisplay API. \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultOrientationValue',\n        value: function getDefaultOrientationValue() {\n            return _defaults2.default.defaultOrientation;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     IMAGE DEFAUTLS     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the size of the any shape image.\r\n         * @static\r\n         * @returns {number} - the size of the any shape image.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getShapeImageSize',\n        value: function getShapeImageSize() {\n            return _defaults2.default.shapesImageSize;\n        }\n\n        /**\r\n         * Returns the size of the any pattern image.\r\n         * @static\r\n         * @returns {number} - the size of the any pattern image.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getPatternImageSize',\n        value: function getPatternImageSize() {\n            return _defaults2.default.patternsImageSize;\n        }\n\n        /**\r\n         * Returns the size of the any figure image.\r\n         * @static\r\n         * @returns {number} - the size of the any figure image.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getFigureImageSize',\n        value: function getFigureImageSize() {\n            return _defaults2.default.figuresImageSize;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     WEBGL DEFAUTLS     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * The default alpha value for the \r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultAlphaValue',\n        value: function getDefaultAlphaValue() {\n            return _defaults2.default.defaultAlpha;\n        }\n\n        /**\r\n         * Returns the number of bytes for each element of a Float32Array.\r\n         * @static\r\n         * @returns {number} - the number of bytes for each element of a Float32Array.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getFloat32BytesPerElement',\n        value: function getFloat32BytesPerElement() {\n            return Float32Array.BYTES_PER_ELEMENT;\n        }\n\n        /**\r\n         * The number of bytes for each element of a Uint8Array (Unsigned int).\r\n         * @static\r\n         * @returns {number} - the number of bytes for each element of a Uint8Array (Unsigned int).\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getUint8BytesPerElement',\n        value: function getUint8BytesPerElement() {\n            return Uint8Array.BYTES_PER_ELEMENTM;\n        }\n\n        /**\r\n         * Returns the names of the borders files (vertex and fragment shaders).\r\n         * @static\r\n         * @returns {{borderVertexFileName: string, borderFragmentFileName:string}}\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getBordersShadersFileNames',\n        value: function getBordersShadersFileNames() {\n            return { borderVertexFileName: 'borders.vert', borderFragmentFileName: 'borders.frag' };\n        }\n\n        /**\r\n         * Returns the default color for the borders.\r\n         * @static\r\n         * @returns {Array<number>} - the default color for the borders.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getDefaultBordersColor',\n        value: function getDefaultBordersColor() {\n            return [0, 0, 0];\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     WEBGL SIZE     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * The min data name to be used in all shaders that use size as a visual variable.\r\n         * @static\r\n         * @returns {string} - min data name to be used in all shaders that use size as a visual variable.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMinSizeDataName',\n        value: function getMinSizeDataName() {\n            return 'minData';\n        }\n\n        /**\r\n         * The max data name to be used in all shaders that use size as a visual variable.\r\n         * @static\r\n         * @returns {string} - max data name to be used in all shaders that use size as a visual variable.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getMaxSizeDataName',\n        value: function getMaxSizeDataName() {\n            return 'maxData';\n        }\n    }, {\n        key: 'getMinSizePixels',\n        value: function getMinSizePixels() {\n            return { name: 'minPixels', value: _defaults2.default.minSize };\n        }\n    }, {\n        key: 'getMaxSizePixels',\n        value: function getMaxSizePixels() {\n            return { name: 'maxPixels', value: _defaults2.default.maxSize };\n        }\n\n        /*\r\n        #####################################################################\r\n        ######################     PARSERS PRIMITIVE     ####################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the type of primitive we want.\r\n         * @static\r\n         * @returns \r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getPrimitive',\n        value: function getPrimitive() {\n            return {\n                POINT: 0,\n                POLYGON: 1,\n                LINE: 2,\n                CSVPOINT: 3,\n                CSVIDS: 4\n            };\n        }\n\n        /**\r\n         * Returns true if the given primitive is polygon.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is polygon.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasPolygons',\n        value: function hasPolygons(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().POLYGON;\n        }\n\n        /**\r\n         * Returns true if the given primitive is line.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is line.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasLines',\n        value: function hasLines(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().LINE;\n        }\n\n        /**\r\n         * Returns true if the given primitive is line.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is line.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasPoints',\n        value: function hasPoints(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().POINT;\n        }\n\n        /**\r\n         * Returns true if the given primitive is points coming from the CSV Parser.\r\n         * @static\r\n         * @param {number} geoPrimitive - The identifier of the primitive. \r\n         * @returns {boolean} - true if the given primitive is points coming from the CSV Parser.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'hasCSVPoints',\n        value: function hasCSVPoints(geoPrimitive) {\n            return geoPrimitive === this.getPrimitive().CSVPOINT;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################      WEBGL PICKING     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Convert the given RGBA color color to it's respective integer value. \r\n         * @param {number} r - The red value.\r\n         * @param {number} g - The green value.\r\n         * @param {number} b - The blue value.\r\n         * @param {number} a - The alpha value.\r\n         * @returns {number} - the integer value converted from the given RGBA value.\r\n         * @see https://github.com/mcwhittemore/rgb-to-int/blob/master/index.js\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'RGBAToNumber',\n        value: function RGBAToNumber(r, g, b, a) {\n            // return r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a;\n            return r * Math.pow(256, 3) + (g << 16 | b << 8 | a); // g<<16 === g * 2^16\n        }\n\n        /**\r\n         * Convert the given number to it's RGBA representation.\r\n         * @static\r\n         * @param {number} num - The number to be converted. \r\n         * @returns {Array<number>} - the RGBA representation of the given number.\r\n         * @see https://math.stackexchange.com/a/1636055\r\n         * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'numberToRGBA',\n        value: function numberToRGBA(num) {\n            var r = Math.floor(num / Math.pow(256, 3));\n            var g = Math.floor(num / Math.pow(256, 2) % 256);\n            var b = Math.floor(num / 256 % 256);\n            var a = num - (Math.pow(256, 3) * r + Math.pow(256, 2) * g + 256 * b);\n            return [r, g, b, a];\n        }\n\n        /**\r\n         * The name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.\r\n         * @static\r\n         * @returns {string} - he name for the boolean variable that is used on the shader to know if we want to draw to picking texture or normal draw.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isPickingName',\n        value: function isPickingName() {\n            return 'isPicking';\n        }\n\n        /**\r\n         * The name of the variable that holds the RGBA colors used for picking.\r\n         * @static\r\n         * @returns {string} - the name of the variable that holds the RGBA colors used for picking.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'pickingColorName',\n        value: function pickingColorName() {\n            return 'pickingColor';\n        }\n\n        /**\r\n         * Returns the name of the picking identifier for the MVC/TG.\r\n         * @static\r\n         * @returns {string} - the name of the picking identifier for the MVC/TG.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'pickingMVCTGIdentifierName',\n        value: function pickingMVCTGIdentifierName() {\n            return \"MVCTGPickingColor\";\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     TIME DEFAUTLS     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the instant time variable.\r\n         * @static\r\n         * @returns {string} - the instant time variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'INSTANT',\n        value: function INSTANT() {\n            return _defaults2.default.timeVariables.INSTANT;\n        }\n\n        /**\r\n         * Returns the interval time variable.\r\n         * @static\r\n         * @returns {string} -  the interval time variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'INTERVAL',\n        value: function INTERVAL() {\n            return _defaults2.default.timeVariables.INTERVAL;\n        }\n\n        /**\r\n         * The animation time variable.\r\n         * @static\r\n         * @returns {string} - the animation time variable.\r\n         * @memberOf GisplayDefaults\r\n         */\n\n    }, {\n        key: 'ANIMATION',\n        value: function ANIMATION() {\n            return _defaults2.default.timeVariables.ANIMATION;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     DATA NATURE     ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the sequential data nature.\r\n         * @static\r\n         * @returns {string} - the sequential data nature.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'SEQUENTIAL',\n        value: function SEQUENTIAL() {\n            return 'sequential';\n        }\n\n        /**\r\n         * Returns the divergent data nature.\r\n         * @static\r\n         * @returns {string} - the divergent data nature.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'DIVERGENT',\n        value: function DIVERGENT() {\n            return 'divergent';\n        }\n\n        /**\r\n         * Returns the qualitative data nature.\r\n         * @static\r\n         * @returns {string} - the qualitative data nature.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'QUALITATIVE',\n        value: function QUALITATIVE() {\n            return 'qualitative';\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################         CSV            ######################\r\n        #####################################################################\r\n        */\n\n    }, {\n        key: 'MESSAGES_CSV',\n        value: function MESSAGES_CSV() {\n            return {\n                TO_START: 'start', //From TP to Ws to start processing their part\n                END_START: 'end_start', //FROM each W to TP flag that the W as terminated its part\n\n                TO_LIMITS_CAT: 'limits_categories', //FROM TP to Ws to get the min and max and categories for each cat and cont vars \n                END_LIMITS_CAT: 'end_limits_categories', //FROM each W to TP with min/max and categories\n\n                TO_LIMITS_CAT_RES: 'limits_categories_res', //FROM TP to Ws with the resulting classes/categories and time granules\n                END_LIMITS_CAT_RES: 'end_limits_categories_res', //FROM each W to TP meaning the W has all the MVCs and TGs in place\n\n                TO_JOIN_DATA: 'join_data', //FROM TP To Ws with information about MVCs and TGs in order to join the final rows\n                END_JOIN_DATA: 'end_join_data', //FROM Ws To TP as a flag to receive data\n\n                TO_GENERATE_RGBA: 'generate_rgba', //FROM TP To Ws to generate RGBA information for each row\n                END_GENERATE_RGBA: 'end_generate_rgba', //FROM each W to TP meaning the W generated all RGBA values\n\n                TO_SEND_DATA: 'send_data', //FROM TP to one W at a time to receive its data\n                END_SEND_DATA: 'end_send_data' //FROM W to TP with the MVCs and TGs created \n            };\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################     ESSENTIALS         ######################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Verifies if the given value is a string.\r\n         * @static\r\n         * @param {any} value - The value to test if it has type string. \r\n         * @returns {boolean} - true, if the given value is a string, false, otherwise.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isString',\n        value: function isString(value) {\n            return typeof value === 'string';\n        }\n\n        /**\r\n         * Returns true, if the type of value is number.\r\n         * @static\r\n         * @param {any} value \r\n         * @returns {boolean} -  true, if the type of value is number, false, otherwise.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isNumber',\n        value: function isNumber(value) {\n            return typeof value === 'number';\n        }\n\n        /**\r\n         * Clone a nested array in Javascript.\r\n         * @static\r\n         * @param {Array<any>} arr - The given array. \r\n         * @returns {Array<any>} - the cloned nested array.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'cloneNestedArray',\n        value: function cloneNestedArray(arr) {\n            var i = void 0,\n                copy = void 0;\n            if (Array.isArray(arr)) {\n                copy = arr.slice(0);\n                for (var _i = 0; _i < copy.length; _i++) {\n                    copy[_i] = this.cloneNestedArray(copy[_i]);\n                }return copy;\n            } else if ((typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object') throw new Error('Cannot clone array containing an object!');else return arr;\n        }\n\n        /*\r\n        #####################################################################\r\n        #######################          EVENTS        ######################\r\n        #####################################################################\r\n        */\n\n    }, {\n        key: 'getEvents',\n        value: function getEvents() {\n            return {\n                /**\r\n                * The name of the library loaded event.\r\n                * @type {string}\r\n                */\n                LIBRARY_LOADED_EVENT: 'libraryLoaded',\n                /**\r\n                 * The name of the parser ended event.\r\n                 * @type {string}\r\n                 */\n                PARSER_ENDED_EVENT: 'parserEnd',\n                /**\r\n                 * The name of the event for geometry ids.\r\n                 * @type {string}\r\n                 */\n                GEOMETRY_IDS_EVENT: 'geometryIdsEnd',\n                /**\r\n                 * The shapes image loaded event.\r\n                 * Needed, otherwise could cause the error: https://github.com/jywarren/webgl-distort/issues/4\r\n                 * @type {string}\r\n                 */\n                SHAPES_IMAGE_LOADED_EVENT: 'shapesImageLoaded',\n                /**\r\n                 * The patterns image loaded event.\r\n                 * @type {string}\r\n                 */\n                PATTERNS_IMAGE_LOADED_EVENT: 'patternsImageLoaded',\n                /**\r\n                 * The figures image loaded event.\r\n                 * @type {string}\r\n                 */\n                FIGURES_IMAGE_LOADED_EVENT: 'figuresImageLoaded',\n                /**\r\n                 * The time range changed event.\r\n                 * @type {string}\r\n                 */\n                TIME_RANGE_CHANGED: 'TimeRangeChanged',\n                /**\r\n                 * The legend changed event.\r\n                 * @type {string}\r\n                 */\n                LEGEND_CHANGED: 'LegendChanged',\n                /**\r\n                 * The extended temporal navigator legend changed event.\r\n                 * @type {string}\r\n                 */\n                EXTENDED_TEMPORAL_NAVIGATOR_LEGEND_CHANGED: 'extended_temporal_navigator_legend',\n                /**\r\n                 * The extended temporal navigator time axis changed event.\r\n                 * @type {string}\r\n                 */\n                EXTENDED_TEMPORAL_NAVIGATOR_TIME_CHANGED: 'extended_temporal_navigator_time',\n                /**\r\n                 * The event for the resize of the window.\r\n                 * @type {string}\r\n                 */\n                RESIZE: 'resize'\n            };\n        }\n\n        /**\r\n         * Returns the list of keys and their key codes to be used by TimeControl and ETN.\r\n         * @static\r\n         * @returns {{LEFT_ARROW: number, A_KEY:number, RIGHT_ARROW: number, D_KEY: number, DOWN_ARROW: number, S_KEY: number, UP_ARROW: number, W_KEY: number}} - the list of keys and their key codes to be used by TimeControl and ETN.\r\n         * @see https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes - Key codes\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'getKeyboardKeyCodes',\n        value: function getKeyboardKeyCodes() {\n            return {\n                LEFT_ARROW: 37,\n                A_KEY: 65,\n                RIGHT_ARROW: 39,\n                D_KEY: 68,\n                DOWN_ARROW: 40,\n                S_KEY: 83,\n                UP_ARROW: 38,\n                W_KEY: 87\n            };\n        }\n\n        /**\r\n         * Returns true if the given Map Variable is an instance of CategoricalVariable.\r\n         * @static\r\n         * @param {any} mapVariable - The value given. \r\n         * @returns {boolean} - true, if the given value is an instance of CategoricalVariable, false, otherwise.\r\n         * @memberof GisplayDefaults\r\n         */\n\n    }, {\n        key: 'isCategoricalMapVariable',\n        value: function isCategoricalMapVariable(mapVariable) {\n            return mapVariable instanceof _CategoricalVariable.CategoricalVariable;\n        }\n    }]);\n\n    return GisplayDefaults;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5RGVmYXVsdHMuanM/YWRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmYXVsdHNGaWxlIGZyb20gJy4vZGVmYXVsdHMuanNvbic7XHJcbmltcG9ydCB7IEdpc3BsYXlFcnJvciB9IGZyb20gJy4vR2lzcGxheUVycm9yJztcclxuaW1wb3J0IHsgQ2F0ZWdvcmljYWxWYXJpYWJsZSB9IGZyb20gJy4vVlZzL0NhdGVnb3JpY2FsVmFyaWFibGUnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgZXhwb3J0cyB0aGUgR2lzcGxheSBkZWZhdWx0IHZhbHVlcy5cclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgR2lzcGxheURlZmF1bHRzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheURlZmF1bHRzIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBjbGFzcyBicmVhayBtZXRob2RzLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSAtIEFsbCBhdmFpbGFibGUgY2xhc3MgYnJlYWsgbWV0aG9kcyB1bmRlciBHaXNwbGF5IEFQSS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5T3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXZhaWxhYmxlQ2xhc3NCcmVha3NNZXRob2RzKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUuYXZhaWxhYmxlQ2xhc3NzQnJlYWtNZXRob2RzOyAvL1tcInF1YW50aWxlc1wiLCBcImVxdWFsaW50ZXJ2YWxzXCIsIFwiay1tZWFuc1wiXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBiYWNrZ3JvdW5kIG1hcCBwcm92aWRlcnMuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IC0gQWxsIGF2YWlsYWJsZSBiYWNrZ3JvdW5kIG1hcCBwcm92aWRlcnMgdW5kZXIgR2lzcGxheSBBUEkuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheU9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEF2YWlsYWJsZUJhY2tncm91bmRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5iZ21hcHNQcm92aWRlcnM7LypbJ0dvb2dsZSBNYXBzJywgJ0dNJywgLy9BbGwgdmFyaWFudHMgb2YgR29vZ2xlIE1hcHNcclxuICAgICAgICAgICAgJ01hcGJveCcsICdNQicsIC8vQWxsIHZhcmlhbnRzIG9mIE1hcGJveFxyXG4gICAgICAgICAgICAnSGVyZSBNYXBzJywgJ0hNJyxcclxuICAgICAgICAgICAgJ0JpbmcgTWFwcycsICdCTSddOyovXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGNsYXNzIG1ldGhvZCB0byBjYWxjdWxhdGUgY2xhc3NlcyBmb3IgY29udGludW91cyB2YXJpYWJsZXMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFJldHVybnMgcXVhbnRpbGVzLCB0aGUgZGVmYXVsdCBtZXRob2QgZm9yIGNsYXNzIGNhbGN1bGF0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENsYXNzQnJlYWtNZXRob2QoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5kZWZhdWx0Q2xhc3NCcmVha01ldGhvZDsvLydlcXVhbGludGVydmFscyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBncmFudWxhcml0aWVzLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBdmFpbGFibGVHcmFudWxhcml0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiBbJ21vbnRoT2ZZZWFyJywgJ2RheU9mWWVhcicsICdkYXlPZk1vbnRoJywgJ2hvdXJPZkRheScsICdtaW51dGVPZkhvdXInLCAneWVhcicsICdtb250aCcsICdkYXknLCAndmFsdWUnXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBjb2xvciBicmV3ZXIgbWV0aG9kcy5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIHRoZSBhdmFpbGFibGUgY29sb3IgYnJld2VyIG1ldGhvZHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBdmFpbGFibGVDb2xvckJyZXdlck1ldGhvZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgJ2NvbG9yYnJld2VyLScgKyBHaXNwbGF5RGVmYXVsdHMuU0VRVUVOVElBTCgpLnRvTG9jYWxlTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICdjb2xvcmJyZXdlci0nICsgR2lzcGxheURlZmF1bHRzLkRJVkVSR0VOVCgpLnRvTG9jYWxlTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICdjb2xvcmJyZXdlci0nICsgR2lzcGxheURlZmF1bHRzLlFVQUxJVEFUSVZFKCkudG9Mb2NhbGVMb3dlckNhc2UoKVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0aW1lIHN0cmluZyB0byB0aGUgZ3JhbnVsYXJpdHkgd2Ugd2FudC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lU3RyaW5nIC0gVGhlIHRpbWUgYXMgaXQgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS4gXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBncmFudWxcclxuICAgICAqIEBtZW1iZXJvZiBDU1ZEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRHcmFudWxlKHRpbWVTdHJpbmcpIHtcclxuICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKHRpbWVTdHJpbmcsIHRoaXMudGltZUdyYW51bGFyaXR5KTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICAvL2lmIGN5Y2xpYyB0aGVuIC4uLlxyXG4gICAgICAgICAgICBkYXkgb2YgeWVhciAtPiBkYXlPZlllYXIgKG4gdGVtb3MgKVxyXG4gICAgICAgICAgICBtb250aCBvZiB5ZWFyIC0+IG1vbnRoT2ZZZWFyICh0ZW1vcylcclxuICAgICAgICAgICAgZGF5IG9mIG1vbnRoIC0+IGRheU9mTW9udGggKHRlbW9zKVxyXG4gICAgICAgICAgICBob3VyIG9mIGRheSAtPiBob3VyT2ZEYXkgKHRlbW9zKVxyXG4gICAgICAgICAgICBtaW51dGUgb2YgaG91ciAtPiBtaW51dGVPZkhvdXIgKHRlbW9zKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9lbHNlIGNvbnRpbnVvdXNcclxuICAgICAgICAgICAgeWVhciAtPiAyMDE1LCAyMDE2IC4uLlxyXG4gICAgICAgICAgICBtb250aCAtPiAyMDE1XzAxLCAyMDE1XzAyIC4uLiAyMDE2XzAxIGV0Y1xyXG4gICAgICAgICAgICBkYXkgLT4gMjAxNV8wMV8wMSwgMjAxNV8wMV8wMiAuLi5cclxuICAgICAgICAgICAgaG91ciAtPiAyMDE1XzAxXzAxXzAxLCAyMDE1XzAxXzAxXzAxIC4uLlxyXG4gICAgICAgICAgICBtaW51dGVcclxuICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAqL1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50aW1lR3JhbnVsYXJpdHkpIHtcclxuICAgICAgICAgICAgLy9DWUNMSUNcclxuICAgICAgICAgICAgY2FzZSAnbW9udGhPZlllYXInOiAvL01lcyBkbyBhbm9cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1vbnRoKCkgKyAxKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5T2ZZZWFyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gLTE7IC8vQ0hBTkdFIHRvIGNhbGN1bGF0ZSBkYXkgb2YgeWVhclxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheU9mTW9udGgnOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXREYXRlKCk7IC8vR09PRFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hvdXJPZkRheSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEhvdXJzKCk7IC8vR09PRFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZU9mSG91cic6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1pbnV0ZXMoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vQ09OVElOVU9VU1xyXG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb250aCc6IC8vTWVzIGRvIGFub1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRGdWxsWWVhcigpICsgXCJfXCIgKyAobmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIl9cIiArIChuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgMSkgKyBcIl9cIiArIG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERhdGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlID0gTnVtYmVyKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIlwiICsgbmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIFwiXCIgKyBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXREYXkoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSArdGltZVN0cmluZztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBWSVNVQUwgVkFSSUFCTEVTICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29sb3IgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgc3RyaW5nICdjb2xvcicuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBDT0xPUigpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnZpc3VhbFZhcmlhYmxlcy5DT0xPUjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzYXR1cmF0aW9uIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWMgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBzYXR1cmF0aW9uIHZpc3VhbCB2YXJpYWJsZSBzdHJpbmcuIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgT1BBQ0lUWSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnZpc3VhbFZhcmlhYmxlcy5PUEFDSVRZO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNoYXBlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHNoYXBlIHZpc3VhbCAgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBTSEFQRSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnZpc3VhbFZhcmlhYmxlcy5TSEFQRTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb3NpdGlvbiB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBwb3NpdGlvbiB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBQT1NJVElPTigpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnZpc3VhbFZhcmlhYmxlcy5QT1NJVElPTjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gaG9sZCB0aGUgbWF0cml4IHByb2plY3Rpb24gXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCB2YXJpYWJsZSBuYW1lIG9uIGFsbCBzaGFkZXJzLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgTVBST0ooKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5kZWZhdWx0U2hhZGVyc1ZhcmlhYmxlcy5wcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgdGV4dHVyZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBURVhUVVJFKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUudmlzdWFsVmFyaWFibGVzLlRFWFRVUkU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2l6ZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBzaXplIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFNJWkUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS52aXN1YWxWYXJpYWJsZXMuU0laRTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmllbnRhdGlvbiB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBvcmllbnRhdGlvbiB2aXN1YWwgIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgT1JJRU5UQVRJT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS52aXN1YWxWYXJpYWJsZXMuT1JJRU5UQVRJT047XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc2hhcGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGdpdmVuIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHNoYXBlLlxyXG4gICAgICogQHRocm93cyB7R2lzcGxheUVycm9yfSAtIElmIHRoZSBnaXZlbiBzaGFwZSBkb2VzIG5vdCBleGlzdC5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZpbmRTaGFwZUluZGV4KHNoYXBlTmFtZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2FybihzaGFwZVRleHR1cmVOYW1lKTtcclxuICAgICAgICBsZXQgc2hhcGVJbmRleCA9IGRlZmF1bHRzRmlsZS5zaGFwZXNbc2hhcGVOYW1lXTtcclxuICAgICAgICBpZiAoc2hhcGVJbmRleCA+PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gc2hhcGVJbmRleDtcclxuICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKGBTaGFwZSB3aXRoIG5hbWU6ICR7c2hhcGVOYW1lfSwgbm90IGZvdW5kLmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBhdHRlcm4uXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybk5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZ2l2ZW4gcGF0dGVybi5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBwYXR0ZXJuLlxyXG4gICAgICogQHRocm93cyB7R2lzcGxheUVycm9yfSAtIElmIHRoZSBnaXZlbiBwYXR0ZXJuIGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZmluZFBhdHRlcm5JbmRleChwYXR0ZXJuTmFtZSkge1xyXG4gICAgICAgIGxldCBwYXR0ZXJuSW5kZXggPSBkZWZhdWx0c0ZpbGUucGF0dGVybnNbcGF0dGVybk5hbWVdO1xyXG4gICAgICAgIGlmIChwYXR0ZXJuSW5kZXggPj0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5JbmRleDtcclxuICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKGBQYXR0ZXJuIHdpdGggbmFtZTogJHtwYXR0ZXJuTmFtZX0sIG5vdCBmb3VuZC5gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBmaWd1cmUgbmFtZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWd1cmVOYW1lIC0gVGhlIGZpZ3VyZSBuYW1lLiBcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBmaWd1cmUgbmFtZS5cclxuICAgICAqIEB0aHJvd3Mge0dpc3BsYXlFcnJvcn0gLSBJZiB0aGUgZ2l2ZW4gZmlndXJlIGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZmluZEZpZ3VyZUluZGV4KGZpZ3VyZU5hbWUpIHtcclxuICAgICAgICBsZXQgZmlndXJlSW5kZXggPSBkZWZhdWx0c0ZpbGUuZmlndXJlc1tmaWd1cmVOYW1lXTtcclxuICAgICAgICBpZiAoZmlndXJlSW5kZXggPj0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGZpZ3VyZUluZGV4O1xyXG4gICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoYEZpZ3VyZSB3aXRoIG5hbWU6ICR7ZmlndXJlTmFtZX0sIG5vdCBmb3VuZC5gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgY29sb3IuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gIC0gdGhlIGRlZmF1bHQgY29sb3IuIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUuZGVmYXVsdENvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGRlZmF1bHQgc2hhcGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCBzaGFwZSAuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0U2hhcGVJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kU2hhcGVJbmRleChkZWZhdWx0c0ZpbGUuZGVmYXVsdFNoYXBlKTsgLy9HaXNwbGF5RGVmYXVsdHMuQ0lSQ0xFX0ZVTEwubmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCB0ZXh0dXJlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGRlZmF1bHQgdGV4dHVyZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRUZXh0dXJlSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFNoYXBlSW5kZXgoZGVmYXVsdHNGaWxlLmRlZmF1bHRUZXh0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBkZWZhdWx0IGZpZ3VyZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBkZWZhdWx0IGZpZ3VyZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRGaWd1cmVJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5kRmlndXJlSW5kZXgoZGVmYXVsdHNGaWxlLmRlZmF1bHRGaWd1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBzaXplIG9mIGEgcG9pbnQgZm9yIHRoZSBHaXNwbGF5IEFQSS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXI9MTV9IC0gdGhlIGRlZmF1bHQgc2l6ZSBvZiBhIHBvaW50IGZvciB0aGUgR2lzcGxheSBBUEkuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0U2l6ZVZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUuZGVmYXVsdFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHNpemUgZm9yIHBvaW50cy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gIHRoZSBtaW5pbXVtIHNpemUgZm9yIHBvaW50cy5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE1pblNpemVWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLm1pblNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHNpemUgZm9yIHBvaW50cy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gIHRoZSBtYXhpbXVtIHNpemUgZm9yIHBvaW50cy5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE1heFNpemVWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLm1heFNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IG9yaWVudGF0aW9uIG9mIGEgZmlndXJlIG9yIHNoYXBlIGluIHRoZSBHaXNwbGF5IEFQSS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXI9MH0gLSB0aGUgZGVmYXVsdCBvcmllbnRhdGlvbiBvZiBhIGZpZ3VyZSBvciBzaGFwZSBpbiB0aGUgR2lzcGxheSBBUEkuIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdE9yaWVudGF0aW9uVmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5kZWZhdWx0T3JpZW50YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgIElNQUdFIERFRkFVVExTICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGFueSBzaGFwZSBpbWFnZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHNpemUgb2YgdGhlIGFueSBzaGFwZSBpbWFnZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNoYXBlSW1hZ2VTaXplKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUuc2hhcGVzSW1hZ2VTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgYW55IHBhdHRlcm4gaW1hZ2UuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBzaXplIG9mIHRoZSBhbnkgcGF0dGVybiBpbWFnZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFBhdHRlcm5JbWFnZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5wYXR0ZXJuc0ltYWdlU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGFueSBmaWd1cmUgaW1hZ2UuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBzaXplIG9mIHRoZSBhbnkgZmlndXJlIGltYWdlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RmlndXJlSW1hZ2VTaXplKCkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0c0ZpbGUuZmlndXJlc0ltYWdlU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgV0VCR0wgREVGQVVUTFMgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgYWxwaGEgdmFsdWUgZm9yIHRoZSBcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEFscGhhVmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS5kZWZhdWx0QWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIGVhY2ggZWxlbWVudCBvZiBhIEZsb2F0MzJBcnJheS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIG51bWJlciBvZiBieXRlcyBmb3IgZWFjaCBlbGVtZW50IG9mIGEgRmxvYXQzMkFycmF5LlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RmxvYXQzMkJ5dGVzUGVyRWxlbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBieXRlcyBmb3IgZWFjaCBlbGVtZW50IG9mIGEgVWludDhBcnJheSAoVW5zaWduZWQgaW50KS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIG51bWJlciBvZiBieXRlcyBmb3IgZWFjaCBlbGVtZW50IG9mIGEgVWludDhBcnJheSAoVW5zaWduZWQgaW50KS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFVpbnQ4Qnl0ZXNQZXJFbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UTTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBib3JkZXJzIGZpbGVzICh2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMpLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3tib3JkZXJWZXJ0ZXhGaWxlTmFtZTogc3RyaW5nLCBib3JkZXJGcmFnbWVudEZpbGVOYW1lOnN0cmluZ319XHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRCb3JkZXJzU2hhZGVyc0ZpbGVOYW1lcygpIHtcclxuICAgICAgICByZXR1cm4geyBib3JkZXJWZXJ0ZXhGaWxlTmFtZTogJ2JvcmRlcnMudmVydCcsIGJvcmRlckZyYWdtZW50RmlsZU5hbWU6ICdib3JkZXJzLmZyYWcnIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGNvbG9yIGZvciB0aGUgYm9yZGVycy5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIHRoZSBkZWZhdWx0IGNvbG9yIGZvciB0aGUgYm9yZGVycy5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRCb3JkZXJzQ29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgV0VCR0wgU0laRSAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWluIGRhdGEgbmFtZSB0byBiZSB1c2VkIGluIGFsbCBzaGFkZXJzIHRoYXQgdXNlIHNpemUgYXMgYSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIG1pbiBkYXRhIG5hbWUgdG8gYmUgdXNlZCBpbiBhbGwgc2hhZGVycyB0aGF0IHVzZSBzaXplIGFzIGEgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TWluU2l6ZURhdGFOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAnbWluRGF0YSc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4IGRhdGEgbmFtZSB0byBiZSB1c2VkIGluIGFsbCBzaGFkZXJzIHRoYXQgdXNlIHNpemUgYXMgYSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIG1heCBkYXRhIG5hbWUgdG8gYmUgdXNlZCBpbiBhbGwgc2hhZGVycyB0aGF0IHVzZSBzaXplIGFzIGEgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TWF4U2l6ZURhdGFOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAnbWF4RGF0YSc7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldE1pblNpemVQaXhlbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogJ21pblBpeGVscycsIHZhbHVlOiBkZWZhdWx0c0ZpbGUubWluU2l6ZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXRNYXhTaXplUGl4ZWxzKCkge1xyXG4gICAgICAgIHJldHVybiB7IG5hbWU6ICdtYXhQaXhlbHMnLCB2YWx1ZTogZGVmYXVsdHNGaWxlLm1heFNpemUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBQQVJTRVJTIFBSSU1JVElWRSAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBwcmltaXRpdmUgd2Ugd2FudC5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0UHJpbWl0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFBPSU5UOiAwLFxyXG4gICAgICAgICAgICBQT0xZR09OOiAxLFxyXG4gICAgICAgICAgICBMSU5FOiAyLFxyXG4gICAgICAgICAgICBDU1ZQT0lOVDogMyxcclxuICAgICAgICAgICAgQ1NWSURTOiA0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJpbWl0aXZlIGlzIHBvbHlnb24uXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2VvUHJpbWl0aXZlIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByaW1pdGl2ZS4gXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgcG9seWdvbi5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc1BvbHlnb25zKGdlb1ByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBnZW9QcmltaXRpdmUgPT09IHRoaXMuZ2V0UHJpbWl0aXZlKCkuUE9MWUdPTjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJpbWl0aXZlIGlzIGxpbmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2VvUHJpbWl0aXZlIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByaW1pdGl2ZS4gXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgbGluZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc0xpbmVzKGdlb1ByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBnZW9QcmltaXRpdmUgPT09IHRoaXMuZ2V0UHJpbWl0aXZlKCkuTElORTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJpbWl0aXZlIGlzIGxpbmUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2VvUHJpbWl0aXZlIC0gVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByaW1pdGl2ZS4gXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgbGluZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc1BvaW50cyhnZW9QcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gZ2VvUHJpbWl0aXZlID09PSB0aGlzLmdldFByaW1pdGl2ZSgpLlBPSU5UO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcmltaXRpdmUgaXMgcG9pbnRzIGNvbWluZyBmcm9tIHRoZSBDU1YgUGFyc2VyLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdlb1ByaW1pdGl2ZSAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBwcmltaXRpdmUuIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJpbWl0aXZlIGlzIHBvaW50cyBjb21pbmcgZnJvbSB0aGUgQ1NWIFBhcnNlci5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGhhc0NTVlBvaW50cyhnZW9QcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gZ2VvUHJpbWl0aXZlID09PSB0aGlzLmdldFByaW1pdGl2ZSgpLkNTVlBPSU5UO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICAgV0VCR0wgUElDS0lORyAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSBnaXZlbiBSR0JBIGNvbG9yIGNvbG9yIHRvIGl0J3MgcmVzcGVjdGl2ZSBpbnRlZ2VyIHZhbHVlLiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gVGhlIHJlZCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnIC0gVGhlIGdyZWVuIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBUaGUgYmx1ZSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gVGhlIGFscGhhIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW50ZWdlciB2YWx1ZSBjb252ZXJ0ZWQgZnJvbSB0aGUgZ2l2ZW4gUkdCQSB2YWx1ZS5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21jd2hpdHRlbW9yZS9yZ2ItdG8taW50L2Jsb2IvbWFzdGVyL2luZGV4LmpzXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBSR0JBVG9OdW1iZXIociwgZywgYiwgYSkge1xyXG4gICAgICAgIC8vIHJldHVybiByICogTWF0aC5wb3coMjU2LCAzKSArIGcgKiBNYXRoLnBvdygyNTYsIDIpICsgYiAqIE1hdGgucG93KDI1NiwgMSkgKyBhO1xyXG4gICAgICAgIHJldHVybiByICogTWF0aC5wb3coMjU2LCAzKSArIChnIDw8IDE2IHwgYiA8PCA4IHwgYSk7IC8vIGc8PDE2ID09PSBnICogMl4xNlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgZ2l2ZW4gbnVtYmVyIHRvIGl0J3MgUkdCQSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIGJlIGNvbnZlcnRlZC4gXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gLSB0aGUgUkdCQSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gICAgICogQHNlZSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8xNjM2MDU1XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3B0LVBUL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBudW1iZXJUb1JHQkEobnVtKSB7XHJcbiAgICAgICAgbGV0IHIgPSBNYXRoLmZsb29yKG51bSAvIE1hdGgucG93KDI1NiwgMykpO1xyXG4gICAgICAgIGxldCBnID0gTWF0aC5mbG9vcihudW0gLyBNYXRoLnBvdygyNTYsIDIpICUgMjU2KTtcclxuICAgICAgICBsZXQgYiA9IE1hdGguZmxvb3IobnVtIC8gMjU2ICUgMjU2KTtcclxuICAgICAgICBsZXQgYSA9IG51bSAtIChNYXRoLnBvdygyNTYsIDMpICogciArIE1hdGgucG93KDI1NiwgMikgKiBnICsgMjU2ICogYik7XHJcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIGZvciB0aGUgYm9vbGVhbiB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgb24gdGhlIHNoYWRlciB0byBrbm93IGlmIHdlIHdhbnQgdG8gZHJhdyB0byBwaWNraW5nIHRleHR1cmUgb3Igbm9ybWFsIGRyYXcuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIGhlIG5hbWUgZm9yIHRoZSBib29sZWFuIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCBvbiB0aGUgc2hhZGVyIHRvIGtub3cgaWYgd2Ugd2FudCB0byBkcmF3IHRvIHBpY2tpbmcgdGV4dHVyZSBvciBub3JtYWwgZHJhdy5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzUGlja2luZ05hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdpc1BpY2tpbmcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRoYXQgaG9sZHMgdGhlIFJHQkEgY29sb3JzIHVzZWQgZm9yIHBpY2tpbmcuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0aGF0IGhvbGRzIHRoZSBSR0JBIGNvbG9ycyB1c2VkIGZvciBwaWNraW5nLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGlja2luZ0NvbG9yTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gJ3BpY2tpbmdDb2xvcic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBwaWNraW5nIGlkZW50aWZpZXIgZm9yIHRoZSBNVkMvVEcuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBuYW1lIG9mIHRoZSBwaWNraW5nIGlkZW50aWZpZXIgZm9yIHRoZSBNVkMvVEcuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwaWNraW5nTVZDVEdJZGVudGlmaWVyTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gXCJNVkNUR1BpY2tpbmdDb2xvclwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBUSU1FIERFRkFVVExTICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluc3RhbnQgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGluc3RhbnQgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIElOU1RBTlQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzRmlsZS50aW1lVmFyaWFibGVzLklOU1RBTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnRlcnZhbCB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSAgdGhlIGludGVydmFsIHRpbWUgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBJTlRFUlZBTCgpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnRpbWVWYXJpYWJsZXMuSU5URVJWQUw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW5pbWF0aW9uIHRpbWUgdmFyaWFibGUuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBhbmltYXRpb24gdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIEFOSU1BVElPTigpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHNGaWxlLnRpbWVWYXJpYWJsZXMuQU5JTUFUSU9OO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBEQVRBIE5BVFVSRSAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXF1ZW50aWFsIGRhdGEgbmF0dXJlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgc2VxdWVudGlhbCBkYXRhIG5hdHVyZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFNFUVVFTlRJQUwoKSB7XHJcbiAgICAgICAgcmV0dXJuICdzZXF1ZW50aWFsJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpdmVyZ2VudCBkYXRhIG5hdHVyZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGRpdmVyZ2VudCBkYXRhIG5hdHVyZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIERJVkVSR0VOVCgpIHtcclxuICAgICAgICByZXR1cm4gJ2RpdmVyZ2VudCc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBxdWFsaXRhdGl2ZSBkYXRhIG5hdHVyZS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHF1YWxpdGF0aXZlIGRhdGEgbmF0dXJlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgUVVBTElUQVRJVkUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdxdWFsaXRhdGl2ZSc7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgICAgICAgICBDU1YgICAgICAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICBzdGF0aWMgTUVTU0FHRVNfQ1NWKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFRPX1NUQVJUOiAnc3RhcnQnLCAvL0Zyb20gVFAgdG8gV3MgdG8gc3RhcnQgcHJvY2Vzc2luZyB0aGVpciBwYXJ0XHJcbiAgICAgICAgICAgIEVORF9TVEFSVDogJ2VuZF9zdGFydCcsIC8vRlJPTSBlYWNoIFcgdG8gVFAgZmxhZyB0aGF0IHRoZSBXIGFzIHRlcm1pbmF0ZWQgaXRzIHBhcnRcclxuXHJcbiAgICAgICAgICAgIFRPX0xJTUlUU19DQVQ6ICdsaW1pdHNfY2F0ZWdvcmllcycsIC8vRlJPTSBUUCB0byBXcyB0byBnZXQgdGhlIG1pbiBhbmQgbWF4IGFuZCBjYXRlZ29yaWVzIGZvciBlYWNoIGNhdCBhbmQgY29udCB2YXJzIFxyXG4gICAgICAgICAgICBFTkRfTElNSVRTX0NBVDogJ2VuZF9saW1pdHNfY2F0ZWdvcmllcycsIC8vRlJPTSBlYWNoIFcgdG8gVFAgd2l0aCBtaW4vbWF4IGFuZCBjYXRlZ29yaWVzXHJcblxyXG4gICAgICAgICAgICBUT19MSU1JVFNfQ0FUX1JFUzogJ2xpbWl0c19jYXRlZ29yaWVzX3JlcycsIC8vRlJPTSBUUCB0byBXcyB3aXRoIHRoZSByZXN1bHRpbmcgY2xhc3Nlcy9jYXRlZ29yaWVzIGFuZCB0aW1lIGdyYW51bGVzXHJcbiAgICAgICAgICAgIEVORF9MSU1JVFNfQ0FUX1JFUzogJ2VuZF9saW1pdHNfY2F0ZWdvcmllc19yZXMnLCAvL0ZST00gZWFjaCBXIHRvIFRQIG1lYW5pbmcgdGhlIFcgaGFzIGFsbCB0aGUgTVZDcyBhbmQgVEdzIGluIHBsYWNlXHJcblxyXG4gICAgICAgICAgICBUT19KT0lOX0RBVEE6ICdqb2luX2RhdGEnLCAvL0ZST00gVFAgVG8gV3Mgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBNVkNzIGFuZCBUR3MgaW4gb3JkZXIgdG8gam9pbiB0aGUgZmluYWwgcm93c1xyXG4gICAgICAgICAgICBFTkRfSk9JTl9EQVRBOiAnZW5kX2pvaW5fZGF0YScsIC8vRlJPTSBXcyBUbyBUUCBhcyBhIGZsYWcgdG8gcmVjZWl2ZSBkYXRhXHJcblxyXG4gICAgICAgICAgICBUT19HRU5FUkFURV9SR0JBOiAnZ2VuZXJhdGVfcmdiYScsLy9GUk9NIFRQIFRvIFdzIHRvIGdlbmVyYXRlIFJHQkEgaW5mb3JtYXRpb24gZm9yIGVhY2ggcm93XHJcbiAgICAgICAgICAgIEVORF9HRU5FUkFURV9SR0JBOiAnZW5kX2dlbmVyYXRlX3JnYmEnLCAvL0ZST00gZWFjaCBXIHRvIFRQIG1lYW5pbmcgdGhlIFcgZ2VuZXJhdGVkIGFsbCBSR0JBIHZhbHVlc1xyXG5cclxuICAgICAgICAgICAgVE9fU0VORF9EQVRBOiAnc2VuZF9kYXRhJywgLy9GUk9NIFRQIHRvIG9uZSBXIGF0IGEgdGltZSB0byByZWNlaXZlIGl0cyBkYXRhXHJcbiAgICAgICAgICAgIEVORF9TRU5EX0RBVEE6ICdlbmRfc2VuZF9kYXRhJyAvL0ZST00gVyB0byBUUCB3aXRoIHRoZSBNVkNzIGFuZCBUR3MgY3JlYXRlZCBcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICBFU1NFTlRJQUxTICAgICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdCBpZiBpdCBoYXMgdHlwZSBzdHJpbmcuIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSwgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSwgaWYgdGhlIHR5cGUgb2YgdmFsdWUgaXMgbnVtYmVyLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gIHRydWUsIGlmIHRoZSB0eXBlIG9mIHZhbHVlIGlzIG51bWJlciwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBHaXNwbGF5RGVmYXVsdHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZSBhIG5lc3RlZCBhcnJheSBpbiBKYXZhc2NyaXB0LlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgZ2l2ZW4gYXJyYXkuIFxyXG4gICAgICogQHJldHVybnMge0FycmF5PGFueT59IC0gdGhlIGNsb25lZCBuZXN0ZWQgYXJyYXkuXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbG9uZU5lc3RlZEFycmF5KGFycikge1xyXG4gICAgICAgIGxldCBpLCBjb3B5O1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcclxuICAgICAgICAgICAgY29weSA9IGFyci5zbGljZSgwKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgY29weVtpXSA9IHRoaXMuY2xvbmVOZXN0ZWRBcnJheShjb3B5W2ldKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2xvbmUgYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QhJyk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICAgICAgICAgIEVWRU5UUyAgICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGdldEV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbGlicmFyeSBsb2FkZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTElCUkFSWV9MT0FERURfRVZFTlQ6ICdsaWJyYXJ5TG9hZGVkJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJzZXIgZW5kZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQQVJTRVJfRU5ERURfRVZFTlQ6ICdwYXJzZXJFbmQnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGZvciBnZW9tZXRyeSBpZHMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBHRU9NRVRSWV9JRFNfRVZFTlQ6ICdnZW9tZXRyeUlkc0VuZCcsXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgc2hhcGVzIGltYWdlIGxvYWRlZCBldmVudC5cclxuICAgICAgICAgICAgICogTmVlZGVkLCBvdGhlcndpc2UgY291bGQgY2F1c2UgdGhlIGVycm9yOiBodHRwczovL2dpdGh1Yi5jb20vanl3YXJyZW4vd2ViZ2wtZGlzdG9ydC9pc3N1ZXMvNFxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU0hBUEVTX0lNQUdFX0xPQURFRF9FVkVOVDogJ3NoYXBlc0ltYWdlTG9hZGVkJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwYXR0ZXJucyBpbWFnZSBsb2FkZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQQVRURVJOU19JTUFHRV9MT0FERURfRVZFTlQ6ICdwYXR0ZXJuc0ltYWdlTG9hZGVkJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmaWd1cmVzIGltYWdlIGxvYWRlZCBldmVudC5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEZJR1VSRVNfSU1BR0VfTE9BREVEX0VWRU5UOiAnZmlndXJlc0ltYWdlTG9hZGVkJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSB0aW1lIHJhbmdlIGNoYW5nZWQgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUSU1FX1JBTkdFX0NIQU5HRUQ6ICdUaW1lUmFuZ2VDaGFuZ2VkJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBsZWdlbmQgY2hhbmdlZCBldmVudC5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIExFR0VORF9DSEFOR0VEOiAnTGVnZW5kQ2hhbmdlZCcsXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZXh0ZW5kZWQgdGVtcG9yYWwgbmF2aWdhdG9yIGxlZ2VuZCBjaGFuZ2VkIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRVhURU5ERURfVEVNUE9SQUxfTkFWSUdBVE9SX0xFR0VORF9DSEFOR0VEOiAnZXh0ZW5kZWRfdGVtcG9yYWxfbmF2aWdhdG9yX2xlZ2VuZCcsXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZXh0ZW5kZWQgdGVtcG9yYWwgbmF2aWdhdG9yIHRpbWUgYXhpcyBjaGFuZ2VkIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRVhURU5ERURfVEVNUE9SQUxfTkFWSUdBVE9SX1RJTUVfQ0hBTkdFRDogJ2V4dGVuZGVkX3RlbXBvcmFsX25hdmlnYXRvcl90aW1lJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBldmVudCBmb3IgdGhlIHJlc2l6ZSBvZiB0aGUgd2luZG93LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUkVTSVpFOiAncmVzaXplJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgYW5kIHRoZWlyIGtleSBjb2RlcyB0byBiZSB1c2VkIGJ5IFRpbWVDb250cm9sIGFuZCBFVE4uXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcmV0dXJucyB7e0xFRlRfQVJST1c6IG51bWJlciwgQV9LRVk6bnVtYmVyLCBSSUdIVF9BUlJPVzogbnVtYmVyLCBEX0tFWTogbnVtYmVyLCBET1dOX0FSUk9XOiBudW1iZXIsIFNfS0VZOiBudW1iZXIsIFVQX0FSUk9XOiBudW1iZXIsIFdfS0VZOiBudW1iZXJ9fSAtIHRoZSBsaXN0IG9mIGtleXMgYW5kIHRoZWlyIGtleSBjb2RlcyB0byBiZSB1c2VkIGJ5IFRpbWVDb250cm9sIGFuZCBFVE4uXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LmNhbWJpYXJlc2VhcmNoLmNvbS9hcnRpY2xlcy8xNS9qYXZhc2NyaXB0LWNoYXItY29kZXMta2V5LWNvZGVzIC0gS2V5IGNvZGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgR2lzcGxheURlZmF1bHRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRLZXlib2FyZEtleUNvZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIExFRlRfQVJST1c6IDM3LFxyXG4gICAgICAgICAgICBBX0tFWTogNjUsXHJcbiAgICAgICAgICAgIFJJR0hUX0FSUk9XOiAzOSxcclxuICAgICAgICAgICAgRF9LRVk6IDY4LFxyXG4gICAgICAgICAgICBET1dOX0FSUk9XOiA0MCxcclxuICAgICAgICAgICAgU19LRVk6IDgzLFxyXG4gICAgICAgICAgICBVUF9BUlJPVzogMzgsXHJcbiAgICAgICAgICAgIFdfS0VZOiA4N1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIE1hcCBWYXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBDYXRlZ29yaWNhbFZhcmlhYmxlLlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHthbnl9IG1hcFZhcmlhYmxlIC0gVGhlIHZhbHVlIGdpdmVuLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBDYXRlZ29yaWNhbFZhcmlhYmxlLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlEZWZhdWx0c1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNDYXRlZ29yaWNhbE1hcFZhcmlhYmxlKG1hcFZhcmlhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFZhcmlhYmxlIGluc3RhbmNlb2YgQ2F0ZWdvcmljYWxWYXJpYWJsZTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9HaXNwbGF5RGVmYXVsdHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQWlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7QUFDQTtBQUNBOzs7OztBQUtBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQXhEQTtBQTBEQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!*****************************************!*\
  !*** ./src/Gisplay/VVs/DataVariable.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Represents a variable. This variable has an external and an internal Name.\r\n * External name is the name of the variable on the dataset.\r\n * Internal name is the name the programmer gave to this variable.\r\n * @export\r\n * @class DataVariable\r\n */\nvar DataVariable = exports.DataVariable = function () {\n\n  /**\r\n   * Creates an instance of a Variable.\r\n   * @param {string} externalName - The external name for this variable.\r\n   * @param {string} internalName - The internal name for this variable.\r\n   * @memberof DataVariable\r\n   */\n  function DataVariable(externalName, internalName) {\n    _classCallCheck(this, DataVariable);\n\n    /**\r\n     * It's the external name of this variable\r\n     * @type {string}\r\n     */\n    this.externalName = externalName;\n    /**\r\n     * The internal name for this variable.\r\n     * @type {string}\r\n     */\n    this.internalName = internalName;\n  }\n\n  /**\r\n   * Returns the external name for this visual variable.\r\n   * @returns {string} - the external name of the visual variable.\r\n   * @memberof DataVariable\r\n   */\n\n\n  _createClass(DataVariable, [{\n    key: \"getExternalName\",\n    value: function getExternalName() {\n      return this.externalName;\n    }\n\n    /**\r\n     * Returns the internal name for this visual variable.\r\n     * @returns {string} - the internal name of the visual variable.\r\n     * @memberof DataVariable\r\n     */\n\n  }, {\n    key: \"getInternalName\",\n    value: function getInternalName() {\n      return this.internalName;\n    }\n  }]);\n\n  return DataVariable;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvRGF0YVZhcmlhYmxlLmpzPzgzNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJlcHJlc2VudHMgYSB2YXJpYWJsZS4gVGhpcyB2YXJpYWJsZSBoYXMgYW4gZXh0ZXJuYWwgYW5kIGFuIGludGVybmFsIE5hbWUuXHJcbiAqIEV4dGVybmFsIG5hbWUgaXMgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIG9uIHRoZSBkYXRhc2V0LlxyXG4gKiBJbnRlcm5hbCBuYW1lIGlzIHRoZSBuYW1lIHRoZSBwcm9ncmFtbWVyIGdhdmUgdG8gdGhpcyB2YXJpYWJsZS5cclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgRGF0YVZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGF0YVZhcmlhYmxlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBEYXRhVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdCdzIHRoZSBleHRlcm5hbCBuYW1lIG9mIHRoaXMgdmFyaWFibGVcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZXh0ZXJuYWxOYW1lID0gZXh0ZXJuYWxOYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbnRlcm5hbCBuYW1lIGZvciB0aGlzIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbE5hbWUgPSBpbnRlcm5hbE5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBleHRlcm5hbCBuYW1lIGZvciB0aGlzIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGV4dGVybmFsIG5hbWUgb2YgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBEYXRhVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0RXh0ZXJuYWxOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIG5hbWUgZm9yIHRoaXMgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIERhdGFWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRJbnRlcm5hbE5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxOYW1lO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L1ZWcy9EYXRhVmFyaWFibGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!*************************************!*\
  !*** ./src/Gisplay/GisplayError.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Custom Error to create a popup message to inform the user about a particular problem.\r\n * @export\r\n * @class GisplayError\r\n * @extends {Error}\r\n * @see https://medium.com/@xjamundx/custom-javascript-errors-in-es6-aa891b173f87\r\n */\nvar GisplayError = exports.GisplayError = function (_Error) {\n        _inherits(GisplayError, _Error);\n\n        /**\r\n         * Creates an instance of GisplayError.\r\n         * @param {string} message - The message to provide to the user.\r\n         * @see https://github.com/codrops/ModalWindowEffects\r\n         * @see https://codepen.io/SMLMRKHLMS/pen/rVYRLQ \r\n         * @memberof GisplayError\r\n         */\n        function GisplayError(message) {\n                _classCallCheck(this, GisplayError);\n\n                // Error.captureStackTrace(this, GisplayError);\n                var _this = _possibleConstructorReturn(this, (GisplayError.__proto__ || Object.getPrototypeOf(GisplayError)).call(this, message));\n\n                console.error(\"GisplayError\");\n                // document.getElementById('head').innerHTML = '';\n\n                // this.createErrorDialog(message);\n                /*  let modal = document.createElement('div');\r\n                 modal.className = 'modal';\r\n                 let content = document.createElement('div');\r\n                 content.className = 'content';\r\n                 content.innerHTML = message;\r\n                    modal.appendChild(content);\r\n                 document.body.appendChild(modal); */\n\n                var modal = document.createElement('div');\n                modal.className = 'gisplayModal';\n\n                var overlay = document.createElement('div');\n                overlay.className = 'gisplayModalOverlay';\n\n                var content = document.createElement('div');\n                content.className = 'gisplayModalContent';\n\n                var contentTitle = document.createElement('div'); //Title\n                var errorFoundParagraph = document.createElement('p'); //Paragraph in title\n                errorFoundParagraph.innerHTML = 'Error found:';\n                contentTitle.appendChild(errorFoundParagraph);\n                var contentMessage = document.createElement('p'); //Content message\n                contentMessage.innerHTML = message;\n                var checkDevTools = document.createElement('button'); //Open devtools button\n                checkDevTools.innerHTML = 'Open Developer tools for more information';\n\n                content.appendChild(contentTitle);\n                content.appendChild(contentMessage);\n                content.appendChild(checkDevTools);\n\n                modal.appendChild(overlay);\n                modal.appendChild(content);\n                document.body.appendChild(modal);\n                return _this;\n        }\n\n        _createClass(GisplayError, [{\n                key: 'createErrorDialog',\n                value: function createErrorDialog(message) {\n                        console.log(\"wut\");\n                        var modal = document.createElement('div');\n                        modal.className = 'modal';\n                        var content = document.createElement('div');\n                        content.className = 'content';\n                        content.innerHTML = message;\n\n                        modal.appendChild(content);\n                        document.body.appendChild(modal);\n                }\n        }]);\n\n        return GisplayError;\n}(Error);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5RXJyb3IuanM/NzNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIEN1c3RvbSBFcnJvciB0byBjcmVhdGUgYSBwb3B1cCBtZXNzYWdlIHRvIGluZm9ybSB0aGUgdXNlciBhYm91dCBhIHBhcnRpY3VsYXIgcHJvYmxlbS5cclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgR2lzcGxheUVycm9yXHJcbiAqIEBleHRlbmRzIHtFcnJvcn1cclxuICogQHNlZSBodHRwczovL21lZGl1bS5jb20vQHhqYW11bmR4L2N1c3RvbS1qYXZhc2NyaXB0LWVycm9ycy1pbi1lczYtYWE4OTFiMTczZjg3XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHaXNwbGF5RXJyb3IuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHByb3ZpZGUgdG8gdGhlIHVzZXIuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2Ryb3BzL01vZGFsV2luZG93RWZmZWN0c1xyXG4gICAgICogQHNlZSBodHRwczovL2NvZGVwZW4uaW8vU01MTVJLSExNUy9wZW4vclZZUkxRIFxyXG4gICAgICogQG1lbWJlcm9mIEdpc3BsYXlFcnJvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgR2lzcGxheUVycm9yKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiR2lzcGxheUVycm9yXCIpO1xyXG4gICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFkJykuaW5uZXJIVE1MID0gJyc7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuY3JlYXRlRXJyb3JEaWFsb2cobWVzc2FnZSk7XHJcbiAgICAgICAgLyogIGxldCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICBtb2RhbC5jbGFzc05hbWUgPSAnbW9kYWwnO1xyXG4gICAgICAgICBsZXQgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdjb250ZW50JztcclxuICAgICAgICAgY29udGVudC5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG4gXHJcbiAgICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsKTsgKi9cclxuXHJcbiAgICAgICAgbGV0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbW9kYWwuY2xhc3NOYW1lID0gJ2dpc3BsYXlNb2RhbCc7XHJcblxyXG4gICAgICAgIGxldCBvdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgb3ZlcmxheS5jbGFzc05hbWUgPSAnZ2lzcGxheU1vZGFsT3ZlcmxheSc7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29udGVudC5jbGFzc05hbWUgPSAnZ2lzcGxheU1vZGFsQ29udGVudCc7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50VGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy9UaXRsZVxyXG4gICAgICAgIGxldCBlcnJvckZvdW5kUGFyYWdyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpOyAvL1BhcmFncmFwaCBpbiB0aXRsZVxyXG4gICAgICAgIGVycm9yRm91bmRQYXJhZ3JhcGguaW5uZXJIVE1MID0gJ0Vycm9yIGZvdW5kOic7XHJcbiAgICAgICAgY29udGVudFRpdGxlLmFwcGVuZENoaWxkKGVycm9yRm91bmRQYXJhZ3JhcGgpO1xyXG4gICAgICAgIGxldCBjb250ZW50TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTsgLy9Db250ZW50IG1lc3NhZ2VcclxuICAgICAgICBjb250ZW50TWVzc2FnZS5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG4gICAgICAgIGxldCBjaGVja0RldlRvb2xzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7IC8vT3BlbiBkZXZ0b29scyBidXR0b25cclxuICAgICAgICBjaGVja0RldlRvb2xzLmlubmVySFRNTCA9ICdPcGVuIERldmVsb3BlciB0b29scyBmb3IgbW9yZSBpbmZvcm1hdGlvbic7XHJcblxyXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoY29udGVudFRpdGxlKTtcclxuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnRNZXNzYWdlKTtcclxuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGNoZWNrRGV2VG9vbHMpO1xyXG5cclxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChvdmVybGF5KTtcclxuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY3JlYXRlRXJyb3JEaWFsb2cobWVzc2FnZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwid3V0XCIpO1xyXG4gICAgICAgIGxldCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIG1vZGFsLmNsYXNzTmFtZSA9ICdtb2RhbCc7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdjb250ZW50JztcclxuICAgICAgICBjb250ZW50LmlubmVySFRNTCA9IG1lc3NhZ2U7XHJcblxyXG4gICAgICAgIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobW9kYWwpO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L0dpc3BsYXlFcnJvci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7Ozs7OztBQU9BOzs7QUFFQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4Q0E7QUF5Q0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQS9EQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/* no static exports found */
/* all exports used */
/*!************************************************!*\
  !*** ./src/Gisplay/VVs/CategoricalVariable.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CategoricalVariable = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MapVariable2 = __webpack_require__(/*! ./MapVariable */ 4);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../GisplayDefaults */ 0);\n\nvar _GisplayError = __webpack_require__(/*! ../GisplayError */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// import { GisplayMap } from '../Maps/GisplayMap';\n\n/**\r\n * Represents a categorical map variable.\r\n * Categorical data, is for those aspects of your data where you make a distinction between different groups, and where you typically can list a small number of categories. This includes product type, gender, age group, etc.\r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @export\r\n * @class CategoricalVariable\r\n */\nvar CategoricalVariable = exports.CategoricalVariable = function (_MapVariable) {\n    _inherits(CategoricalVariable, _MapVariable);\n\n    /**\r\n     * Creates an instance of CategoricalVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The name of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Map<string, string|number>} visualVariableMapping - The mapping for the given visual variable.\r\n     * @param {GisplayMap} gisplayMap - The GisplayMap. It's used when we need to get the colors for the variable.\r\n     * @memberof CategoricalVariable\r\n     */\n    function CategoricalVariable(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping, gisplayMap) {\n        _classCallCheck(this, CategoricalVariable);\n\n        /**\r\n         * The categories for this categorical variable.\r\n         * @type {Set<string>}\r\n         */\n        var _this = _possibleConstructorReturn(this, (CategoricalVariable.__proto__ || Object.getPrototypeOf(CategoricalVariable)).call(this, externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping));\n\n        _this.categories = new Set();\n        if (visualVariableMapping && visualVariableMapping.size > 0) {\n            //The mapping was given by the programmer (Map<\"ABC\"->\"red\", \"DEF\"->\"blue\" etc> )\n            /**\r\n             * Map containing the values for this categorical map variable and an integer to represent each of these values.\r\n             * @type {Map<string, number>} \r\n             */\n            _this.valueToIndexMap = _this._createCategoricalVarMap(visualVariableMapping.keys());\n            _this._setIndexToUsableValueMap();\n        }\n\n        /**  \r\n         * Boolean that stores true if class calcutation is required, false, otherwise.\r\n         * @type {boolean}\r\n         */\n        _this.classCalculationRequiredBool = _this.visualVariableMapping.size === 0;\n        /**\r\n         * The GisplayMap object.\r\n         * @type {GisplayMap}\r\n         */\n        _this.gisplayMap = gisplayMap;\n        console.error(_this);\n        return _this;\n    }\n\n    /**\r\n     * For each category in this categorical variable, create one index which will be used as substitute.\r\n     * This replacement will save up a lot of space. \r\n     * @param {Array<string>} values - The categories that this visual variable holds. \r\n     * @returns {Map<string, number>} - the map which contains a sequential integer to represent each category.\r\n     * @memberof CategoricalVariable\r\n     */\n\n\n    _createClass(CategoricalVariable, [{\n        key: '_createCategoricalVarMap',\n        value: function _createCategoricalVarMap(values) {\n            var map = new Map();\n            var index = 0;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var value = _step.value;\n\n                    map.set(value, index++);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return map;\n        }\n\n        /**\r\n         * Returns the value to index map.\r\n         * @returns {Map<string, number>} - the map containing the values for this categorical visual variable and an integer to represent each of these values.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'getValueIndexMapping',\n        value: function getValueIndexMapping() {\n            return this.valueToIndexMap;\n        }\n\n        /**\r\n         * Returns the index of the given category.\r\n         * @param {string} value - The category to find. \r\n         * @returns {number} - the index of the given category.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'findIndex',\n        value: function findIndex(value) {\n            return this.getValueIndexMapping().get(value);\n        }\n\n        /**\r\n         * Set each index (of each category) to it's respective value (color, or number in the shape/texture image).\r\n         * E.g. 0 -> [255,0,0] etc or 0 -> 14 (index in image).\r\n         * @private\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: '_setIndexToUsableValueMap',\n        value: function _setIndexToUsableValueMap() {\n            var typeOfVisualVariable = this.getTypeOfVisualVariable();\n            var valueToIndexMapKeys = this.valueToIndexMap.keys();\n            console.warn(valueToIndexMapKeys);\n            console.warn(this.getVisualVariableMapping());\n\n            switch (typeOfVisualVariable) {\n                case _GisplayDefaults.GisplayDefaults.COLOR():\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = valueToIndexMapKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var mapkey = _step2.value;\n\n                            var index = this.valueToIndexMap.get(mapkey); // 0, 1..\n                            var color = this.visualVariableMapping.get(mapkey); // [255, 0, 0], [122, 220, 85] ...\n                            this.indexToUsableValueMap.set(index, color);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n\n                    break;\n                case _GisplayDefaults.GisplayDefaults.SHAPE():\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n\n                    try {\n                        for (var _iterator3 = valueToIndexMapKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var _mapkey = _step3.value;\n                            // \"Y\", \"N\"\n                            var _index = this.valueToIndexMap.get(_mapkey); // 0, 1..\n                            var shapeName = this.visualVariableMapping.get(_mapkey); // \"terrain\", \"bricks\", \"triangle\"\n                            var shapeIndex = _GisplayDefaults.GisplayDefaults.findShapeIndex(shapeName); // 6, 7, 12, 13\n                            // console.log(index, shapeName, textureIndex);\n                            this.indexToUsableValueMap.set(_index, shapeIndex);\n                        }\n                    } catch (err) {\n                        _didIteratorError3 = true;\n                        _iteratorError3 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                _iterator3.return();\n                            }\n                        } finally {\n                            if (_didIteratorError3) {\n                                throw _iteratorError3;\n                            }\n                        }\n                    }\n\n                    break;\n                case _GisplayDefaults.GisplayDefaults.TEXTURE():\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = valueToIndexMapKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var _mapkey2 = _step4.value;\n                            // \"Y\", \"N\"\n                            var _index2 = this.valueToIndexMap.get(_mapkey2); // 0, 1..\n                            var patternName = this.visualVariableMapping.get(_mapkey2); // \"terrain\", \"bricks\", \"triangle\"\n                            var patternIndex = _GisplayDefaults.GisplayDefaults.findPatternIndex(patternName); // 6, 7, 12, 13\n                            console.log(_index2, patternName, patternIndex);\n                            this.indexToUsableValueMap.set(_index2, patternIndex);\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n\n                    break;\n                case _GisplayDefaults.GisplayDefaults.SIZE():\n                    throw new _GisplayError.GisplayError(\"Visual variable: size, can't be used with a categorical variable.\");\n                case _GisplayDefaults.GisplayDefaults.ORIENTATION():\n                    console.log(valueToIndexMapKeys, this.valueToIndexMap, this.visualVariableMapping);\n                    var _iteratorNormalCompletion5 = true;\n                    var _didIteratorError5 = false;\n                    var _iteratorError5 = undefined;\n\n                    try {\n                        for (var _iterator5 = valueToIndexMapKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                            var _mapkey3 = _step5.value;\n                            // \"Y\", \"N\"\n                            var _index3 = this.valueToIndexMap.get(_mapkey3); // 0, 1..\n                            var orientationValue = this.visualVariableMapping.get(_mapkey3); // 0, 28, 90 (degrees)\n                            console.log(_index3, orientationValue);\n                            this.indexToUsableValueMap.set(_index3, orientationValue);\n                        }\n                    } catch (err) {\n                        _didIteratorError5 = true;\n                        _iteratorError5 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                _iterator5.return();\n                            }\n                        } finally {\n                            if (_didIteratorError5) {\n                                throw _iteratorError5;\n                            }\n                        }\n                    }\n\n                // throw new Error(\"Index to orientation value not yet implemented in Categorical Variable. Should look like COLOR + SHAPE/TEXTURE combined\");\n            }\n            console.log(\"CAT VV_TO_INDEX_MAP =========================\", this.indexToUsableValueMap);\n        }\n\n        /**\r\n         * Add a categorie to the set of categories in this categorical variable.\r\n         * @param {string} category - The category to add to this categorical variable. \r\n         */\n\n    }, {\n        key: 'addCategory',\n        value: function addCategory(category) {\n            this.categories.add(category);\n        }\n\n        /**\r\n         * Add the given categories to the set of categories of this Categorical variable.\r\n         * @param {Set<string>} categories - The categories given. \r\n         */\n\n    }, {\n        key: 'addCategories',\n        value: function addCategories(categories) {\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = categories.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var category = _step6.value;\n\n                    this.addCategory(category);\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Returns the set of categories for this Categorical variable.\r\n         * @returns {Set<string>} - the set of categories for this Categorical variable.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'getCategories',\n        value: function getCategories() {\n            return this.categories;\n        }\n\n        /**\r\n         * Returns the number of categories for this categorical variable.\r\n         * @returns {number} - the number of categories for this categorical variable.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'getNumCategories',\n        value: function getNumCategories() {\n            return this.categories.size !== 0 ? this.categories.size : this.getVisualVariableMapping().size;\n        }\n\n        /**\r\n         * Update the information when all categories are on the Set. \r\n         * Used when the categories weren't given by the programmer.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'updateCategoricalInformation',\n        value: function updateCategoricalInformation() {\n            this.valueToIndexMap = this._createCategoricalVarMap(this.categories.keys());\n\n            var categories = Array.from(this.categories);\n            console.error(this.valueToIndexMap.size);\n            if (this.valueToIndexMap.size < 2) throw new _GisplayError.GisplayError('Only one category (' + Array.from(this.valueToIndexMap.keys()) + ') in the dataset. ');\n            var colors = this.gisplayMap.getDefaultColors(this.valueToIndexMap.size, _GisplayDefaults.GisplayDefaults.QUALITATIVE());\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n                for (var _iterator7 = categories.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                    var _step7$value = _slicedToArray(_step7.value, 2),\n                        i = _step7$value[0],\n                        category = _step7$value[1];\n\n                    this.visualVariableMapping.set(category, colors[i]);\n                }\n            } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                        _iterator7.return();\n                    }\n                } finally {\n                    if (_didIteratorError7) {\n                        throw _iteratorError7;\n                    }\n                }\n            }\n\n            this._setIndexToUsableValueMap();\n        }\n\n        /**\r\n         * This map variable requires it's classes to be calculated or not. Categorical variables always return false.\r\n         * @returns {boolean} - true, if we need to calculate the classes, false, otherwise.\r\n         * @memberof CategoricalVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return this.classCalculationRequiredBool; // the map has no K->V pairs\n        }\n    }]);\n\n    return CategoricalVariable;\n}(_MapVariable2.MapVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvQ2F0ZWdvcmljYWxWYXJpYWJsZS5qcz8yZGJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcFZhcmlhYmxlIH0gZnJvbSAnLi9NYXBWYXJpYWJsZSc7XHJcbmltcG9ydCB7IEdpc3BsYXlEZWZhdWx0cyB9IGZyb20gJy4uL0dpc3BsYXlEZWZhdWx0cyc7XHJcbmltcG9ydCB7IEdpc3BsYXlFcnJvciB9IGZyb20gJy4uL0dpc3BsYXlFcnJvcic7XHJcbi8vIGltcG9ydCB7IEdpc3BsYXlNYXAgfSBmcm9tICcuLi9NYXBzL0dpc3BsYXlNYXAnO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjYXRlZ29yaWNhbCBtYXAgdmFyaWFibGUuXHJcbiAqIENhdGVnb3JpY2FsIGRhdGEsIGlzIGZvciB0aG9zZSBhc3BlY3RzIG9mIHlvdXIgZGF0YSB3aGVyZSB5b3UgbWFrZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gZGlmZmVyZW50IGdyb3VwcywgYW5kIHdoZXJlIHlvdSB0eXBpY2FsbHkgY2FuIGxpc3QgYSBzbWFsbCBudW1iZXIgb2YgY2F0ZWdvcmllcy4gVGhpcyBpbmNsdWRlcyBwcm9kdWN0IHR5cGUsIGdlbmRlciwgYWdlIGdyb3VwLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9lYWdlcmV5ZXMub3JnL2Jhc2ljcy9kYXRhLWNvbnRpbnVvdXMtdnMtY2F0ZWdvcmljYWxcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQ2F0ZWdvcmljYWxWYXJpYWJsZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENhdGVnb3JpY2FsVmFyaWFibGUgZXh0ZW5kcyBNYXBWYXJpYWJsZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENhdGVnb3JpY2FsVmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZXJuYWxOYW1lIC0gVGhlIGV4dGVybmFsIG5hbWUgZm9yIHRoaXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJuYWxOYW1lIC0gVGhlIGludGVybmFsIG5hbWUgZm9yIHRoaXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU9mVmlzdWFsVmFyaWFibGUgLSBUaGUgbmFtZSBvZiB2aXN1YWwgdmFyaWFibGUgKGUuZy4gY29sb3IsIHNoYXBlLCBzaXplLCBvcmllbnRhdGlvbiBvciB0ZXh0dXJlKS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJWYXJpYWJsZVF1YWxpZmllciAtIFRoZSBzaGFkZXIgdmFyaWFibGUgcXVhbGlmaWVyLiBcclxuICAgICAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nfG51bWJlcj59IHZpc3VhbFZhcmlhYmxlTWFwcGluZyAtIFRoZSBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQHBhcmFtIHtHaXNwbGF5TWFwfSBnaXNwbGF5TWFwIC0gVGhlIEdpc3BsYXlNYXAuIEl0J3MgdXNlZCB3aGVuIHdlIG5lZWQgdG8gZ2V0IHRoZSBjb2xvcnMgZm9yIHRoZSB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZywgZ2lzcGxheU1hcCkge1xyXG4gICAgICAgIHN1cGVyKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhdGVnb3JpZXMgZm9yIHRoaXMgY2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBpZiAodmlzdWFsVmFyaWFibGVNYXBwaW5nICYmIHZpc3VhbFZhcmlhYmxlTWFwcGluZy5zaXplID4gMCkgeyAvL1RoZSBtYXBwaW5nIHdhcyBnaXZlbiBieSB0aGUgcHJvZ3JhbW1lciAoTWFwPFwiQUJDXCItPlwicmVkXCIsIFwiREVGXCItPlwiYmx1ZVwiIGV0Yz4gKVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFwIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBmb3IgdGhpcyBjYXRlZ29yaWNhbCBtYXAgdmFyaWFibGUgYW5kIGFuIGludGVnZXIgdG8gcmVwcmVzZW50IGVhY2ggb2YgdGhlc2UgdmFsdWVzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlVG9JbmRleE1hcCA9IHRoaXMuX2NyZWF0ZUNhdGVnb3JpY2FsVmFyTWFwKHZpc3VhbFZhcmlhYmxlTWFwcGluZy5rZXlzKCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbmRleFRvVXNhYmxlVmFsdWVNYXAoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiAgXHJcbiAgICAgICAgICogQm9vbGVhbiB0aGF0IHN0b3JlcyB0cnVlIGlmIGNsYXNzIGNhbGN1dGF0aW9uIGlzIHJlcXVpcmVkLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3NDYWxjdWxhdGlvblJlcXVpcmVkQm9vbCA9IHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nLnNpemUgPT09IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIEdpc3BsYXlNYXAgb2JqZWN0LlxyXG4gICAgICAgICAqIEB0eXBlIHtHaXNwbGF5TWFwfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2lzcGxheU1hcCA9IGdpc3BsYXlNYXA7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGNhdGVnb3J5IGluIHRoaXMgY2F0ZWdvcmljYWwgdmFyaWFibGUsIGNyZWF0ZSBvbmUgaW5kZXggd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHN1YnN0aXR1dGUuXHJcbiAgICAgKiBUaGlzIHJlcGxhY2VtZW50IHdpbGwgc2F2ZSB1cCBhIGxvdCBvZiBzcGFjZS4gXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZhbHVlcyAtIFRoZSBjYXRlZ29yaWVzIHRoYXQgdGhpcyB2aXN1YWwgdmFyaWFibGUgaG9sZHMuIFxyXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcj59IC0gdGhlIG1hcCB3aGljaCBjb250YWlucyBhIHNlcXVlbnRpYWwgaW50ZWdlciB0byByZXByZXNlbnQgZWFjaCBjYXRlZ29yeS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9jcmVhdGVDYXRlZ29yaWNhbFZhck1hcCh2YWx1ZXMpIHtcclxuICAgICAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKVxyXG4gICAgICAgICAgICBtYXAuc2V0KHZhbHVlLCBpbmRleCsrKTtcclxuICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgdG8gaW5kZXggbWFwLlxyXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcj59IC0gdGhlIG1hcCBjb250YWluaW5nIHRoZSB2YWx1ZXMgZm9yIHRoaXMgY2F0ZWdvcmljYWwgdmlzdWFsIHZhcmlhYmxlIGFuZCBhbiBpbnRlZ2VyIHRvIHJlcHJlc2VudCBlYWNoIG9mIHRoZXNlIHZhbHVlcy5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFZhbHVlSW5kZXhNYXBwaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVG9JbmRleE1hcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBjYXRlZ29yeS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFRoZSBjYXRlZ29yeSB0byBmaW5kLiBcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBjYXRlZ29yeS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGZpbmRJbmRleCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlSW5kZXhNYXBwaW5nKCkuZ2V0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBlYWNoIGluZGV4IChvZiBlYWNoIGNhdGVnb3J5KSB0byBpdCdzIHJlc3BlY3RpdmUgdmFsdWUgKGNvbG9yLCBvciBudW1iZXIgaW4gdGhlIHNoYXBlL3RleHR1cmUgaW1hZ2UpLlxyXG4gICAgICogRS5nLiAwIC0+IFsyNTUsMCwwXSBldGMgb3IgMCAtPiAxNCAoaW5kZXggaW4gaW1hZ2UpLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9zZXRJbmRleFRvVXNhYmxlVmFsdWVNYXAoKSB7XHJcbiAgICAgICAgbGV0IHR5cGVPZlZpc3VhbFZhcmlhYmxlID0gdGhpcy5nZXRUeXBlT2ZWaXN1YWxWYXJpYWJsZSgpO1xyXG4gICAgICAgIGxldCB2YWx1ZVRvSW5kZXhNYXBLZXlzID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAua2V5cygpO1xyXG4gICAgICAgIGNvbnNvbGUud2Fybih2YWx1ZVRvSW5kZXhNYXBLZXlzKTtcclxuICAgICAgICBjb25zb2xlLndhcm4odGhpcy5nZXRWaXN1YWxWYXJpYWJsZU1hcHBpbmcoKSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZU9mVmlzdWFsVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgY2FzZSBHaXNwbGF5RGVmYXVsdHMuQ09MT1IoKTpcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG1hcGtleSBvZiB2YWx1ZVRvSW5kZXhNYXBLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAuZ2V0KG1hcGtleSk7IC8vIDAsIDEuLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nLmdldChtYXBrZXkpOyAvLyBbMjU1LCAwLCAwXSwgWzEyMiwgMjIwLCA4NV0gLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXAuc2V0KGluZGV4LCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBHaXNwbGF5RGVmYXVsdHMuU0hBUEUoKTpcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG1hcGtleSBvZiB2YWx1ZVRvSW5kZXhNYXBLZXlzKSB7IC8vIFwiWVwiLCBcIk5cIlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMudmFsdWVUb0luZGV4TWFwLmdldChtYXBrZXkpOyAvLyAwLCAxLi5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2hhcGVOYW1lID0gdGhpcy52aXN1YWxWYXJpYWJsZU1hcHBpbmcuZ2V0KG1hcGtleSk7IC8vIFwidGVycmFpblwiLCBcImJyaWNrc1wiLCBcInRyaWFuZ2xlXCJcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2hhcGVJbmRleCA9IEdpc3BsYXlEZWZhdWx0cy5maW5kU2hhcGVJbmRleChzaGFwZU5hbWUpOyAvLyA2LCA3LCAxMiwgMTNcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpbmRleCwgc2hhcGVOYW1lLCB0ZXh0dXJlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwLnNldChpbmRleCwgc2hhcGVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBHaXNwbGF5RGVmYXVsdHMuVEVYVFVSRSgpOlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbWFwa2V5IG9mIHZhbHVlVG9JbmRleE1hcEtleXMpIHsgLy8gXCJZXCIsIFwiTlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAuZ2V0KG1hcGtleSk7IC8vIDAsIDEuLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuTmFtZSA9IHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nLmdldChtYXBrZXkpOyAvLyBcInRlcnJhaW5cIiwgXCJicmlja3NcIiwgXCJ0cmlhbmdsZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdHRlcm5JbmRleCA9IEdpc3BsYXlEZWZhdWx0cy5maW5kUGF0dGVybkluZGV4KHBhdHRlcm5OYW1lKTsgLy8gNiwgNywgMTIsIDEzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZXgsIHBhdHRlcm5OYW1lLCBwYXR0ZXJuSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwLnNldChpbmRleCwgcGF0dGVybkluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEdpc3BsYXlEZWZhdWx0cy5TSVpFKCk6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKFwiVmlzdWFsIHZhcmlhYmxlOiBzaXplLCBjYW4ndCBiZSB1c2VkIHdpdGggYSBjYXRlZ29yaWNhbCB2YXJpYWJsZS5cIik7XHJcbiAgICAgICAgICAgIGNhc2UgR2lzcGxheURlZmF1bHRzLk9SSUVOVEFUSU9OKCk6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZVRvSW5kZXhNYXBLZXlzLCB0aGlzLnZhbHVlVG9JbmRleE1hcCwgdGhpcy52aXN1YWxWYXJpYWJsZU1hcHBpbmcpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbWFwa2V5IG9mIHZhbHVlVG9JbmRleE1hcEtleXMpIHsgLy8gXCJZXCIsIFwiTlwiXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy52YWx1ZVRvSW5kZXhNYXAuZ2V0KG1hcGtleSk7IC8vIDAsIDEuLlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmllbnRhdGlvblZhbHVlID0gdGhpcy52aXN1YWxWYXJpYWJsZU1hcHBpbmcuZ2V0KG1hcGtleSk7IC8vIDAsIDI4LCA5MCAoZGVncmVlcylcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRleCwgb3JpZW50YXRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXAuc2V0KGluZGV4LCBvcmllbnRhdGlvblZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggdG8gb3JpZW50YXRpb24gdmFsdWUgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBDYXRlZ29yaWNhbCBWYXJpYWJsZS4gU2hvdWxkIGxvb2sgbGlrZSBDT0xPUiArIFNIQVBFL1RFWFRVUkUgY29tYmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ0FUIFZWX1RPX0lOREVYX01BUCA9PT09PT09PT09PT09PT09PT09PT09PT09XCIsIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGNhdGVnb3JpZSB0byB0aGUgc2V0IG9mIGNhdGVnb3JpZXMgaW4gdGhpcyBjYXRlZ29yaWNhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAtIFRoZSBjYXRlZ29yeSB0byBhZGQgdG8gdGhpcyBjYXRlZ29yaWNhbCB2YXJpYWJsZS4gXHJcbiAgICAgKi9cclxuICAgIGFkZENhdGVnb3J5KGNhdGVnb3J5KSB7XHJcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGdpdmVuIGNhdGVnb3JpZXMgdG8gdGhlIHNldCBvZiBjYXRlZ29yaWVzIG9mIHRoaXMgQ2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBjYXRlZ29yaWVzIC0gVGhlIGNhdGVnb3JpZXMgZ2l2ZW4uIFxyXG4gICAgICovXHJcbiAgICBhZGRDYXRlZ29yaWVzKGNhdGVnb3JpZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGVnb3JpZXMua2V5cygpKVxyXG4gICAgICAgICAgICB0aGlzLmFkZENhdGVnb3J5KGNhdGVnb3J5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNldCBvZiBjYXRlZ29yaWVzIGZvciB0aGlzIENhdGVnb3JpY2FsIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge1NldDxzdHJpbmc+fSAtIHRoZSBzZXQgb2YgY2F0ZWdvcmllcyBmb3IgdGhpcyBDYXRlZ29yaWNhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldENhdGVnb3JpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F0ZWdvcmllcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjYXRlZ29yaWVzIGZvciB0aGlzIGNhdGVnb3JpY2FsIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGNhdGVnb3JpZXMgZm9yIHRoaXMgY2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2F0ZWdvcmljYWxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXROdW1DYXRlZ29yaWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhdGVnb3JpZXMuc2l6ZSAhPT0gMCA/IHRoaXMuY2F0ZWdvcmllcy5zaXplIDogdGhpcy5nZXRWaXN1YWxWYXJpYWJsZU1hcHBpbmcoKS5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBpbmZvcm1hdGlvbiB3aGVuIGFsbCBjYXRlZ29yaWVzIGFyZSBvbiB0aGUgU2V0LiBcclxuICAgICAqIFVzZWQgd2hlbiB0aGUgY2F0ZWdvcmllcyB3ZXJlbid0IGdpdmVuIGJ5IHRoZSBwcm9ncmFtbWVyLlxyXG4gICAgICogQG1lbWJlcm9mIENhdGVnb3JpY2FsVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ2F0ZWdvcmljYWxJbmZvcm1hdGlvbigpIHtcclxuICAgICAgICB0aGlzLnZhbHVlVG9JbmRleE1hcCA9IHRoaXMuX2NyZWF0ZUNhdGVnb3JpY2FsVmFyTWFwKHRoaXMuY2F0ZWdvcmllcy5rZXlzKCkpO1xyXG5cclxuICAgICAgICBsZXQgY2F0ZWdvcmllcyA9IEFycmF5LmZyb20odGhpcy5jYXRlZ29yaWVzKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMudmFsdWVUb0luZGV4TWFwLnNpemUpO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlVG9JbmRleE1hcC5zaXplIDwgMilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEdpc3BsYXlFcnJvcihgT25seSBvbmUgY2F0ZWdvcnkgKCR7QXJyYXkuZnJvbSh0aGlzLnZhbHVlVG9JbmRleE1hcC5rZXlzKCkpfSkgaW4gdGhlIGRhdGFzZXQuIGApO1xyXG4gICAgICAgIGxldCBjb2xvcnMgPSB0aGlzLmdpc3BsYXlNYXAuZ2V0RGVmYXVsdENvbG9ycyh0aGlzLnZhbHVlVG9JbmRleE1hcC5zaXplLCBHaXNwbGF5RGVmYXVsdHMuUVVBTElUQVRJVkUoKSk7XHJcbiAgICAgICAgZm9yIChsZXQgW2ksIGNhdGVnb3J5XSBvZiBjYXRlZ29yaWVzLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgdGhpcy52aXN1YWxWYXJpYWJsZU1hcHBpbmcuc2V0KGNhdGVnb3J5LCBjb2xvcnNbaV0pO1xyXG5cclxuICAgICAgICB0aGlzLl9zZXRJbmRleFRvVXNhYmxlVmFsdWVNYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWFwIHZhcmlhYmxlIHJlcXVpcmVzIGl0J3MgY2xhc3NlcyB0byBiZSBjYWxjdWxhdGVkIG9yIG5vdC4gQ2F0ZWdvcmljYWwgdmFyaWFibGVzIGFsd2F5cyByZXR1cm4gZmFsc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlLCBpZiB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgY2xhc3NlcywgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYXRlZ29yaWNhbFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0NhbGN1bGF0aW9uUmVxdWlyZWRCb29sOyAvLyB0aGUgbWFwIGhhcyBubyBLLT5WIHBhaXJzXHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL0NhdGVnb3JpY2FsVmFyaWFibGUuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7OztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUExQkE7QUEyQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQXBDQTtBQXNDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFQQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/VVs/MapVariable.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MapVariable = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable2 = __webpack_require__(/*! ./DataVariable */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Represents a Map Variable.\r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @see http://leg.ufpr.br/~silvia/CE055/node8.html\r\n * @export\r\n * @class MapVariable\r\n */\nvar MapVariable = exports.MapVariable = function (_DataVariable) {\n    _inherits(MapVariable, _DataVariable);\n\n    /**\r\n     * Creates an instance of MapVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Array<string|number>|Map<string, string|number>} visualVariableMapping - The mapping for the given type of visual variable.\r\n     * @memberof MapVariable\r\n     */\n    function MapVariable(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping) {\n        _classCallCheck(this, MapVariable);\n\n        /**\r\n         * The type of visual variable mapping (e.g. color, shape, size, orientation or texture).\r\n         * @type {string}\r\n         */\n        var _this = _possibleConstructorReturn(this, (MapVariable.__proto__ || Object.getPrototypeOf(MapVariable)).call(this, externalName, internalName));\n\n        _this.typeOfVisualVariable = typeOfVisualVariable;\n        /**\r\n         * The access qualifier for the shader variable.\r\n         * @type {string}\r\n         */\n        _this.shaderQualifier = shaderVariableQualifier;\n        /**\r\n         * The shader qualifier is of type attribute or not.\r\n         * @type {boolean} \r\n         */\n        _this.qualifierIsAttributeBool = shaderVariableQualifier === 'attribute';\n        /**\r\n         * The mapping between the values and the type of visual variable availabe values.\r\n         * E.g. 'THEFT' => 'triangle'\r\n         * @type {Map<string, string>|Array<string|number>}\r\n         */\n        _this.visualVariableMapping = visualVariableMapping;\n        /**\r\n         * The mapping between each class/category index and it's visual variable usable value.\r\n         * Possible keys: 0 .... n-1\r\n         * Possible values: 1) Array of numbers for color\r\n         *                  2) Index number for shapes and textures\r\n         *                  3) Number for size and orientation\r\n         * E.g. 'THEFT' => 'triangle' => 8 (8 is the index of the triangle in the shapes map)\r\n         *      'NO THEFT' => 'square' => 4\r\n         * Then we would have Map( 0 -> 8, 1 -> 4)\r\n         * @type {Map<number,Array<number>|number>}\r\n         */\n        _this.indexToUsableValueMap = new Map();\n        return _this;\n    }\n\n    /**\r\n     * Returns the type of visual variable (e.g. color, shape, size, orientation or texture) that this map variable will be mapped to.\r\n     * @returns {string} - the type of visual variable mapping (e.g. color, shape, size, orientation or texture).\r\n     * @memberof MapVariable\r\n     */\n\n\n    _createClass(MapVariable, [{\n        key: 'getTypeOfVisualVariable',\n        value: function getTypeOfVisualVariable() {\n            return this.typeOfVisualVariable;\n        }\n\n        /**\r\n         * Returns the mapping for the type of visual variable. \r\n         * It can be a Object<Key, Value> if it's categorical, an array of strings or array of numbers. \r\n         * @returns {Map<string, string>|Array<string|number>} - the mappings for this visual variable.\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'getVisualVariableMapping',\n        value: function getVisualVariableMapping() {\n            return this.visualVariableMapping;\n            //Array number (Cont no size e orientation)\n            //Array string (Cont para color, size e orientation + Cat para color)\n            //Object K->V (Cat para shape, texture e orientation)\n        }\n\n        /**\r\n         * This map variable requires it's classes to be calculated or not. Categorical variables always return false.\r\n         * @returns {boolean} - true, if we need to calculate the classes, false, otherwise.\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return false;\n        }\n\n        /**\r\n         * Returns the mapping between each class/category and it's visual variable usable value.\r\n         * @returns {Map<number,Array<number>|number>} - the mapping between each class/category and it's visual variable usable value.\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'getIndexToUSableValueMap',\n        value: function getIndexToUSableValueMap() {\n            return this.indexToUsableValueMap;\n        }\n\n        /**\r\n         * The value associated with the given index.\r\n         * E.g. [255,0,0] for color or 57 for size/orientation or 3 for shape/texture.\r\n         * @param {number} index - The index of the visual variable.\r\n         * @returns {Array<number>|number>}\r\n         * @memberof MapVariable\r\n         */\n\n    }, {\n        key: 'findUsableValue',\n        value: function findUsableValue(index) {\n            return this.indexToUsableValueMap.get(index);\n        }\n\n        /**\r\n         * The access qualifier for the shader variable \r\n         * @returns {string} - the access qualifier for the shader variable \r\n         * @memberOf MapVariable\r\n         */\n\n    }, {\n        key: 'getShaderVariableQualifier',\n        value: function getShaderVariableQualifier() {\n            return this.shaderQualifier;\n        }\n\n        /**\r\n         * Returns true if the shader qualifier is equal to attribute, false, otherwise.\r\n         * @returns {boolean} - true if the shader qualifier is equal to attribute, false, otherwise.\r\n         * @memberOf MapVariable\r\n         */\n\n    }, {\n        key: 'qualifierIsAttribute',\n        value: function qualifierIsAttribute() {\n            return this.qualifierIsAttributeBool;\n        }\n    }]);\n\n    return MapVariable;\n}(_DataVariable2.DataVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvTWFwVmFyaWFibGUuanM/MzQ4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVmFyaWFibGUgfSBmcm9tICcuL0RhdGFWYXJpYWJsZSc7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBNYXAgVmFyaWFibGUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9lYWdlcmV5ZXMub3JnL2Jhc2ljcy9kYXRhLWNvbnRpbnVvdXMtdnMtY2F0ZWdvcmljYWxcclxuICogQHNlZSBodHRwOi8vbGVnLnVmcHIuYnIvfnNpbHZpYS9DRTA1NS9ub2RlOC5odG1sXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIE1hcFZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWFwVmFyaWFibGUgZXh0ZW5kcyBEYXRhVmFyaWFibGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlT2ZWaXN1YWxWYXJpYWJsZSAtIFRoZSB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZSAoZS5nLiBjb2xvciwgc2hhcGUsIHNpemUsIG9yaWVudGF0aW9uIG9yIHRleHR1cmUpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyIC0gVGhlIHNoYWRlciB2YXJpYWJsZSBxdWFsaWZpZXIuIFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8bnVtYmVyPnxNYXA8c3RyaW5nLCBzdHJpbmd8bnVtYmVyPn0gdmlzdWFsVmFyaWFibGVNYXBwaW5nIC0gVGhlIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSwgdHlwZU9mVmlzdWFsVmFyaWFibGUsIHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyLCB2aXN1YWxWYXJpYWJsZU1hcHBpbmcpIHtcclxuICAgICAgICBzdXBlcihleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdmlzdWFsIHZhcmlhYmxlIG1hcHBpbmcgKGUuZy4gY29sb3IsIHNoYXBlLCBzaXplLCBvcmllbnRhdGlvbiBvciB0ZXh0dXJlKS5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZU9mVmlzdWFsVmFyaWFibGUgPSB0eXBlT2ZWaXN1YWxWYXJpYWJsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYWNjZXNzIHF1YWxpZmllciBmb3IgdGhlIHNoYWRlciB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hhZGVyUXVhbGlmaWVyID0gc2hhZGVyVmFyaWFibGVRdWFsaWZpZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYWRlciBxdWFsaWZpZXIgaXMgb2YgdHlwZSBhdHRyaWJ1dGUgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnF1YWxpZmllcklzQXR0cmlidXRlQm9vbCA9IHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyID09PSAnYXR0cmlidXRlJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFwcGluZyBiZXR3ZWVuIHRoZSB2YWx1ZXMgYW5kIHRoZSB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZSBhdmFpbGFiZSB2YWx1ZXMuXHJcbiAgICAgICAgICogRS5nLiAnVEhFRlQnID0+ICd0cmlhbmdsZSdcclxuICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPnxBcnJheTxzdHJpbmd8bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpc3VhbFZhcmlhYmxlTWFwcGluZyA9IHZpc3VhbFZhcmlhYmxlTWFwcGluZztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFwcGluZyBiZXR3ZWVuIGVhY2ggY2xhc3MvY2F0ZWdvcnkgaW5kZXggYW5kIGl0J3MgdmlzdWFsIHZhcmlhYmxlIHVzYWJsZSB2YWx1ZS5cclxuICAgICAgICAgKiBQb3NzaWJsZSBrZXlzOiAwIC4uLi4gbi0xXHJcbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzOiAxKSBBcnJheSBvZiBudW1iZXJzIGZvciBjb2xvclxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgMikgSW5kZXggbnVtYmVyIGZvciBzaGFwZXMgYW5kIHRleHR1cmVzXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAzKSBOdW1iZXIgZm9yIHNpemUgYW5kIG9yaWVudGF0aW9uXHJcbiAgICAgICAgICogRS5nLiAnVEhFRlQnID0+ICd0cmlhbmdsZScgPT4gOCAoOCBpcyB0aGUgaW5kZXggb2YgdGhlIHRyaWFuZ2xlIGluIHRoZSBzaGFwZXMgbWFwKVxyXG4gICAgICAgICAqICAgICAgJ05PIFRIRUZUJyA9PiAnc3F1YXJlJyA9PiA0XHJcbiAgICAgICAgICogVGhlbiB3ZSB3b3VsZCBoYXZlIE1hcCggMCAtPiA4LCAxIC0+IDQpXHJcbiAgICAgICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8bnVtYmVyPnxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB2aXN1YWwgdmFyaWFibGUgKGUuZy4gY29sb3IsIHNoYXBlLCBzaXplLCBvcmllbnRhdGlvbiBvciB0ZXh0dXJlKSB0aGF0IHRoaXMgbWFwIHZhcmlhYmxlIHdpbGwgYmUgbWFwcGVkIHRvLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgdHlwZSBvZiB2aXN1YWwgdmFyaWFibGUgbWFwcGluZyAoZS5nLiBjb2xvciwgc2hhcGUsIHNpemUsIG9yaWVudGF0aW9uIG9yIHRleHR1cmUpLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFR5cGVPZlZpc3VhbFZhcmlhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVPZlZpc3VhbFZhcmlhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFwcGluZyBmb3IgdGhlIHR5cGUgb2YgdmlzdWFsIHZhcmlhYmxlLiBcclxuICAgICAqIEl0IGNhbiBiZSBhIE9iamVjdDxLZXksIFZhbHVlPiBpZiBpdCdzIGNhdGVnb3JpY2FsLCBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFycmF5IG9mIG51bWJlcnMuIFxyXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz58QXJyYXk8c3RyaW5nfG51bWJlcj59IC0gdGhlIG1hcHBpbmdzIGZvciB0aGlzIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRWaXN1YWxWYXJpYWJsZU1hcHBpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzdWFsVmFyaWFibGVNYXBwaW5nO1xyXG4gICAgICAgIC8vQXJyYXkgbnVtYmVyIChDb250IG5vIHNpemUgZSBvcmllbnRhdGlvbilcclxuICAgICAgICAvL0FycmF5IHN0cmluZyAoQ29udCBwYXJhIGNvbG9yLCBzaXplIGUgb3JpZW50YXRpb24gKyBDYXQgcGFyYSBjb2xvcilcclxuICAgICAgICAvL09iamVjdCBLLT5WIChDYXQgcGFyYSBzaGFwZSwgdGV4dHVyZSBlIG9yaWVudGF0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtYXAgdmFyaWFibGUgcmVxdWlyZXMgaXQncyBjbGFzc2VzIHRvIGJlIGNhbGN1bGF0ZWQgb3Igbm90LiBDYXRlZ29yaWNhbCB2YXJpYWJsZXMgYWx3YXlzIHJldHVybiBmYWxzZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXBwaW5nIGJldHdlZW4gZWFjaCBjbGFzcy9jYXRlZ29yeSBhbmQgaXQncyB2aXN1YWwgdmFyaWFibGUgdXNhYmxlIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge01hcDxudW1iZXIsQXJyYXk8bnVtYmVyPnxudW1iZXI+fSAtIHRoZSBtYXBwaW5nIGJldHdlZW4gZWFjaCBjbGFzcy9jYXRlZ29yeSBhbmQgaXQncyB2aXN1YWwgdmFyaWFibGUgdXNhYmxlIHZhbHVlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4VG9VU2FibGVWYWx1ZU1hcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFRvVXNhYmxlVmFsdWVNYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cclxuICAgICAqIEUuZy4gWzI1NSwwLDBdIGZvciBjb2xvciBvciA1NyBmb3Igc2l6ZS9vcmllbnRhdGlvbiBvciAzIGZvciBzaGFwZS90ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPnxudW1iZXI+fVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGZpbmRVc2FibGVWYWx1ZShpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4VG9Vc2FibGVWYWx1ZU1hcC5nZXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFjY2VzcyBxdWFsaWZpZXIgZm9yIHRoZSBzaGFkZXIgdmFyaWFibGUgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBhY2Nlc3MgcXVhbGlmaWVyIGZvciB0aGUgc2hhZGVyIHZhcmlhYmxlIFxyXG4gICAgICogQG1lbWJlck9mIE1hcFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFNoYWRlclZhcmlhYmxlUXVhbGlmaWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlclF1YWxpZmllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2hhZGVyIHF1YWxpZmllciBpcyBlcXVhbCB0byBhdHRyaWJ1dGUsIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzaGFkZXIgcXVhbGlmaWVyIGlzIGVxdWFsIHRvIGF0dHJpYnV0ZSwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJPZiBNYXBWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBxdWFsaWZpZXJJc0F0dHJpYnV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWFsaWZpZXJJc0F0dHJpYnV0ZUJvb2w7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL01hcFZhcmlhYmxlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOzs7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTs7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBRkE7QUFDQTtBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBbENBO0FBbUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/* no static exports found */
/* all exports used */
/*!***********************************************!*\
  !*** ./src/Gisplay/VVs/ContinuousVariable.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ContinuousVariable = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MapVariable2 = __webpack_require__(/*! ./MapVariable */ 4);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../GisplayDefaults */ 0);\n\nvar _GisplayError = __webpack_require__(/*! ../GisplayError */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Represents a continuous variable.\r\n * Continous data, is data where the values can change continuously, and you cannot count the number of different values (e.g. weight, price, profits, counts, etc). \r\n * @see https://eagereyes.org/basics/data-continuous-vs-categorical\r\n * @export\r\n * @class ContinuousVariable\r\n */\nvar ContinuousVariable = exports.ContinuousVariable = function (_MapVariable) {\n    _inherits(ContinuousVariable, _MapVariable);\n\n    /**\r\n     * Creates an instance of ContinuousVariable.\r\n     * @param {string} externalName - The external name for this variable.\r\n     * @param {string} internalName - The internal name for this variable.\r\n     * @param {string} typeOfVisualVariable - The type of visual variable (e.g. color, shape, size, orientation or texture).\r\n     * @param {string} shaderVariableQualifier - The shader variable qualifier. \r\n     * @param {Array<string|number>} visualVariableMapping - The mapping for the given type of visual variable.\r\n     * @param {Array<number>} classBreaks - The classes for this map variable.\r\n     * @param {string} numberOfClasses - The number of classes for this continuous variable.\r\n     * @param {string} classBreakMethod - The class breaks method to be used.\r\n     * @param {Array<number|string>} classBreakMethodParams - The parameters for the class break method.\r\n     * @memberof ContinuousVariable\r\n     */\n    function ContinuousVariable(externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping, classBreaks, numberOfClasses, classBreakMethod, classBreakMethodParams) {\n        _classCallCheck(this, ContinuousVariable);\n\n        /**\r\n         * The class intervals for the map variable.\r\n         * @type {Array<number>}\r\n         */\n        var _this = _possibleConstructorReturn(this, (ContinuousVariable.__proto__ || Object.getPrototypeOf(ContinuousVariable)).call(this, externalName, internalName, typeOfVisualVariable, shaderVariableQualifier, visualVariableMapping));\n\n        _this.classBreaks = classBreaks;\n        /**\r\n         * The number of classes for the map variable.\r\n         * @type {number}\r\n         */\n        _this.numberOfClasses = visualVariableMapping ? visualVariableMapping.length : numberOfClasses;\n        /**\r\n         * The method to use to calculate classes for the map variable.\r\n         * @type {string}\r\n         */\n        _this.classBreakMethod = classBreakMethod;\n        /**\r\n         * Returns the array of params for the class break method.\r\n         *  @type{Array<number|string>} \r\n         */\n        _this.classBreakMethodParams = classBreakMethodParams;\n\n        /**\r\n         * Number of bins. This value is hardcoded to 100. But it should work even if changed to another integer value.\r\n         * @type {number}\r\n         */\n        _this.numBins = 100;\n        /**\r\n         * The minimum value.\r\n         * @type {number}\r\n         */\n        _this.min = Number.MAX_SAFE_INTEGER - 1;\n        /**\r\n         * The maximum value.\r\n         * @type {number}\r\n         */\n        _this.max = Number.MIN_SAFE_INTEGER + 1;\n\n        _this.newMin = Number.MAX_SAFE_INTEGER;\n        _this.newMax = Number.MIN_SAFE_INTEGER;\n\n        /**\r\n         * Amount between any two bins.\r\n         * @type {number}\r\n         */\n        _this.step = -1;\n        /**\r\n         * The bin limits.\r\n         * @type {Array<number>}\r\n         */\n        _this.bins = new Array(100).fill(-1);\n        /**\r\n         * Histogram with number of values by bin interval. \r\n         * @type {Array<number>}\r\n         */\n        _this.histogram = new Array(100).fill(0); //Array with 100 elements each filled with the value 0\n        /**\r\n         * The class intervals for the map variable.\r\n         * @type {Array<Array<number>>}\r\n         */\n        _this.classIntervals;\n\n        if (_this.classBreaks) {\n            _this.min = _this.classBreaks[0];\n            _this.max = _this.classBreaks[_this.classBreaks.length - 1];\n            _this.step = (_this.getMax() - _this.getMin()) / _this.numBins;\n\n            _this.bins = _this.buildBinIntervals();\n            _this.classIntervals = _this.calculateClassIntervals(_this.classBreaks);\n        }\n        if (_this.getVisualVariableMapping()) _this._setIndexToUsableValueMap();\n\n        /**  \r\n         * Boolean that stores true if class calcutation is required, false, otherwise.\r\n         * @type {boolean}\r\n         */\n        _this.classCalculationRequiredBool = _this.classBreaks === undefined;\n        console.log(_this);\n        return _this;\n    }\n\n    /**\r\n     * Returns the method to be used to calculate the classes for this map variable.\r\n     * @returns {string} - the method to be used to calculate the classes for this variable.\r\n     * @memberof ContinuousVariable\r\n     */\n\n\n    _createClass(ContinuousVariable, [{\n        key: 'getClassBreakMethod',\n        value: function getClassBreakMethod() {\n            return this.classBreakMethod;\n        }\n\n        /**\r\n         * Returns the class intervals for this map variable.\r\n         * @returns {Array<number>} - the class intervals for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getClassBreaks',\n        value: function getClassBreaks() {\n            return this.classBreaks;\n        }\n\n        /**\r\n         * Sets the class breaks to the calculated class breaks.\r\n         * @param {Array<number>} calculatedClassBreaks - The array of class intervals for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'setClassBreaks',\n        value: function setClassBreaks(calculatedClassBreaks) {\n            this.classBreaks = calculatedClassBreaks;\n        }\n\n        /**\r\n         * Returns true, if the class breaks weren't given by the programmer for the map variable, false, otherwise. \r\n         * @returns {boolean} - true, if the class breaks weren't given by the programmer for the visual variable, false, otherwise.  \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return this.classCalculationRequiredBool;\n        }\n\n        /**\r\n         * Calculates class intervals for this variable.\r\n         * @param {Array<number>} classBreaks - The class breaks given by the programmer. \r\n         * @returns {Array<Array<number>>} - the start and end for each class of this variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'calculateClassIntervals',\n        value: function calculateClassIntervals(classBreaks) {\n            console.error(\"classBreaks = \", classBreaks, this);\n            var res = [];\n\n            /*     \r\n                [min, a[, [a, b[, [b,c[, [c,max] -> caso em que o min dos dados é !== do a\r\n                min - todos os valore menores que a\r\n                [a,b,c] ->  [min, a[, [a, b[, [b,c[, [c,max] \r\n                Se min for == a então n cabe \r\n                >= a && < a \r\n                  1º intervalos todos os inferiores a \"a\"\r\n                o ultimo intervalo é todos os >= a c \r\n            */\n            for (var i = 0; i < classBreaks.length - 1; i++) {\n                res.push([classBreaks[i], classBreaks[i + 1]]);\n            } /*   if (this.classBreaks !== undefined) {\r\n                    res.push([this.min, classBreaks[0]]);\r\n                    for (let i = 0; i < classBreaks.length - 1; i++)\r\n                        res.push([classBreaks[i], classBreaks[i + 1]]);\r\n                    res.push([classBreaks[classBreaks.length - 1], this.max]);\r\n                } else {\r\n                    // res.push([this.min, classBreaks[0]]);\r\n                    for (let i = 0; i < classBreaks.length - 1; i++)\r\n                        res.push([classBreaks[i], classBreaks[i + 1]]);\r\n                    // res.push([classBreaks[classBreaks.length - 1], this.max]);\r\n                } */\n            return res;\n            // return null;\n        }\n\n        /**\r\n         * Returns the class intervals for this class.\r\n         * @returns {Array<Array<number>>} - the class intervals for this class. \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getClassIntervals',\n        value: function getClassIntervals() {\n            return this.classIntervals;\n        }\n\n        /**\r\n         * Find the class index of the given value.\r\n         * It's inside a class if it's value is equal or higher than the starting point and less than the end point.\r\n         * @param {number} value - The value of the element.\r\n         * @returns {number} - The  index of the class.\r\n         * @memberof Parser\r\n         */\n\n    }, {\n        key: 'findClassIntervalIndex',\n        value: function findClassIntervalIndex(value) {\n            var classIntervals = this.getClassIntervals();\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = classIntervals.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var _step$value = _slicedToArray(_step.value, 2),\n                        index = _step$value[0],\n                        classInterval = _step$value[1];\n\n                    if (value >= classInterval[0] && value < classInterval[1]) return index;\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            if (value < classIntervals[0][0]) return 0;\n            return classIntervals.length - 1;\n        }\n\n        /**\r\n         * Set the min and max values if the given value changes them.\r\n         * @param {number} value - The given vaue. \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'setMinMax',\n        value: function setMinMax(value) {\n            if (value < this.min) this.min = value;\n            if (value > this.max) this.max = value;\n            /* if (value < this.newMin)\r\n                this.newMin = value;\r\n            if (value > this.newMax)\r\n                this.newMax = value; */\n        }\n\n        /*\r\n        #####################################################################\r\n        ######################     CLASS CALCULATION      ###################\r\n        #####################################################################\r\n        */\n        /**\r\n         * Returns the minimum value for the visual variable.\r\n         * @returns {number} - the minimum value for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getMin',\n        value: function getMin() {\n            return this.min;\n        }\n\n        /**\r\n         * Returns the maximum value for the visual variable.\r\n         * @returns {number} -  the maximum value for the visual variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getMax',\n        value: function getMax() {\n            return this.max;\n        }\n\n        /**\r\n         * Update the step vaue.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'setStep',\n        value: function setStep() {\n            this.step = (this.getMax() - this.getMin()) / this.numBins;\n        }\n\n        /**\r\n         * Returns the step between each bin value.\r\n         * @returns {number} - the step between each bin value.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getStep',\n        value: function getStep() {\n            return this.step;\n        }\n\n        /**\r\n         * Returns the histogram for this continuous variable.\r\n         * @returns {Array<number>} - the histogram for this continuous variable.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getHistogram',\n        value: function getHistogram() {\n            return this.histogram;\n        }\n\n        /**\r\n         * Updates the histogram of this continuous variable with the histogram values\r\n         * @param {Array<number>} histogram - The given histogram\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'updateHistogram',\n        value: function updateHistogram(histogram) {\n            for (var i = 0; i < histogram.length; i++) {\n                this.histogram[i] += histogram[i];\n            }\n        }\n\n        /**\r\n         * Return the number of classes.\r\n         * @returns {numer} - the number of classes.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'getNumberOfClasses',\n        value: function getNumberOfClasses() {\n            return this.numberOfClasses;\n        }\n\n        /**\r\n         * Create 100 bins with equal intervals between the minimum and maximum value.\r\n         * @param {number} min - The minimum for this continuous variable. \r\n         * @param {number} max - The maximum for this continuous variable.\r\n         * @returns {Array<number>} - The bins that will be used to calculate the classes.\r\n         * @memberof LegendClasses\r\n         */\n\n    }, {\n        key: 'buildBinIntervals',\n        value: function buildBinIntervals() {\n            // let step = (max - min) / this.numBins;\n            if (this.step === -1) this.setStep();\n            var resBins = [];\n            var min = this.min;\n            var max = this.max;\n            // resBins.push(min);\n            for (var i = min; i < max; i += this.step) {\n                resBins.push(i);\n            }if (Math.round(resBins[resBins.length - 1]) === max || max - resBins[resBins.length - 1] < 0.0001) //min = 0, max = 199.2 Math.round(199.19999999999976) = 199 <-- ERROR\n                resBins[resBins.length - 1] = max;else resBins.push(max);\n            return resBins;\n        }\n\n        /**\r\n         * Create the bins array with 101? values that represent the intervals.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'createBins',\n        value: function createBins() {\n            this.bins = this.buildBinIntervals();\n        }\n\n        /**\r\n         * Add the value to the respective bin index.\r\n         * This method works at O(1) instead of O(n), since it only needs to calculate the index and add one to it's bin.\r\n         * The alternative was to loop through all the bins and find where this value would fit.\r\n         * @param {number} value - The value to insert into one of the bins. \r\n         * @see http://prntscr.com/gdn1wu - Reason for if statement\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'addValueToBins',\n        value: function addValueToBins(value) {\n            var binIndex = Math.floor((value - this.min) / this.step);\n            if (value >= this.max) //The case it is equal to the max value then change index to the previous.\n                binIndex = this.numBins - 1;else if (value <= this.min) binIndex = 0;\n            this.histogram[binIndex]++;\n            // console.log(\"value\", value, \"binIndex\", binIndex);\n        }\n\n        /**\r\n         * Calculates the classes for the visual variable using the method specified by the programmer.\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'calculateClasses',\n        value: function calculateClasses() {\n            //Usando os bins faz calculo de classes e alterar guardar nos classIntervals\n            switch (this.getClassBreakMethod()) {\n                case 'quantiles':\n                    this.classIntervals = this.calculateClassIntervals(this.quantiles());\n                    break;\n                case 'equalintervals':\n                    // console.log('equalintervals');\n                    this.classIntervals = this.calculateClassIntervals(this.equalIntervals());\n                    break;\n                default:\n                    throw new _GisplayError.GisplayError('Continuous Variable: ' + this.getInternalName() + '. Given method for class calculation does not exist. ');\n            }\n\n            if (this.classIntervals.length !== this.numberOfClasses) throw new _GisplayError.GisplayError(\"The number of calculated class intervals is different from the number of classes\");\n        }\n\n        /**\r\n         * Calculate the intervals for each class using the quantiles method.\r\n         * @param {Array<number>} histogram - Histogram with quantity of values by bin interval. \r\n         * @param {number} binValues - The bin values between the minimum and the maximum.\r\n         * @param {number} numRows - Number of rows read from the file.\r\n         * @param {number} numClasses - Number of classes to calculate.\r\n         * @returns {Array<number>} -  The resulting classes using the quantiles method.\r\n         * @see https://en.wikipedia.org/wiki/Quantile\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'quantiles',\n        value: function quantiles() {\n            var numberOfClasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNumberOfClasses();\n\n            var numRows = 0;\n            for (var i = 0, length = this.histogram.length; i < length; i++) {\n                numRows += this.histogram[i];\n            }var numValsPerClass = numRows / numberOfClasses;\n            // console.log(numRows, this.getNumberOfClasses(), numValsPerClass);\n            var classes = [];\n            classes.push(this.bins[0]);\n            var sum = 0;\n            for (var _i = 0; _i < this.histogram.length - 1; _i++) {\n                sum += this.histogram[_i];\n                if (sum >= numValsPerClass) {\n                    classes.push(this.bins[_i + 1]);\n                    sum = 0;\n                }\n            }\n            classes.push(this.bins[this.bins.length - 1]);\n            // console.log(classes);\n            // console.log(this);\n            if (classes.length < numberOfClasses) console.warn('Quantiles method couldn\\'t create ' + numberOfClasses + ' classes, instead it created ' + (classes.length - 1) + ' classes. [' + classes + ']');else if (classes.length - 1 > numberOfClasses) throw new _GisplayError.GisplayError('Something went wrong with quantiles method. Number of classes calculated is: ' + (classes.length - 1) + ', the intended values was ' + this.getNumberOfClasses());\n            return classes;\n        }\n\n        /**\r\n         * Taking the calculated bins, this method will calculate the intervals for each class using the equal intervals method.\r\n         * @param {number} binValues - The bin values between the minimum and the maximum.\r\n         * @param {number} numClasses - Number of classes to calculate.\r\n         * @returns {Array<number>} - The resulting classes using the equal intervals method.\r\n         * @see http://wiki.gis.com/wiki/index.php/Equal_Interval_classification\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: 'equalIntervals',\n        value: function equalIntervals() {\n            var numberOfClasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNumberOfClasses();\n\n            var interval = Math.round((this.getMax() - this.getMin()) / numberOfClasses); //To give a integer (this.bins.length - 1) / this.numClasses;\n            // console.log(\"EquInt interval=\", interval);\n            // console.log(this.getMin(), this.getMax(), numberOfClasses);\n            var classes = [];\n            classes.push(this.bins[0]);\n            var currentValue = this.getMin(); // Current value\n            for (var i = 0; i < numberOfClasses - 1; i++) {\n                currentValue += interval;\n                classes.push(this._findBin(currentValue));\n            }\n            classes.push(this.bins[this.bins.length - 1]);\n\n            // console.log(\"equalIntervals = \", classes);\n            return classes;\n        }\n\n        /**\r\n         * Find the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first.\r\n         * @param {number} value - The value used to find the correct bin. \r\n         * @returns {number} - the bin that is higher or equal than the value and the distance to next bin value is smaller than to the first. \r\n         * @private \r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: '_findBin',\n        value: function _findBin(value) {\n            for (var i = 0; i < this.bins.length - 1; i++) {\n                var val1 = this.bins[i];\n                var val2 = this.bins[i + 1];\n                if (value >= val1 && value < val2) {\n                    var distToVal1 = value - val1;\n                    var distToVal2 = val2 - value;\n                    if (distToVal1 <= distToVal2) return val1;\n                    return val2;\n                }\n            }\n        }\n\n        /**\r\n         * Set each index (of each class) to it's respective value (color array, size or orientation value).\r\n         * E.g. 0 -> [255, 0, 0], 1 -> [0, 128, 0] etc\r\n         * @private\r\n         * @memberof ContinuousVariable\r\n         */\n\n    }, {\n        key: '_setIndexToUsableValueMap',\n        value: function _setIndexToUsableValueMap() {\n            var typeOfVisualVariable = this.getTypeOfVisualVariable();\n            switch (typeOfVisualVariable) {\n                case _GisplayDefaults.GisplayDefaults.COLOR():\n                case _GisplayDefaults.GisplayDefaults.SIZE():\n                case _GisplayDefaults.GisplayDefaults.ORIENTATION():\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        for (var _iterator2 = this.getVisualVariableMapping().entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var _step2$value = _slicedToArray(_step2.value, 2),\n                                index = _step2$value[0],\n                                vvMapping = _step2$value[1];\n\n                            this.indexToUsableValueMap.set(index, vvMapping);\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n\n                    break;\n                case _GisplayDefaults.GisplayDefaults.SHAPE():\n                case _GisplayDefaults.GisplayDefaults.TEXTURE():\n                    throw new _GisplayError.GisplayError(typeOfVisualVariable + ' shouldn\\'t be used with a continuous variable.');\n            }\n            // console.log(\"CONT VV_TO_INDEX_MAP =========================\", this.indexToUsableValueMap);\n        }\n    }]);\n\n    return ContinuousVariable;\n}(_MapVariable2.MapVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvQ29udGludW91c1ZhcmlhYmxlLmpzP2E0MWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwVmFyaWFibGUgfSBmcm9tICcuL01hcFZhcmlhYmxlJztcclxuaW1wb3J0IHsgR2lzcGxheURlZmF1bHRzIH0gZnJvbSAnLi4vR2lzcGxheURlZmF1bHRzJztcclxuaW1wb3J0IHsgR2lzcGxheUVycm9yIH0gZnJvbSAnLi4vR2lzcGxheUVycm9yJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY29udGludW91cyB2YXJpYWJsZS5cclxuICogQ29udGlub3VzIGRhdGEsIGlzIGRhdGEgd2hlcmUgdGhlIHZhbHVlcyBjYW4gY2hhbmdlIGNvbnRpbnVvdXNseSwgYW5kIHlvdSBjYW5ub3QgY291bnQgdGhlIG51bWJlciBvZiBkaWZmZXJlbnQgdmFsdWVzIChlLmcuIHdlaWdodCwgcHJpY2UsIHByb2ZpdHMsIGNvdW50cywgZXRjKS4gXHJcbiAqIEBzZWUgaHR0cHM6Ly9lYWdlcmV5ZXMub3JnL2Jhc2ljcy9kYXRhLWNvbnRpbnVvdXMtdnMtY2F0ZWdvcmljYWxcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQ29udGludW91c1ZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29udGludW91c1ZhcmlhYmxlIGV4dGVuZHMgTWFwVmFyaWFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbnRpbnVvdXNWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlT2ZWaXN1YWxWYXJpYWJsZSAtIFRoZSB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZSAoZS5nLiBjb2xvciwgc2hhcGUsIHNpemUsIG9yaWVudGF0aW9uIG9yIHRleHR1cmUpLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlclZhcmlhYmxlUXVhbGlmaWVyIC0gVGhlIHNoYWRlciB2YXJpYWJsZSBxdWFsaWZpZXIuIFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gdmlzdWFsVmFyaWFibGVNYXBwaW5nIC0gVGhlIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiB0eXBlIG9mIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xhc3NCcmVha3MgLSBUaGUgY2xhc3NlcyBmb3IgdGhpcyBtYXAgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtYmVyT2ZDbGFzc2VzIC0gVGhlIG51bWJlciBvZiBjbGFzc2VzIGZvciB0aGlzIGNvbnRpbnVvdXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NCcmVha01ldGhvZCAtIFRoZSBjbGFzcyBicmVha3MgbWV0aG9kIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcnxzdHJpbmc+fSBjbGFzc0JyZWFrTWV0aG9kUGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjbGFzcyBicmVhayBtZXRob2QuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZywgY2xhc3NCcmVha3MsIG51bWJlck9mQ2xhc3NlcywgY2xhc3NCcmVha01ldGhvZCwgY2xhc3NCcmVha01ldGhvZFBhcmFtcykge1xyXG4gICAgICAgIHN1cGVyKGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lLCB0eXBlT2ZWaXN1YWxWYXJpYWJsZSwgc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsIHZpc3VhbFZhcmlhYmxlTWFwcGluZyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhlIG1hcCB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtzID0gY2xhc3NCcmVha3M7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBjbGFzc2VzIGZvciB0aGUgbWFwIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5udW1iZXJPZkNsYXNzZXMgPSB2aXN1YWxWYXJpYWJsZU1hcHBpbmcgPyB2aXN1YWxWYXJpYWJsZU1hcHBpbmcubGVuZ3RoIDogbnVtYmVyT2ZDbGFzc2VzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtZXRob2QgdG8gdXNlIHRvIGNhbGN1bGF0ZSBjbGFzc2VzIGZvciB0aGUgbWFwIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGFzc0JyZWFrTWV0aG9kID0gY2xhc3NCcmVha01ldGhvZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJhbXMgZm9yIHRoZSBjbGFzcyBicmVhayBtZXRob2QuXHJcbiAgICAgICAgICogIEB0eXBle0FycmF5PG51bWJlcnxzdHJpbmc+fSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtNZXRob2RQYXJhbXMgPSBjbGFzc0JyZWFrTWV0aG9kUGFyYW1zO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgYmlucy4gVGhpcyB2YWx1ZSBpcyBoYXJkY29kZWQgdG8gMTAwLiBCdXQgaXQgc2hvdWxkIHdvcmsgZXZlbiBpZiBjaGFuZ2VkIHRvIGFub3RoZXIgaW50ZWdlciB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubnVtQmlucyA9IDEwMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWluaW11bSB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiArIDE7XHJcblxyXG4gICAgICAgIHRoaXMubmV3TWluID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgdGhpcy5uZXdNYXggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW1vdW50IGJldHdlZW4gYW55IHR3byBiaW5zLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGVwID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJpbiBsaW1pdHMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iaW5zID0gbmV3IEFycmF5KDEwMCkuZmlsbCgtMSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGlzdG9ncmFtIHdpdGggbnVtYmVyIG9mIHZhbHVlcyBieSBiaW4gaW50ZXJ2YWwuIFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGlzdG9ncmFtID0gbmV3IEFycmF5KDEwMCkuZmlsbCgwKTsgLy9BcnJheSB3aXRoIDEwMCBlbGVtZW50cyBlYWNoIGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSAwXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhlIG1hcCB2YXJpYWJsZS5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGFzc0ludGVydmFscztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NCcmVha3MpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4gPSB0aGlzLmNsYXNzQnJlYWtzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXMuY2xhc3NCcmVha3NbdGhpcy5jbGFzc0JyZWFrcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdGhpcy5zdGVwID0gKHRoaXMuZ2V0TWF4KCkgLSB0aGlzLmdldE1pbigpKSAvICh0aGlzLm51bUJpbnMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5iaW5zID0gdGhpcy5idWlsZEJpbkludGVydmFscygpO1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzSW50ZXJ2YWxzID0gdGhpcy5jYWxjdWxhdGVDbGFzc0ludGVydmFscyh0aGlzLmNsYXNzQnJlYWtzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0VmlzdWFsVmFyaWFibGVNYXBwaW5nKCkpXHJcbiAgICAgICAgICAgIHRoaXMuX3NldEluZGV4VG9Vc2FibGVWYWx1ZU1hcCgpO1xyXG5cclxuICAgICAgICAvKiogIFxyXG4gICAgICAgICAqIEJvb2xlYW4gdGhhdCBzdG9yZXMgdHJ1ZSBpZiBjbGFzcyBjYWxjdXRhdGlvbiBpcyByZXF1aXJlZCwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZEJvb2wgPSB0aGlzLmNsYXNzQnJlYWtzID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXRob2QgdG8gYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGNsYXNzZXMgZm9yIHRoaXMgbWFwIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgbWV0aG9kIHRvIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzIGZvciB0aGlzIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRDbGFzc0JyZWFrTWV0aG9kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzQnJlYWtNZXRob2Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBpbnRlcnZhbHMgZm9yIHRoaXMgbWFwIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IC0gdGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2xhc3NCcmVha3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NCcmVha3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjbGFzcyBicmVha3MgdG8gdGhlIGNhbGN1bGF0ZWQgY2xhc3MgYnJlYWtzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjYWxjdWxhdGVkQ2xhc3NCcmVha3MgLSBUaGUgYXJyYXkgb2YgY2xhc3MgaW50ZXJ2YWxzIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBzZXRDbGFzc0JyZWFrcyhjYWxjdWxhdGVkQ2xhc3NCcmVha3MpIHtcclxuICAgICAgICB0aGlzLmNsYXNzQnJlYWtzID0gY2FsY3VsYXRlZENsYXNzQnJlYWtzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlLCBpZiB0aGUgY2xhc3MgYnJlYWtzIHdlcmVuJ3QgZ2l2ZW4gYnkgdGhlIHByb2dyYW1tZXIgZm9yIHRoZSBtYXAgdmFyaWFibGUsIGZhbHNlLCBvdGhlcndpc2UuIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSwgaWYgdGhlIGNsYXNzIGJyZWFrcyB3ZXJlbid0IGdpdmVuIGJ5IHRoZSBwcm9ncmFtbWVyIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLCBmYWxzZSwgb3RoZXJ3aXNlLiAgXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0NhbGN1bGF0aW9uUmVxdWlyZWRCb29sO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBjbGFzcyBpbnRlcnZhbHMgZm9yIHRoaXMgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsYXNzQnJlYWtzIC0gVGhlIGNsYXNzIGJyZWFrcyBnaXZlbiBieSB0aGUgcHJvZ3JhbW1lci4gXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IC0gdGhlIHN0YXJ0IGFuZCBlbmQgZm9yIGVhY2ggY2xhc3Mgb2YgdGhpcyB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlQ2xhc3NJbnRlcnZhbHMoY2xhc3NCcmVha3MpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiY2xhc3NCcmVha3MgPSBcIiwgY2xhc3NCcmVha3MsIHRoaXMpXHJcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xyXG5cclxuICAgICAgICAvKiAgICAgXHJcbiAgICAgICAgICAgIFttaW4sIGFbLCBbYSwgYlssIFtiLGNbLCBbYyxtYXhdIC0+IGNhc28gZW0gcXVlIG8gbWluIGRvcyBkYWRvcyDDqSAhPT0gZG8gYVxyXG4gICAgICAgICAgICBtaW4gLSB0b2RvcyBvcyB2YWxvcmUgbWVub3JlcyBxdWUgYVxyXG4gICAgICAgICAgICBbYSxiLGNdIC0+ICBbbWluLCBhWywgW2EsIGJbLCBbYixjWywgW2MsbWF4XSBcclxuICAgICAgICAgICAgU2UgbWluIGZvciA9PSBhIGVudMOjbyBuIGNhYmUgXHJcbiAgICAgICAgICAgID49IGEgJiYgPCBhIFxyXG5cclxuICAgICAgICAgICAgMcK6IGludGVydmFsb3MgdG9kb3Mgb3MgaW5mZXJpb3JlcyBhIFwiYVwiXHJcbiAgICAgICAgICAgIG8gdWx0aW1vIGludGVydmFsbyDDqSB0b2RvcyBvcyA+PSBhIGMgXHJcbiAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzQnJlYWtzLmxlbmd0aCAtIDE7IGkrKylcclxuICAgICAgICAgICAgcmVzLnB1c2goW2NsYXNzQnJlYWtzW2ldLCBjbGFzc0JyZWFrc1tpICsgMV1dKTtcclxuICAgICAgICAvKiAgIGlmICh0aGlzLmNsYXNzQnJlYWtzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICByZXMucHVzaChbdGhpcy5taW4sIGNsYXNzQnJlYWtzWzBdXSk7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0JyZWFrcy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtjbGFzc0JyZWFrc1tpXSwgY2xhc3NCcmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgcmVzLnB1c2goW2NsYXNzQnJlYWtzW2NsYXNzQnJlYWtzLmxlbmd0aCAtIDFdLCB0aGlzLm1heF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyByZXMucHVzaChbdGhpcy5taW4sIGNsYXNzQnJlYWtzWzBdXSk7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0JyZWFrcy5sZW5ndGggLSAxOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtjbGFzc0JyZWFrc1tpXSwgY2xhc3NCcmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgLy8gcmVzLnB1c2goW2NsYXNzQnJlYWtzW2NsYXNzQnJlYWtzLmxlbmd0aCAtIDFdLCB0aGlzLm1heF0pO1xyXG4gICAgICAgICAgfSAqL1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgLy8gcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjbGFzcyBpbnRlcnZhbHMgZm9yIHRoaXMgY2xhc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IC0gdGhlIGNsYXNzIGludGVydmFscyBmb3IgdGhpcyBjbGFzcy4gXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldENsYXNzSW50ZXJ2YWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzSW50ZXJ2YWxzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgY2xhc3MgaW5kZXggb2YgdGhlIGdpdmVuIHZhbHVlLlxyXG4gICAgICogSXQncyBpbnNpZGUgYSBjbGFzcyBpZiBpdCdzIHZhbHVlIGlzIGVxdWFsIG9yIGhpZ2hlciB0aGFuIHRoZSBzdGFydGluZyBwb2ludCBhbmQgbGVzcyB0aGFuIHRoZSBlbmQgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSAgaW5kZXggb2YgdGhlIGNsYXNzLlxyXG4gICAgICogQG1lbWJlcm9mIFBhcnNlclxyXG4gICAgICovXHJcbiAgICBmaW5kQ2xhc3NJbnRlcnZhbEluZGV4KHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGNsYXNzSW50ZXJ2YWxzID0gdGhpcy5nZXRDbGFzc0ludGVydmFscygpO1xyXG4gICAgICAgIGZvciAobGV0IFtpbmRleCwgY2xhc3NJbnRlcnZhbF0gb2YgY2xhc3NJbnRlcnZhbHMuZW50cmllcygpKVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gY2xhc3NJbnRlcnZhbFswXSAmJiB2YWx1ZSA8IGNsYXNzSW50ZXJ2YWxbMV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgY2xhc3NJbnRlcnZhbHNbMF1bMF0pXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHJldHVybiBjbGFzc0ludGVydmFscy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgaWYgdGhlIGdpdmVuIHZhbHVlIGNoYW5nZXMgdGhlbS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBnaXZlbiB2YXVlLiBcclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgc2V0TWluTWF4KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5taW4pXHJcbiAgICAgICAgICAgIHRoaXMubWluID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5tYXgpXHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdmFsdWU7XHJcbiAgICAgICAgLyogaWYgKHZhbHVlIDwgdGhpcy5uZXdNaW4pXHJcbiAgICAgICAgICAgIHRoaXMubmV3TWluID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5uZXdNYXgpXHJcbiAgICAgICAgICAgIHRoaXMubmV3TWF4ID0gdmFsdWU7ICovXHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAgICAgQ0xBU1MgQ0FMQ1VMQVRJT04gICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjXHJcbiAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgZm9yIHRoZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBtaW5pbXVtIHZhbHVlIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRNaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gIHRoZSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgdmlzdWFsIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRNYXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBzdGVwIHZhdWUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIHNldFN0ZXAoKSB7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gKHRoaXMuZ2V0TWF4KCkgLSB0aGlzLmdldE1pbigpKSAvICh0aGlzLm51bUJpbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RlcCBiZXR3ZWVuIGVhY2ggYmluIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgc3RlcCBiZXR3ZWVuIGVhY2ggYmluIHZhbHVlLlxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRTdGVwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoaXN0b2dyYW0gZm9yIHRoaXMgY29udGludW91cyB2YXJpYWJsZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIHRoZSBoaXN0b2dyYW0gZm9yIHRoaXMgY29udGludW91cyB2YXJpYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0SGlzdG9ncmFtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpc3RvZ3JhbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGhpc3RvZ3JhbSBvZiB0aGlzIGNvbnRpbnVvdXMgdmFyaWFibGUgd2l0aCB0aGUgaGlzdG9ncmFtIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBoaXN0b2dyYW0gLSBUaGUgZ2l2ZW4gaGlzdG9ncmFtXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUhpc3RvZ3JhbShoaXN0b2dyYW0pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvZ3JhbS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1baV0gKz0gaGlzdG9ncmFtW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgY2xhc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIHtudW1lcn0gLSB0aGUgbnVtYmVyIG9mIGNsYXNzZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldE51bWJlck9mQ2xhc3NlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgMTAwIGJpbnMgd2l0aCBlcXVhbCBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBUaGUgbWluaW11bSBmb3IgdGhpcyBjb250aW51b3VzIHZhcmlhYmxlLiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSBmb3IgdGhpcyBjb250aW51b3VzIHZhcmlhYmxlLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IC0gVGhlIGJpbnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzLlxyXG4gICAgICogQG1lbWJlcm9mIExlZ2VuZENsYXNzZXNcclxuICAgICAqL1xyXG4gICAgYnVpbGRCaW5JbnRlcnZhbHMoKSB7XHJcbiAgICAgICAgLy8gbGV0IHN0ZXAgPSAobWF4IC0gbWluKSAvIHRoaXMubnVtQmlucztcclxuICAgICAgICBpZiAodGhpcy5zdGVwID09PSAtMSlcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGVwKCk7XHJcbiAgICAgICAgbGV0IHJlc0JpbnMgPSBbXTtcclxuICAgICAgICBsZXQgbWluID0gdGhpcy5taW47XHJcbiAgICAgICAgbGV0IG1heCA9IHRoaXMubWF4O1xyXG4gICAgICAgIC8vIHJlc0JpbnMucHVzaChtaW4pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBtYXg7IGkgKz0gdGhpcy5zdGVwKVxyXG4gICAgICAgICAgICByZXNCaW5zLnB1c2goaSk7XHJcblxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHJlc0JpbnNbcmVzQmlucy5sZW5ndGggLSAxXSkgPT09IG1heCB8fCBtYXggLSByZXNCaW5zW3Jlc0JpbnMubGVuZ3RoIC0gMV0gPCAwLjAwMDEpIC8vbWluID0gMCwgbWF4ID0gMTk5LjIgTWF0aC5yb3VuZCgxOTkuMTk5OTk5OTk5OTk5NzYpID0gMTk5IDwtLSBFUlJPUlxyXG4gICAgICAgICAgICByZXNCaW5zW3Jlc0JpbnMubGVuZ3RoIC0gMV0gPSBtYXg7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXNCaW5zLnB1c2gobWF4KTtcclxuICAgICAgICByZXR1cm4gcmVzQmlucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgYmlucyBhcnJheSB3aXRoIDEwMT8gdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBpbnRlcnZhbHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUJpbnMoKSB7XHJcbiAgICAgICAgdGhpcy5iaW5zID0gdGhpcy5idWlsZEJpbkludGVydmFscygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSB2YWx1ZSB0byB0aGUgcmVzcGVjdGl2ZSBiaW4gaW5kZXguXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3b3JrcyBhdCBPKDEpIGluc3RlYWQgb2YgTyhuKSwgc2luY2UgaXQgb25seSBuZWVkcyB0byBjYWxjdWxhdGUgdGhlIGluZGV4IGFuZCBhZGQgb25lIHRvIGl0J3MgYmluLlxyXG4gICAgICogVGhlIGFsdGVybmF0aXZlIHdhcyB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBiaW5zIGFuZCBmaW5kIHdoZXJlIHRoaXMgdmFsdWUgd291bGQgZml0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc2VydCBpbnRvIG9uZSBvZiB0aGUgYmlucy4gXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9wcm50c2NyLmNvbS9nZG4xd3UgLSBSZWFzb24gZm9yIGlmIHN0YXRlbWVudFxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBhZGRWYWx1ZVRvQmlucyh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBiaW5JbmRleCA9IE1hdGguZmxvb3IoKHZhbHVlIC0gdGhpcy5taW4pIC8gdGhpcy5zdGVwKTtcclxuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5tYXgpIC8vVGhlIGNhc2UgaXQgaXMgZXF1YWwgdG8gdGhlIG1heCB2YWx1ZSB0aGVuIGNoYW5nZSBpbmRleCB0byB0aGUgcHJldmlvdXMuXHJcbiAgICAgICAgICAgIGJpbkluZGV4ID0gdGhpcy5udW1CaW5zIC0gMTtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8PSB0aGlzLm1pbilcclxuICAgICAgICAgICAgYmluSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuaGlzdG9ncmFtW2JpbkluZGV4XSsrO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidmFsdWVcIiwgdmFsdWUsIFwiYmluSW5kZXhcIiwgYmluSW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY2xhc3NlcyBmb3IgdGhlIHZpc3VhbCB2YXJpYWJsZSB1c2luZyB0aGUgbWV0aG9kIHNwZWNpZmllZCBieSB0aGUgcHJvZ3JhbW1lci5cclxuICAgICAqIEBtZW1iZXJvZiBDb250aW51b3VzVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlQ2xhc3NlcygpIHtcclxuICAgICAgICAvL1VzYW5kbyBvcyBiaW5zIGZheiBjYWxjdWxvIGRlIGNsYXNzZXMgZSBhbHRlcmFyIGd1YXJkYXIgbm9zIGNsYXNzSW50ZXJ2YWxzXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldENsYXNzQnJlYWtNZXRob2QoKSkge1xyXG4gICAgICAgICAgICBjYXNlICdxdWFudGlsZXMnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0ludGVydmFscyA9IHRoaXMuY2FsY3VsYXRlQ2xhc3NJbnRlcnZhbHModGhpcy5xdWFudGlsZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZXF1YWxpbnRlcnZhbHMnOlxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VxdWFsaW50ZXJ2YWxzJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzSW50ZXJ2YWxzID0gdGhpcy5jYWxjdWxhdGVDbGFzc0ludGVydmFscyh0aGlzLmVxdWFsSW50ZXJ2YWxzKCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKGBDb250aW51b3VzIFZhcmlhYmxlOiAke3RoaXMuZ2V0SW50ZXJuYWxOYW1lKCl9LiBHaXZlbiBtZXRob2QgZm9yIGNsYXNzIGNhbGN1bGF0aW9uIGRvZXMgbm90IGV4aXN0LiBgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNsYXNzSW50ZXJ2YWxzLmxlbmd0aCAhPT0gdGhpcy5udW1iZXJPZkNsYXNzZXMpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBHaXNwbGF5RXJyb3IoXCJUaGUgbnVtYmVyIG9mIGNhbGN1bGF0ZWQgY2xhc3MgaW50ZXJ2YWxzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBudW1iZXIgb2YgY2xhc3Nlc1wiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgaW50ZXJ2YWxzIGZvciBlYWNoIGNsYXNzIHVzaW5nIHRoZSBxdWFudGlsZXMgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBoaXN0b2dyYW0gLSBIaXN0b2dyYW0gd2l0aCBxdWFudGl0eSBvZiB2YWx1ZXMgYnkgYmluIGludGVydmFsLiBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaW5WYWx1ZXMgLSBUaGUgYmluIHZhbHVlcyBiZXR3ZWVuIHRoZSBtaW5pbXVtIGFuZCB0aGUgbWF4aW11bS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1Sb3dzIC0gTnVtYmVyIG9mIHJvd3MgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bUNsYXNzZXMgLSBOdW1iZXIgb2YgY2xhc3NlcyB0byBjYWxjdWxhdGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gLSAgVGhlIHJlc3VsdGluZyBjbGFzc2VzIHVzaW5nIHRoZSBxdWFudGlsZXMgbWV0aG9kLlxyXG4gICAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWFudGlsZVxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBxdWFudGlsZXMobnVtYmVyT2ZDbGFzc2VzID0gdGhpcy5nZXROdW1iZXJPZkNsYXNzZXMoKSkge1xyXG4gICAgICAgIGxldCBudW1Sb3dzID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gdGhpcy5oaXN0b2dyYW0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIG51bVJvd3MgKz0gdGhpcy5oaXN0b2dyYW1baV07XHJcblxyXG4gICAgICAgIGxldCBudW1WYWxzUGVyQ2xhc3MgPSBudW1Sb3dzIC8gbnVtYmVyT2ZDbGFzc2VzO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG51bVJvd3MsIHRoaXMuZ2V0TnVtYmVyT2ZDbGFzc2VzKCksIG51bVZhbHNQZXJDbGFzcyk7XHJcbiAgICAgICAgbGV0IGNsYXNzZXMgPSBbXTtcclxuICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5iaW5zWzBdKTtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGlzdG9ncmFtLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5oaXN0b2dyYW1baV07XHJcbiAgICAgICAgICAgIGlmIChzdW0gPj0gbnVtVmFsc1BlckNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5iaW5zW2kgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLmJpbnNbdGhpcy5iaW5zLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhjbGFzc2VzKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuICAgICAgICBpZiAoY2xhc3Nlcy5sZW5ndGggPCBudW1iZXJPZkNsYXNzZXMpXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUXVhbnRpbGVzIG1ldGhvZCBjb3VsZG4ndCBjcmVhdGUgJHtudW1iZXJPZkNsYXNzZXN9IGNsYXNzZXMsIGluc3RlYWQgaXQgY3JlYXRlZCAke2NsYXNzZXMubGVuZ3RoIC0gMX0gY2xhc3Nlcy4gWyR7Y2xhc3Nlc31dYCk7XHJcbiAgICAgICAgZWxzZSBpZiAoY2xhc3Nlcy5sZW5ndGggLSAxID4gbnVtYmVyT2ZDbGFzc2VzKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKGBTb21ldGhpbmcgd2VudCB3cm9uZyB3aXRoIHF1YW50aWxlcyBtZXRob2QuIE51bWJlciBvZiBjbGFzc2VzIGNhbGN1bGF0ZWQgaXM6ICR7Y2xhc3Nlcy5sZW5ndGggLSAxfSwgdGhlIGludGVuZGVkIHZhbHVlcyB3YXMgJHt0aGlzLmdldE51bWJlck9mQ2xhc3NlcygpfWApO1xyXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFraW5nIHRoZSBjYWxjdWxhdGVkIGJpbnMsIHRoaXMgbWV0aG9kIHdpbGwgY2FsY3VsYXRlIHRoZSBpbnRlcnZhbHMgZm9yIGVhY2ggY2xhc3MgdXNpbmcgdGhlIGVxdWFsIGludGVydmFscyBtZXRob2QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmluVmFsdWVzIC0gVGhlIGJpbiB2YWx1ZXMgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgdGhlIG1heGltdW0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQ2xhc3NlcyAtIE51bWJlciBvZiBjbGFzc2VzIHRvIGNhbGN1bGF0ZS5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIFRoZSByZXN1bHRpbmcgY2xhc3NlcyB1c2luZyB0aGUgZXF1YWwgaW50ZXJ2YWxzIG1ldGhvZC5cclxuICAgICAqIEBzZWUgaHR0cDovL3dpa2kuZ2lzLmNvbS93aWtpL2luZGV4LnBocC9FcXVhbF9JbnRlcnZhbF9jbGFzc2lmaWNhdGlvblxyXG4gICAgICogQG1lbWJlcm9mIENvbnRpbnVvdXNWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBlcXVhbEludGVydmFscyhudW1iZXJPZkNsYXNzZXMgPSB0aGlzLmdldE51bWJlck9mQ2xhc3NlcygpKSB7XHJcbiAgICAgICAgbGV0IGludGVydmFsID0gTWF0aC5yb3VuZCgodGhpcy5nZXRNYXgoKSAtIHRoaXMuZ2V0TWluKCkpIC8gbnVtYmVyT2ZDbGFzc2VzKTsgLy9UbyBnaXZlIGEgaW50ZWdlciAodGhpcy5iaW5zLmxlbmd0aCAtIDEpIC8gdGhpcy5udW1DbGFzc2VzO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRXF1SW50IGludGVydmFsPVwiLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5nZXRNaW4oKSwgdGhpcy5nZXRNYXgoKSwgbnVtYmVyT2ZDbGFzc2VzKTtcclxuICAgICAgICBsZXQgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLmJpbnNbMF0pO1xyXG4gICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0aGlzLmdldE1pbigpOyAvLyBDdXJyZW50IHZhbHVlXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNsYXNzZXMgLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudFZhbHVlICs9IGludGVydmFsO1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5fZmluZEJpbihjdXJyZW50VmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMuYmluc1t0aGlzLmJpbnMubGVuZ3RoIC0gMV0pO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVxdWFsSW50ZXJ2YWxzID0gXCIsIGNsYXNzZXMpO1xyXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgYmluIHRoYXQgaXMgaGlnaGVyIG9yIGVxdWFsIHRoYW4gdGhlIHZhbHVlIGFuZCB0aGUgZGlzdGFuY2UgdG8gbmV4dCBiaW4gdmFsdWUgaXMgc21hbGxlciB0aGFuIHRvIHRoZSBmaXJzdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlY3QgYmluLiBcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGJpbiB0aGF0IGlzIGhpZ2hlciBvciBlcXVhbCB0aGFuIHRoZSB2YWx1ZSBhbmQgdGhlIGRpc3RhbmNlIHRvIG5leHQgYmluIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiB0byB0aGUgZmlyc3QuIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9maW5kQmluKHZhbHVlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJpbnMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWwxID0gdGhpcy5iaW5zW2ldO1xyXG4gICAgICAgICAgICBsZXQgdmFsMiA9IHRoaXMuYmluc1tpICsgMV07XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWwxICYmIHZhbHVlIDwgdmFsMikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RUb1ZhbDEgPSB2YWx1ZSAtIHZhbDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlzdFRvVmFsMiA9IHZhbDIgLSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0VG9WYWwxIDw9IGRpc3RUb1ZhbDIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBlYWNoIGluZGV4IChvZiBlYWNoIGNsYXNzKSB0byBpdCdzIHJlc3BlY3RpdmUgdmFsdWUgKGNvbG9yIGFycmF5LCBzaXplIG9yIG9yaWVudGF0aW9uIHZhbHVlKS5cclxuICAgICAqIEUuZy4gMCAtPiBbMjU1LCAwLCAwXSwgMSAtPiBbMCwgMTI4LCAwXSBldGNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGludW91c1ZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9zZXRJbmRleFRvVXNhYmxlVmFsdWVNYXAoKSB7XHJcbiAgICAgICAgbGV0IHR5cGVPZlZpc3VhbFZhcmlhYmxlID0gdGhpcy5nZXRUeXBlT2ZWaXN1YWxWYXJpYWJsZSgpO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZU9mVmlzdWFsVmFyaWFibGUpIHtcclxuICAgICAgICAgICAgY2FzZSBHaXNwbGF5RGVmYXVsdHMuQ09MT1IoKTpcclxuICAgICAgICAgICAgY2FzZSBHaXNwbGF5RGVmYXVsdHMuU0laRSgpOlxyXG4gICAgICAgICAgICBjYXNlIEdpc3BsYXlEZWZhdWx0cy5PUklFTlRBVElPTigpOlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2luZGV4LCB2dk1hcHBpbmddIG9mIHRoaXMuZ2V0VmlzdWFsVmFyaWFibGVNYXBwaW5nKCkuZW50cmllcygpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwLnNldChpbmRleCwgdnZNYXBwaW5nKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEdpc3BsYXlEZWZhdWx0cy5TSEFQRSgpOlxyXG4gICAgICAgICAgICBjYXNlIEdpc3BsYXlEZWZhdWx0cy5URVhUVVJFKCk6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2lzcGxheUVycm9yKGAke3R5cGVPZlZpc3VhbFZhcmlhYmxlfSBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIGEgY29udGludW91cyB2YXJpYWJsZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJDT05UIFZWX1RPX0lOREVYX01BUCA9PT09PT09PT09PT09PT09PT09PT09PT09XCIsIHRoaXMuaW5kZXhUb1VzYWJsZVZhbHVlTWFwKTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9WVnMvQ29udGludW91c1ZhcmlhYmxlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7Ozs7O0FBT0E7OztBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFGQTtBQUNBO0FBS0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUEvRUE7QUFnRkE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7Ozs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/* no static exports found */
/* all exports used */
/*!*****************************************!*\
  !*** ./src/Gisplay/VVs/TimeVariable.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TimeVariable = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable2 = __webpack_require__(/*! ./DataVariable */ 1);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../GisplayDefaults */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Represents the time information.\r\n * @export\r\n * @class TimeVariable\r\n */\nvar TimeVariable = exports.TimeVariable = function (_DataVariable) {\n    _inherits(TimeVariable, _DataVariable);\n\n    /**\r\n     * Creates an instance of TimeVariable.\r\n     * @param {string} externalName - The external name of the time variable.\r\n     * @param {string} internalName - The internal name of the time variable.\r\n     * @param {string} granularity - The granularity of the time variable.\r\n     * @param {string} timeControl - The time control for the time variable.\r\n     * @memberof TimeVariable\r\n     */\n    function TimeVariable(externalName, internalName, granularity, timeControl) {\n        _classCallCheck(this, TimeVariable);\n\n        /**\r\n         * The time granularity.\r\n         * @type {string}\r\n         */\n        var _this = _possibleConstructorReturn(this, (TimeVariable.__proto__ || Object.getPrototypeOf(TimeVariable)).call(this, externalName, internalName));\n\n        _this.granularity = granularity;\n        /**\r\n         * The granules for this time variable that were processed from the file.\r\n         * @type {Set<string|number>}\r\n         */\n        _this.granules = new Set();\n        /**\r\n         * A map with each temporal granule and it's index.\r\n         * @type {Map<number|string, number>}\r\n         */\n        _this.temporalGranulesMap = new Map();\n        /**\r\n         * The current granule index. This is used to give each granule it's specific index.\r\n         * @type {number}\r\n         */\n        _this.granuleIndex = 0;\n        /**\r\n         * The temporal granules sorted by Date. If its a number (year or day or value etc) then sorted by number.\r\n         * @type {Array<number|string>}\r\n         */\n        _this.sortedTemporalGranulesArr = [];\n        /** \r\n         * The map that contains the string that represents the date and the respective date (e.g. 2016_1_1 => 1 January 2016 OR 2016 => 2016)\r\n         * If the date is a number (e.g. year, monthOfYear, value etc) then the key and the value are equal (2016 => 2016).\r\n         * A value here will be a key in the temporalGranulesMap.\r\n         * @type {Map<string|number, string|number>}\r\n         */\n        _this.strToTemporalGranuleMap = new Map();\n        /** \r\n         * The map with the string temporal granules and their respective index inm the sorted temporal granules array.\r\n         * E.g. Map (3)  {\"1 January 2016\" => 0, \"2 January 2016\" => 1, \"3 January 2016\" => 2, \"4 January 2016\" => 3 }.\r\n         * Used to quickly search for the index of the start and end point of the time control.\r\n         * A value here is an index in the sortedTemporalGranulesArr.\r\n         * @type {Map<string|number, number>}\r\n         */\n        _this.sortedTGsToIndexMap = new Map();\n        /**\r\n         * The time control to use.\r\n         * @type {string}\r\n         */\n        _this.timeControl = timeControl;\n        return _this;\n    }\n\n    /**\r\n     * The granularity\r\n     * @returns {string} - The granularity. \r\n     * @memberof TimeVariable\r\n     */\n\n\n    _createClass(TimeVariable, [{\n        key: 'getGranularity',\n        value: function getGranularity() {\n            return this.granularity;\n        }\n\n        /**\r\n         * Returns the type of time control that should be used.\r\n         * @returns \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTypeOfTimeControl',\n        value: function getTypeOfTimeControl() {\n            return this.timeControl ? this.timeControl : _GisplayDefaults.GisplayDefaults.INSTANT();\n        }\n\n        /**\r\n         * Available granularities for the time value.\r\n         * @returns {Array<string>} - the set of available granularities.  \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getAvailableGranularities',\n        value: function _getAvailableGranularities() {\n            return ['year', 'month', 'day', 'value', //Continuous\n            'monthOfYear', 'dayOfYear', 'dayOfMonth', 'hourOfDay', 'minuteOfHour' // Cyclic\n            ];\n        }\n\n        //GRANULES ETC\n        /**\r\n         * Add all values to the temporal granules map.\r\n         * @param {Array<number>} values - The array of values to add to the granules map.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'createTemporalGranulesMap',\n        value: function createTemporalGranulesMap(values) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var val = _step.value;\n\n                    this.temporalGranulesMap.set(val, this.granuleIndex++);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Add temporal granule to the temporal granules set and return it's index if it does not exist.\r\n         * @param {number} temporalGranule - The temporal granule to be added. \r\n         * @returns {number} - the index of the given temporal granule.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'addTemporalGranule',\n        value: function addTemporalGranule(temporalGranule) {\n            if (this.temporalGranulesMap.has(temporalGranule)) return this.temporalGranulesMap.get(temporalGranule);else {\n                this.temporalGranulesMap.set(temporalGranule, this.granuleIndex);\n                return this.granuleIndex++;\n            }\n        }\n\n        /**\r\n         * Add the given temporal granule to the set of existing temporal granules.\r\n         * @param {string|number} temporalGranule - The temporal granule to add to the set of temporal granules.\r\n         */\n\n    }, {\n        key: 'addTemporalGranuleToSet',\n        value: function addTemporalGranuleToSet(temporalGranule) {\n            this.granules.add(temporalGranule);\n        }\n\n        /**\r\n         * Add temporal granules to the set of temporal granules.\r\n         * @param {Set<string>} temporalGranules - The temporal granules. \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'addTemporalGranulesToSet',\n        value: function addTemporalGranulesToSet(temporalGranules) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = temporalGranules.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var temporalGranule = _step2.value;\n\n                    this.addTemporalGranuleToSet(temporalGranule);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Returns the Set of temporal granules.\r\n         * @returns {Set<string>} - the Set of temporal granules. \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTemporalGranulesSet',\n        value: function getTemporalGranulesSet() {\n            return this.granules;\n        }\n\n        /**\r\n         * Returns the temporal granules that exist on the dataset. E.g. 2016, 2017 etc\r\n         * @returns {Map<number, number>} - the temporal granules that exist on the dataset.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTemporalGranules',\n        value: function getTemporalGranules() {\n            return this.temporalGranulesMap; //Array.from(this.temporalGranulesMap.keys());\n        }\n\n        /**\r\n         * Returns true if the temporal granule values were given, false, otherwise.\r\n         * @returns {booelan} - true if the temporal granule values were given, false, otherwise.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'classCalculationRequired',\n        value: function classCalculationRequired() {\n            return true;\n        }\n\n        /**\r\n         * Sort the temporal granules creating an array with those sorted elements.\r\n         * If the elements are dates then order by date, if they are numbers order by number.\r\n         * @returns {Array<string|number>} - the sorted temporal granules, sorted by date/number.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'sortTemporalGranules',\n        value: function sortTemporalGranules() {\n            var availableGranularites = this._getAvailableGranularities();\n            var tgs = this.getTemporalGranules().keys();\n            var granularitiesArray = []; // \n            var strToTGMap = new Map(); // 26_1_0 => 1 January 2016\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = tgs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var tg = _step3.value;\n\n                    var strGranularity = void 0;\n                    switch (this.granularity) {\n                        case availableGranularites[1]:\n                            //Month\n                            strGranularity = this._getMonth(tg);\n                            break;\n                        case availableGranularites[2]:\n                            //Day\n                            strGranularity = this._getDay(tg);\n                            break;\n                        default:\n                            strGranularity = tg;\n                            break;\n                    }\n                    granularitiesArray.push(strGranularity);\n                    strToTGMap.set(strGranularity, tg);\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            this.strToTemporalGranuleMap = strToTGMap;\n            this.sortedTemporalGranulesArr = granularitiesArray.sort(function (a, b) {\n                return new Date(a) - new Date(b);\n            });\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = this.sortedTemporalGranulesArr.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var _step4$value = _slicedToArray(_step4.value, 2),\n                        i = _step4$value[0],\n                        sortedTG = _step4$value[1];\n\n                    this.sortedTGsToIndexMap.set(sortedTG, i);\n                } /*   console.warn(this.sortedTemporalGranulesArr);\r\n                    console.warn(this.strToTemporalGranuleMap);\r\n                    console.warn(this.sortedTGsToIndexMap); */\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n\n            this._sortTemporalGranulesMap();\n            return this.sortedTemporalGranulesArr;\n        }\n\n        /**\r\n         * Sort the temporal granules strings (read from file) to the indices of the sorted\r\n         * temporal granules.\r\n         * @private\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_sortTemporalGranulesMap',\n        value: function _sortTemporalGranulesMap() {\n            var sortedIndexMap = new Map();\n            var sortedTGsToIndexMap = this.sortedTGsToIndexMap; //January 2017 -> 0, February 2017 -> 1\n            var strToTGMap = this.strToTemporalGranuleMap; //January 2017 -> 2017_1, February 2017 -> 2017_2\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = sortedTGsToIndexMap.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var key = _step5.value;\n\n                    sortedIndexMap.set(strToTGMap.get(key), sortedTGsToIndexMap.get(key));\n                } //2017_1 -> 0\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            this.temporalGranulesMap = sortedIndexMap;\n        }\n\n        /**\r\n         * Returns the locale month string. \r\n         * In portugal will return 'janeiro', 'fevereiro' etc... \r\n         * @param {string} dateString - The date string read from the file.\r\n         * @returns {string} - the locale month string.\r\n         * @private\r\n         * @see https://stackoverflow.com/a/18648314/\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getLocaleMonth',\n        value: function _getLocaleMonth(dateString) {\n            var date = new Date(dateString.replace(/_/g, '-'));\n            return date.toLocaleString(\"en-us\", { month: \"long\" });\n        }\n\n        /**\r\n         * Returns the month name plus the year.\r\n         * @param {string} dateString \r\n         * @returns {string} - the month name plus the year.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getMonth',\n        value: function _getMonth(dateString) {\n            var date = new Date(dateString.replace(/_/g, '-'));\n            var monthName = this._getLocaleMonth(dateString);\n            var year = date.getFullYear();\n            return monthName + \" \" + year;\n        }\n\n        /**\r\n         * Get the date including the day (day month year).\r\n         * @param {string} dateString - The date string read from the file.\r\n         * @returns {string} - the date including the day.\r\n         * @see https://stackoverflow.com/a/18648314/\r\n         * @private\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: '_getDay',\n        value: function _getDay(dateString) {\n            var date = new Date(dateString.replace(/_/g, '-'));\n            var monthName = this._getLocaleMonth(dateString);\n            var day = date.getDate();\n            var year = date.getFullYear();\n            return day + \" \" + monthName + \" \" + year;\n        }\n\n        /**\r\n         * Returns the index of the temporal granule given by the string. \r\n         * @param {string|number} temporalgranuleStr - The temporal granule string representation.\r\n         * @returns {number} - the index of the temporal granule given by the string.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getGranuleIndexFromStr',\n        value: function getGranuleIndexFromStr(temporalgranuleStr) {\n            var key = this.strToTemporalGranuleMap.get(temporalgranuleStr);\n            return this.temporalGranulesMap.get(key);\n        }\n\n        /**\r\n         * Returns the index of the temporal granule read from the file.\r\n         * @param {string} str - The given string \r\n         * @returns {number} - the index of the temporal granule read from the file.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getTGMapIndex',\n        value: function getTGMapIndex(str) {\n            return this.temporalGranulesMap.get(str);\n        }\n\n        /**\r\n         * Returns the sorted temporal granules. \r\n         * @returns {Array<string|number>} - the sorted temporal granules.  \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getSortedTemporalGranules',\n        value: function getSortedTemporalGranules() {\n            return this.sortedTemporalGranulesArr;\n        }\n\n        /**\r\n         * Returns the first temporal granule from the sorted list of temporal granules.\r\n         * @returns {string|number} - the first temporal granule from the sorted list of temporal granules.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getFirstTemporalGranule',\n        value: function getFirstTemporalGranule() {\n            return this.sortedTemporalGranulesArr[0];\n        }\n\n        /**\r\n         * Returns the indices of the temporal granules between the start and end temporal granules string representations.\r\n         * @param {any} startTGStr - The string representation of the range start temporal granule. \r\n         * @param {any} endTGStr - The string representation of the range end temporal granule. \r\n         * @returns {Array<number>} - the indices of the temporal granules between the given start and end temporal granules.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getRangeIndices',\n        value: function getRangeIndices(startTGStr, endTGStr) {\n            var _ref = [this.sortedTGsToIndexMap.get(startTGStr), this.sortedTGsToIndexMap.get(endTGStr)],\n                sortedStartIndex = _ref[0],\n                sortedEndIndex = _ref[1];\n\n            var sortedTGsArrSliced = this.sortedTemporalGranulesArr.slice(sortedStartIndex, sortedEndIndex + 1);\n            var rangeIndices = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = sortedTGsArrSliced[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var sortedTG = _step6.value;\n\n                    rangeIndices.push(this.getGranuleIndexFromStr(sortedTG));\n                }\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            return rangeIndices;\n        }\n\n        /**\r\n         * Returns the index of the given temporal granule string/number. \r\n         * The index is the value associated with  the given key.\r\n         * @param {string|number} sortedTemporalGranule - The temporal granule string/number.\r\n         * @returns {number} - the index of the given temporal granule string/number. \r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'getSortedIndexFromStr',\n        value: function getSortedIndexFromStr(sortedTemporalGranule) {\n            return this.sortedTGsToIndexMap.get(sortedTemporalGranule);\n        }\n\n        /**\r\n         * Returns the index of the next temporal granule on the \"timeline\".\r\n         * @param {string|number} currentTG - The current temporal granule.\r\n         * @returns {number} - the index of the next temporal granule on the \"timeline\".\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'findNextTGIndex',\n        value: function findNextTGIndex(currentTG) {\n            var indexSortedTG = this.sortedTGsToIndexMap.get(currentTG);\n            var lastTG = this.sortedTemporalGranulesArr.length - 1;\n            var nextSortedTG = this.sortedTemporalGranulesArr[indexSortedTG < lastTG ? indexSortedTG + 1 : indexSortedTG]; //Avoid it going over the last index\n            return this.getSortedIndexFromStr(nextSortedTG);\n        }\n\n        /**\r\n         * Returns the index of the previous temporal granule on the \"timeline\".\r\n         * @param {string|number} currentTG - The current temporal granule.\r\n         * @returns {number} - the index of the previous temporal granule on the \"timeline\".\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'findPreviousTGIndex',\n        value: function findPreviousTGIndex(currentTG) {\n            var indexSortedTG = this.sortedTGsToIndexMap.get(currentTG);\n            var previousTG = this.sortedTemporalGranulesArr[indexSortedTG >= 1 ? indexSortedTG - 1 : indexSortedTG]; //Avoid it going bellow 0\n            return this.getSortedIndexFromStr(previousTG);\n        }\n\n        /**\r\n         * Returns true if the temporal granules are numbers.\r\n         * @returns {boolean} - true if the temporal granules are numbers, false, otherwise.\r\n         * @memberof TimeVariable\r\n         */\n\n    }, {\n        key: 'temporalGranulesAreNumbers',\n        value: function temporalGranulesAreNumbers() {\n            return _GisplayDefaults.GisplayDefaults.isNumber(this.getFirstTemporalGranule()); //typeof this.getFirstTemporalGranule() === 'number';\n        }\n    }]);\n\n    return TimeVariable;\n}(_DataVariable2.DataVariable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvVGltZVZhcmlhYmxlLmpzP2Y0MTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVZhcmlhYmxlIH0gZnJvbSAnLi9EYXRhVmFyaWFibGUnO1xyXG5pbXBvcnQgeyBHaXNwbGF5RGVmYXVsdHMgfSBmcm9tICcuLi9HaXNwbGF5RGVmYXVsdHMnO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHRpbWUgaW5mb3JtYXRpb24uXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIFRpbWVWYXJpYWJsZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRpbWVWYXJpYWJsZSBleHRlbmRzIERhdGFWYXJpYWJsZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRpbWVWYXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlcm5hbE5hbWUgLSBUaGUgZXh0ZXJuYWwgbmFtZSBvZiB0aGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcm5hbE5hbWUgLSBUaGUgaW50ZXJuYWwgbmFtZSBvZiB0aGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncmFudWxhcml0eSAtIFRoZSBncmFudWxhcml0eSBvZiB0aGUgdGltZSB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lQ29udHJvbCAtIFRoZSB0aW1lIGNvbnRyb2wgZm9yIHRoZSB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSwgZ3JhbnVsYXJpdHksIHRpbWVDb250cm9sKSB7XHJcbiAgICAgICAgc3VwZXIoZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0aW1lIGdyYW51bGFyaXR5LlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ncmFudWxhcml0eSA9IGdyYW51bGFyaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBncmFudWxlcyBmb3IgdGhpcyB0aW1lIHZhcmlhYmxlIHRoYXQgd2VyZSBwcm9jZXNzZWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAgICAgKiBAdHlwZSB7U2V0PHN0cmluZ3xudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JhbnVsZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXAgd2l0aCBlYWNoIHRlbXBvcmFsIGdyYW51bGUgYW5kIGl0J3MgaW5kZXguXHJcbiAgICAgICAgICogQHR5cGUge01hcDxudW1iZXJ8c3RyaW5nLCBudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGVtcG9yYWxHcmFudWxlc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBncmFudWxlIGluZGV4LiBUaGlzIGlzIHVzZWQgdG8gZ2l2ZSBlYWNoIGdyYW51bGUgaXQncyBzcGVjaWZpYyBpbmRleC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JhbnVsZUluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGVtcG9yYWwgZ3JhbnVsZXMgc29ydGVkIGJ5IERhdGUuIElmIGl0cyBhIG51bWJlciAoeWVhciBvciBkYXkgb3IgdmFsdWUgZXRjKSB0aGVuIHNvcnRlZCBieSBudW1iZXIuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcnxzdHJpbmc+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0FyciA9IFtdO1xyXG4gICAgICAgIC8qKiBcclxuICAgICAgICAgKiBUaGUgbWFwIHRoYXQgY29udGFpbnMgdGhlIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGUgYW5kIHRoZSByZXNwZWN0aXZlIGRhdGUgKGUuZy4gMjAxNl8xXzEgPT4gMSBKYW51YXJ5IDIwMTYgT1IgMjAxNiA9PiAyMDE2KVxyXG4gICAgICAgICAqIElmIHRoZSBkYXRlIGlzIGEgbnVtYmVyIChlLmcuIHllYXIsIG1vbnRoT2ZZZWFyLCB2YWx1ZSBldGMpIHRoZW4gdGhlIGtleSBhbmQgdGhlIHZhbHVlIGFyZSBlcXVhbCAoMjAxNiA9PiAyMDE2KS5cclxuICAgICAgICAgKiBBIHZhbHVlIGhlcmUgd2lsbCBiZSBhIGtleSBpbiB0aGUgdGVtcG9yYWxHcmFudWxlc01hcC5cclxuICAgICAgICAgKiBAdHlwZSB7TWFwPHN0cmluZ3xudW1iZXIsIHN0cmluZ3xudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RyVG9UZW1wb3JhbEdyYW51bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFRoZSBtYXAgd2l0aCB0aGUgc3RyaW5nIHRlbXBvcmFsIGdyYW51bGVzIGFuZCB0aGVpciByZXNwZWN0aXZlIGluZGV4IGlubSB0aGUgc29ydGVkIHRlbXBvcmFsIGdyYW51bGVzIGFycmF5LlxyXG4gICAgICAgICAqIEUuZy4gTWFwICgzKSAge1wiMSBKYW51YXJ5IDIwMTZcIiA9PiAwLCBcIjIgSmFudWFyeSAyMDE2XCIgPT4gMSwgXCIzIEphbnVhcnkgMjAxNlwiID0+IDIsIFwiNCBKYW51YXJ5IDIwMTZcIiA9PiAzIH0uXHJcbiAgICAgICAgICogVXNlZCB0byBxdWlja2x5IHNlYXJjaCBmb3IgdGhlIGluZGV4IG9mIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50IG9mIHRoZSB0aW1lIGNvbnRyb2wuXHJcbiAgICAgICAgICogQSB2YWx1ZSBoZXJlIGlzIGFuIGluZGV4IGluIHRoZSBzb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyLlxyXG4gICAgICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nfG51bWJlciwgbnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRpbWUgY29udHJvbCB0byB1c2UuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVDb250cm9sID0gdGltZUNvbnRyb2w7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JhbnVsYXJpdHlcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGdyYW51bGFyaXR5LiBcclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0R3JhbnVsYXJpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnVsYXJpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRpbWUgY29udHJvbCB0aGF0IHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFR5cGVPZlRpbWVDb250cm9sKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVDb250cm9sID8gdGhpcy50aW1lQ29udHJvbCA6IEdpc3BsYXlEZWZhdWx0cy5JTlNUQU5UKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdmFpbGFibGUgZ3JhbnVsYXJpdGllcyBmb3IgdGhlIHRpbWUgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gLSB0aGUgc2V0IG9mIGF2YWlsYWJsZSBncmFudWxhcml0aWVzLiAgXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9nZXRBdmFpbGFibGVHcmFudWxhcml0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ3ZhbHVlJywgLy9Db250aW51b3VzXHJcbiAgICAgICAgICAgICdtb250aE9mWWVhcicsICdkYXlPZlllYXInLCAnZGF5T2ZNb250aCcsICdob3VyT2ZEYXknLCAnbWludXRlT2ZIb3VyJyAvLyBDeWNsaWNcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vR1JBTlVMRVMgRVRDXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbGwgdmFsdWVzIHRvIHRoZSB0ZW1wb3JhbCBncmFudWxlcyBtYXAuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlcyAtIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBncmFudWxlcyBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVRlbXBvcmFsR3JhbnVsZXNNYXAodmFsdWVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlcylcclxuICAgICAgICAgICAgdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwLnNldCh2YWwsIHRoaXMuZ3JhbnVsZUluZGV4KyspO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRlbXBvcmFsIGdyYW51bGUgdG8gdGhlIHRlbXBvcmFsIGdyYW51bGVzIHNldCBhbmQgcmV0dXJuIGl0J3MgaW5kZXggaWYgaXQgZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGVtcG9yYWxHcmFudWxlIC0gVGhlIHRlbXBvcmFsIGdyYW51bGUgdG8gYmUgYWRkZWQuIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHRlbXBvcmFsIGdyYW51bGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGFkZFRlbXBvcmFsR3JhbnVsZSh0ZW1wb3JhbEdyYW51bGUpIHtcclxuICAgICAgICBpZiAodGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwLmhhcyh0ZW1wb3JhbEdyYW51bGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwLmdldCh0ZW1wb3JhbEdyYW51bGUpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFsR3JhbnVsZXNNYXAuc2V0KHRlbXBvcmFsR3JhbnVsZSwgdGhpcy5ncmFudWxlSW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFudWxlSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGdpdmVuIHRlbXBvcmFsIGdyYW51bGUgdG8gdGhlIHNldCBvZiBleGlzdGluZyB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdGVtcG9yYWxHcmFudWxlIC0gVGhlIHRlbXBvcmFsIGdyYW51bGUgdG8gYWRkIHRvIHRoZSBzZXQgb2YgdGVtcG9yYWwgZ3JhbnVsZXMuXHJcbiAgICAgKi9cclxuICAgIGFkZFRlbXBvcmFsR3JhbnVsZVRvU2V0KHRlbXBvcmFsR3JhbnVsZSkge1xyXG4gICAgICAgIHRoaXMuZ3JhbnVsZXMuYWRkKHRlbXBvcmFsR3JhbnVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGVtcG9yYWwgZ3JhbnVsZXMgdG8gdGhlIHNldCBvZiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBwYXJhbSB7U2V0PHN0cmluZz59IHRlbXBvcmFsR3JhbnVsZXMgLSBUaGUgdGVtcG9yYWwgZ3JhbnVsZXMuIFxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBhZGRUZW1wb3JhbEdyYW51bGVzVG9TZXQodGVtcG9yYWxHcmFudWxlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGVtcG9yYWxHcmFudWxlIG9mIHRlbXBvcmFsR3JhbnVsZXMua2V5cygpKVxyXG4gICAgICAgICAgICB0aGlzLmFkZFRlbXBvcmFsR3JhbnVsZVRvU2V0KHRlbXBvcmFsR3JhbnVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBTZXQgb2YgdGVtcG9yYWwgZ3JhbnVsZXMuXHJcbiAgICAgKiBAcmV0dXJucyB7U2V0PHN0cmluZz59IC0gdGhlIFNldCBvZiB0ZW1wb3JhbCBncmFudWxlcy4gXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFRlbXBvcmFsR3JhbnVsZXNTZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnVsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wb3JhbCBncmFudWxlcyB0aGF0IGV4aXN0IG9uIHRoZSBkYXRhc2V0LiBFLmcuIDIwMTYsIDIwMTcgZXRjXHJcbiAgICAgKiBAcmV0dXJucyB7TWFwPG51bWJlciwgbnVtYmVyPn0gLSB0aGUgdGVtcG9yYWwgZ3JhbnVsZXMgdGhhdCBleGlzdCBvbiB0aGUgZGF0YXNldC5cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGVtcG9yYWxHcmFudWxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwOy8vQXJyYXkuZnJvbSh0aGlzLnRlbXBvcmFsR3JhbnVsZXNNYXAua2V5cygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcG9yYWwgZ3JhbnVsZSB2YWx1ZXMgd2VyZSBnaXZlbiwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEByZXR1cm5zIHtib29lbGFufSAtIHRydWUgaWYgdGhlIHRlbXBvcmFsIGdyYW51bGUgdmFsdWVzIHdlcmUgZ2l2ZW4sIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgdGhlIHRlbXBvcmFsIGdyYW51bGVzIGNyZWF0aW5nIGFuIGFycmF5IHdpdGggdGhvc2Ugc29ydGVkIGVsZW1lbnRzLlxyXG4gICAgICogSWYgdGhlIGVsZW1lbnRzIGFyZSBkYXRlcyB0aGVuIG9yZGVyIGJ5IGRhdGUsIGlmIHRoZXkgYXJlIG51bWJlcnMgb3JkZXIgYnkgbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZ3xudW1iZXI+fSAtIHRoZSBzb3J0ZWQgdGVtcG9yYWwgZ3JhbnVsZXMsIHNvcnRlZCBieSBkYXRlL251bWJlci5cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgc29ydFRlbXBvcmFsR3JhbnVsZXMoKSB7XHJcbiAgICAgICAgbGV0IGF2YWlsYWJsZUdyYW51bGFyaXRlcyA9IHRoaXMuX2dldEF2YWlsYWJsZUdyYW51bGFyaXRpZXMoKTtcclxuICAgICAgICBsZXQgdGdzID0gdGhpcy5nZXRUZW1wb3JhbEdyYW51bGVzKCkua2V5cygpO1xyXG4gICAgICAgIGxldCBncmFudWxhcml0aWVzQXJyYXkgPSBbXTsgLy8gXHJcbiAgICAgICAgbGV0IHN0clRvVEdNYXAgPSBuZXcgTWFwKCk7IC8vIDI2XzFfMCA9PiAxIEphbnVhcnkgMjAxNlxyXG4gICAgICAgIGZvciAoY29uc3QgdGcgb2YgdGdzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHJHcmFudWxhcml0eTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdyYW51bGFyaXR5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGF2YWlsYWJsZUdyYW51bGFyaXRlc1sxXTogLy9Nb250aFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ckdyYW51bGFyaXR5ID0gdGhpcy5fZ2V0TW9udGgodGcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBhdmFpbGFibGVHcmFudWxhcml0ZXNbMl06IC8vRGF5XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyR3JhbnVsYXJpdHkgPSB0aGlzLl9nZXREYXkodGcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBzdHJHcmFudWxhcml0eSA9IHRnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyYW51bGFyaXRpZXNBcnJheS5wdXNoKHN0ckdyYW51bGFyaXR5KTtcclxuICAgICAgICAgICAgc3RyVG9UR01hcC5zZXQoc3RyR3JhbnVsYXJpdHksIHRnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdHJUb1RlbXBvcmFsR3JhbnVsZU1hcCA9IHN0clRvVEdNYXA7XHJcbiAgICAgICAgdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyID0gZ3JhbnVsYXJpdGllc0FycmF5LnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIG5ldyBEYXRlKGEpIC0gbmV3IERhdGUoYik7IH0pO1xyXG4gICAgICAgIGZvciAobGV0IFtpLCBzb3J0ZWRUR10gb2YgdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyLmVudHJpZXMoKSlcclxuICAgICAgICAgICAgdGhpcy5zb3J0ZWRUR3NUb0luZGV4TWFwLnNldChzb3J0ZWRURywgaSk7XHJcbiAgICAgICAgLyogICBjb25zb2xlLndhcm4odGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyKTtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnN0clRvVGVtcG9yYWxHcmFudWxlTWFwKTtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXApOyAqL1xyXG4gICAgICAgIHRoaXMuX3NvcnRUZW1wb3JhbEdyYW51bGVzTWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0FycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgdGhlIHRlbXBvcmFsIGdyYW51bGVzIHN0cmluZ3MgKHJlYWQgZnJvbSBmaWxlKSB0byB0aGUgaW5kaWNlcyBvZiB0aGUgc29ydGVkXHJcbiAgICAgKiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9zb3J0VGVtcG9yYWxHcmFudWxlc01hcCgpIHtcclxuICAgICAgICBsZXQgc29ydGVkSW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgbGV0IHNvcnRlZFRHc1RvSW5kZXhNYXAgPSB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXA7IC8vSmFudWFyeSAyMDE3IC0+IDAsIEZlYnJ1YXJ5IDIwMTcgLT4gMVxyXG4gICAgICAgIGxldCBzdHJUb1RHTWFwID0gdGhpcy5zdHJUb1RlbXBvcmFsR3JhbnVsZU1hcDsgLy9KYW51YXJ5IDIwMTcgLT4gMjAxN18xLCBGZWJydWFyeSAyMDE3IC0+IDIwMTdfMlxyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzb3J0ZWRUR3NUb0luZGV4TWFwLmtleXMoKSlcclxuICAgICAgICAgICAgc29ydGVkSW5kZXhNYXAuc2V0KHN0clRvVEdNYXAuZ2V0KGtleSksIHNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGtleSkpOyAvLzIwMTdfMSAtPiAwXHJcbiAgICAgICAgdGhpcy50ZW1wb3JhbEdyYW51bGVzTWFwID0gc29ydGVkSW5kZXhNYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbGUgbW9udGggc3RyaW5nLiBcclxuICAgICAqIEluIHBvcnR1Z2FsIHdpbGwgcmV0dXJuICdqYW5laXJvJywgJ2ZldmVyZWlybycgZXRjLi4uIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHJpbmcgLSBUaGUgZGF0ZSBzdHJpbmcgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgbG9jYWxlIG1vbnRoIHN0cmluZy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODY0ODMxNC9cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgX2dldExvY2FsZU1vbnRoKGRhdGVTdHJpbmcpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcucmVwbGFjZSgvXy9nLCAnLScpKTtcclxuICAgICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLXVzXCIsIHsgbW9udGg6IFwibG9uZ1wiIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbW9udGggbmFtZSBwbHVzIHRoZSB5ZWFyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHJpbmcgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBtb250aCBuYW1lIHBsdXMgdGhlIHllYXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9nZXRNb250aChkYXRlU3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nLnJlcGxhY2UoL18vZywgJy0nKSk7XHJcbiAgICAgICAgbGV0IG1vbnRoTmFtZSA9IHRoaXMuX2dldExvY2FsZU1vbnRoKGRhdGVTdHJpbmcpO1xyXG4gICAgICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIHJldHVybiBtb250aE5hbWUgKyBcIiBcIiArIHllYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRhdGUgaW5jbHVkaW5nIHRoZSBkYXkgKGRheSBtb250aCB5ZWFyKS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyaW5nIC0gVGhlIGRhdGUgc3RyaW5nIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGRhdGUgaW5jbHVkaW5nIHRoZSBkYXkuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODY0ODMxNC9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9nZXREYXkoZGF0ZVN0cmluZykge1xyXG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZy5yZXBsYWNlKC9fL2csICctJykpO1xyXG4gICAgICAgIGxldCBtb250aE5hbWUgPSB0aGlzLl9nZXRMb2NhbGVNb250aChkYXRlU3RyaW5nKTtcclxuICAgICAgICBsZXQgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XHJcbiAgICAgICAgbGV0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGRheSArIFwiIFwiICsgbW9udGhOYW1lICsgXCIgXCIgKyB5ZWFyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHRlbXBvcmFsIGdyYW51bGUgZ2l2ZW4gYnkgdGhlIHN0cmluZy4gXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHRlbXBvcmFsZ3JhbnVsZVN0ciAtIFRoZSB0ZW1wb3JhbCBncmFudWxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSB0ZW1wb3JhbCBncmFudWxlIGdpdmVuIGJ5IHRoZSBzdHJpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEdyYW51bGVJbmRleEZyb21TdHIodGVtcG9yYWxncmFudWxlU3RyKSB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuc3RyVG9UZW1wb3JhbEdyYW51bGVNYXAuZ2V0KHRlbXBvcmFsZ3JhbnVsZVN0cik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcG9yYWxHcmFudWxlc01hcC5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSB0ZW1wb3JhbCBncmFudWxlIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgZ2l2ZW4gc3RyaW5nIFxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIHRlbXBvcmFsIGdyYW51bGUgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRUR01hcEluZGV4KHN0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBvcmFsR3JhbnVsZXNNYXAuZ2V0KHN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzb3J0ZWQgdGVtcG9yYWwgZ3JhbnVsZXMuIFxyXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZ3xudW1iZXI+fSAtIHRoZSBzb3J0ZWQgdGVtcG9yYWwgZ3JhbnVsZXMuICBcclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0U29ydGVkVGVtcG9yYWxHcmFudWxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdGVtcG9yYWwgZ3JhbnVsZSBmcm9tIHRoZSBzb3J0ZWQgbGlzdCBvZiB0ZW1wb3JhbCBncmFudWxlcy5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSAtIHRoZSBmaXJzdCB0ZW1wb3JhbCBncmFudWxlIGZyb20gdGhlIHNvcnRlZCBsaXN0IG9mIHRlbXBvcmFsIGdyYW51bGVzLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRGaXJzdFRlbXBvcmFsR3JhbnVsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRUZW1wb3JhbEdyYW51bGVzQXJyWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kaWNlcyBvZiB0aGUgdGVtcG9yYWwgZ3JhbnVsZXMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB0ZW1wb3JhbCBncmFudWxlcyBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxyXG4gICAgICogQHBhcmFtIHthbnl9IHN0YXJ0VEdTdHIgLSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByYW5nZSBzdGFydCB0ZW1wb3JhbCBncmFudWxlLiBcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbmRUR1N0ciAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJhbmdlIGVuZCB0ZW1wb3JhbCBncmFudWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSAtIHRoZSBpbmRpY2VzIG9mIHRoZSB0ZW1wb3JhbCBncmFudWxlcyBiZXR3ZWVuIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIHRlbXBvcmFsIGdyYW51bGVzLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRSYW5nZUluZGljZXMoc3RhcnRUR1N0ciwgZW5kVEdTdHIpIHtcclxuICAgICAgICBsZXQgW3NvcnRlZFN0YXJ0SW5kZXgsIHNvcnRlZEVuZEluZGV4XSA9IFt0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KHN0YXJ0VEdTdHIpLCB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGVuZFRHU3RyKV07XHJcbiAgICAgICAgbGV0IHNvcnRlZFRHc0FyclNsaWNlZCA9IHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0Fyci5zbGljZShzb3J0ZWRTdGFydEluZGV4LCBzb3J0ZWRFbmRJbmRleCArIDEpO1xyXG4gICAgICAgIGxldCByYW5nZUluZGljZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBzb3J0ZWRURyBvZiBzb3J0ZWRUR3NBcnJTbGljZWQpXHJcbiAgICAgICAgICAgIHJhbmdlSW5kaWNlcy5wdXNoKHRoaXMuZ2V0R3JhbnVsZUluZGV4RnJvbVN0cihzb3J0ZWRURykpO1xyXG4gICAgICAgIHJldHVybiByYW5nZUluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gdGVtcG9yYWwgZ3JhbnVsZSBzdHJpbmcvbnVtYmVyLiBcclxuICAgICAqIFRoZSBpbmRleCBpcyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoICB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzb3J0ZWRUZW1wb3JhbEdyYW51bGUgLSBUaGUgdGVtcG9yYWwgZ3JhbnVsZSBzdHJpbmcvbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHRlbXBvcmFsIGdyYW51bGUgc3RyaW5nL251bWJlci4gXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldFNvcnRlZEluZGV4RnJvbVN0cihzb3J0ZWRUZW1wb3JhbEdyYW51bGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRUR3NUb0luZGV4TWFwLmdldChzb3J0ZWRUZW1wb3JhbEdyYW51bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5leHQgdGVtcG9yYWwgZ3JhbnVsZSBvbiB0aGUgXCJ0aW1lbGluZVwiLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjdXJyZW50VEcgLSBUaGUgY3VycmVudCB0ZW1wb3JhbCBncmFudWxlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSB0aGUgaW5kZXggb2YgdGhlIG5leHQgdGVtcG9yYWwgZ3JhbnVsZSBvbiB0aGUgXCJ0aW1lbGluZVwiLlxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBmaW5kTmV4dFRHSW5kZXgoY3VycmVudFRHKSB7XHJcbiAgICAgICAgbGV0IGluZGV4U29ydGVkVEcgPSB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGN1cnJlbnRURyk7XHJcbiAgICAgICAgbGV0IGxhc3RURyA9IHRoaXMuc29ydGVkVGVtcG9yYWxHcmFudWxlc0Fyci5sZW5ndGggLSAxO1xyXG4gICAgICAgIGxldCBuZXh0U29ydGVkVEcgPSB0aGlzLnNvcnRlZFRlbXBvcmFsR3JhbnVsZXNBcnJbaW5kZXhTb3J0ZWRURyA8IGxhc3RURyA/IGluZGV4U29ydGVkVEcgKyAxIDogaW5kZXhTb3J0ZWRUR107IC8vQXZvaWQgaXQgZ29pbmcgb3ZlciB0aGUgbGFzdCBpbmRleFxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvcnRlZEluZGV4RnJvbVN0cihuZXh0U29ydGVkVEcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHRlbXBvcmFsIGdyYW51bGUgb24gdGhlIFwidGltZWxpbmVcIi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY3VycmVudFRHIC0gVGhlIGN1cnJlbnQgdGVtcG9yYWwgZ3JhbnVsZS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIGluZGV4IG9mIHRoZSBwcmV2aW91cyB0ZW1wb3JhbCBncmFudWxlIG9uIHRoZSBcInRpbWVsaW5lXCIuXHJcbiAgICAgKiBAbWVtYmVyb2YgVGltZVZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGZpbmRQcmV2aW91c1RHSW5kZXgoY3VycmVudFRHKSB7XHJcbiAgICAgICAgbGV0IGluZGV4U29ydGVkVEcgPSB0aGlzLnNvcnRlZFRHc1RvSW5kZXhNYXAuZ2V0KGN1cnJlbnRURyk7XHJcbiAgICAgICAgbGV0IHByZXZpb3VzVEcgPSB0aGlzLnNvcnRlZFRlbXBvcmFsR3JhbnVsZXNBcnJbaW5kZXhTb3J0ZWRURyA+PSAxID8gaW5kZXhTb3J0ZWRURyAtIDEgOiBpbmRleFNvcnRlZFRHXTsgLy9Bdm9pZCBpdCBnb2luZyBiZWxsb3cgMFxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNvcnRlZEluZGV4RnJvbVN0cihwcmV2aW91c1RHKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcG9yYWwgZ3JhbnVsZXMgYXJlIG51bWJlcnMuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSB0ZW1wb3JhbCBncmFudWxlcyBhcmUgbnVtYmVycywgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBUaW1lVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgdGVtcG9yYWxHcmFudWxlc0FyZU51bWJlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEdpc3BsYXlEZWZhdWx0cy5pc051bWJlcih0aGlzLmdldEZpcnN0VGVtcG9yYWxHcmFudWxlKCkpOy8vdHlwZW9mIHRoaXMuZ2V0Rmlyc3RUZW1wb3JhbEdyYW51bGUoKSA9PT0gJ251bWJlcic7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL1RpbWVWYXJpYWJsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7OztBQUtBOzs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUZBO0FBQ0E7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7QUFJQTtBQTlDQTtBQStDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW9CQTtBQUNBO0FBQUE7QUFBQTtBQXRCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBOzs7QUF2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7OztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/VVs/URLVariable.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Represents the url variable that is given by the programmer in the parsing options.\r\n * @export\r\n * @class URLVariable\r\n */\nvar URLVariable = exports.URLVariable = function () {\n    /**\r\n     * Creates an instance of URLVariable.\r\n     * @param {File|string} dataURL - URL of the data to read.  \r\n     * @param {File|string} geoSpatialURL - URL of the geometry and identifiers to read.\r\n     * @param {string} idOnDataURL - The id of the geometry in the data URL.\r\n     * @param {string} idOnGeoSpatialURL - The id of the geometry in the geospatial URL.\r\n     * @memberof URLVariable\r\n     */\n    function URLVariable(dataURL, geoSpatialURL, idOnDataURL, idOnGeoSpatialURL) {\n        _classCallCheck(this, URLVariable);\n\n        /**\r\n         * The data url file handler.\r\n         * @type {File|URL}\r\n         */\n        this.dataURL = dataURL;\n        /**\r\n         * The geospatial url file handler.\r\n         * @type {File|URL}\r\n         */\n        this.geoSpatialURL = geoSpatialURL;\n        /**\r\n         * The id of the geometry on the data url.\r\n         * @type {string}\r\n         */\n        this.idOnDataURL = idOnDataURL;\n        /**\r\n         * The id of the geometry on the geospatial url. \r\n         * @type {string}\r\n         */\n        this.idOnGeoSpatialURL = idOnGeoSpatialURL;\n    }\n\n    /**\r\n     * Returns the data URL.\r\n     * @returns {File|URL} - The data URL.\r\n     * @memberof URLVariable\r\n     */\n\n\n    _createClass(URLVariable, [{\n        key: 'getDataURL',\n        value: function getDataURL() {\n            return this.dataURL;\n        }\n\n        /**\r\n         * Returns the name of the data URL.\r\n         * @returns {string} - the name of the data URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getDataName',\n        value: function getDataName() {\n            return this.dataURL instanceof URL ? this.dataURL.href : this.dataURL.name;\n        }\n\n        /**\r\n         * Returns the size in bytes of the data URL.\r\n         * @returns {number} - the size in bytes of the data URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getDataSize',\n        value: function getDataSize() {\n            return this.dataURL instanceof URL ? 0 : this.dataURL.size;\n        }\n\n        /**\r\n         * Returns the geoSpatial URL.\r\n         * @returns {File|URL} - the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getGeoSpatialURL',\n        value: function getGeoSpatialURL() {\n            return this.geoSpatialURL;\n        }\n\n        /**\r\n         * Returns the name of the geospatial URL.\r\n         * @returns {string} - the name of the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getGeospatialName',\n        value: function getGeospatialName() {\n            return this.geoSpatialURL instanceof URL ? this.geoSpatialURL.href : this.geoSpatialURL.name;\n        }\n\n        /**\r\n         * Returns the size in bytes of the geospatial URL.\r\n         * @returns {number} - the size in bytes of the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getGeospatialSize',\n        value: function getGeospatialSize() {\n            return this.geoSpatialURL instanceof URL ? 0 : this.geoSpatialURL.size;\n        }\n\n        /**\r\n         * Returns the id of the geometry in the data URL.\r\n         * @returns {string} - the id of the geometry in the data URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getIdOnDataURL',\n        value: function getIdOnDataURL() {\n            return this.idOnDataURL;\n        }\n\n        /**\r\n         * Returns the id of the geometry in the geospatial URL.\r\n         * @returns {string} - the id of the geometry in the geospatial URL.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'getIdOnGeoSpatialURL',\n        value: function getIdOnGeoSpatialURL() {\n            return this.idOnGeoSpatialURL;\n        }\n\n        /**\r\n         * Returns true if the data file is a geojson file. \r\n         * @returns {boolean} - true, if the data file is a geojson file, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'dataURLisGeoJSON',\n        value: function dataURLisGeoJSON() {\n            return this._isGeoJSON(this.getDataName());\n        }\n\n        /**\r\n         * Returns true if the dataURL is an instance of URL.\r\n         * @returns {boolean} - true if the dataURL is an instance of URL, false, otherwise\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'dataURLisRemote',\n        value: function dataURLisRemote() {\n            return this.dataURL instanceof URL;\n        }\n\n        /**\r\n         * Returns true if the data URL is a remote file. \r\n         * @returns {boolean} - true, if the data URL is a remote file, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'geoSpatialURLisGeoJSON',\n        value: function geoSpatialURLisGeoJSON() {\n            return this.geoSpatialURL !== undefined && this._isGeoJSON(this.getGeospatialName());\n        }\n\n        /**\r\n         * Returns true if the geospatial URL is a remote file. \r\n         * @returns {boolean} - true, if the geospatial URL is a remote file, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'geoSpatialURLisRemote',\n        value: function geoSpatialURLisRemote() {\n            return this.geoSpatialURL instanceof URL;\n        }\n\n        /**\r\n         * Verifies if the given name is a GeoJSON file.\r\n         * @param {string} name - The name of the file. \r\n         * @returns {boolean} - true, if it's a geojson file, false, otherwise.\r\n         * @private\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: '_isGeoJSON',\n        value: function _isGeoJSON(name) {\n            return name.endsWith('.json') || name.endsWith('.geojson');\n        }\n\n        /**\r\n         * Returns true, if both ids exist, false otherwise.\r\n         * @returns {boolean} - true, if both ids exist, false, otherwise.\r\n         * @memberof URLVariable\r\n         */\n\n    }, {\n        key: 'hasIds',\n        value: function hasIds() {\n            return this.idOnDataURL !== undefined && this.idOnGeoSpatialURL !== undefined;\n        }\n    }]);\n\n    return URLVariable;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9WVnMvVVJMVmFyaWFibGUuanM/YmJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHVybCB2YXJpYWJsZSB0aGF0IGlzIGdpdmVuIGJ5IHRoZSBwcm9ncmFtbWVyIGluIHRoZSBwYXJzaW5nIG9wdGlvbnMuXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIFVSTFZhcmlhYmxlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVVJMVmFyaWFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFVSTFZhcmlhYmxlLlxyXG4gICAgICogQHBhcmFtIHtGaWxlfHN0cmluZ30gZGF0YVVSTCAtIFVSTCBvZiB0aGUgZGF0YSB0byByZWFkLiAgXHJcbiAgICAgKiBAcGFyYW0ge0ZpbGV8c3RyaW5nfSBnZW9TcGF0aWFsVVJMIC0gVVJMIG9mIHRoZSBnZW9tZXRyeSBhbmQgaWRlbnRpZmllcnMgdG8gcmVhZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZE9uRGF0YVVSTCAtIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgaW4gdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkT25HZW9TcGF0aWFsVVJMIC0gVGhlIGlkIG9mIHRoZSBnZW9tZXRyeSBpbiB0aGUgZ2Vvc3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAbWVtYmVyb2YgVVJMVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YVVSTCwgZ2VvU3BhdGlhbFVSTCwgaWRPbkRhdGFVUkwsIGlkT25HZW9TcGF0aWFsVVJMKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRhdGEgdXJsIGZpbGUgaGFuZGxlci5cclxuICAgICAgICAgKiBAdHlwZSB7RmlsZXxVUkx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhVVJMID0gZGF0YVVSTDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZ2Vvc3BhdGlhbCB1cmwgZmlsZSBoYW5kbGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtGaWxlfFVSTH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdlb1NwYXRpYWxVUkwgPSBnZW9TcGF0aWFsVVJMO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgb24gdGhlIGRhdGEgdXJsLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZE9uRGF0YVVSTCA9IGlkT25EYXRhVVJMO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgb24gdGhlIGdlb3NwYXRpYWwgdXJsLiBcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWRPbkdlb1NwYXRpYWxVUkwgPSBpZE9uR2VvU3BhdGlhbFVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQHJldHVybnMge0ZpbGV8VVJMfSAtIFRoZSBkYXRhIFVSTC5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhVVJMKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFVUkw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBkYXRhIFVSTC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldERhdGFOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFVUkwgaW5zdGFuY2VvZiBVUkwgPyB0aGlzLmRhdGFVUkwuaHJlZiA6IHRoaXMuZGF0YVVSTC5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBpbiBieXRlcyBvZiB0aGUgZGF0YSBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBzaXplIGluIGJ5dGVzIG9mIHRoZSBkYXRhIFVSTC5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVVJMIGluc3RhbmNlb2YgVVJMID8gMCA6IHRoaXMuZGF0YVVSTC5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2VvU3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7RmlsZXxVUkx9IC0gdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEdlb1NwYXRpYWxVUkwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU3BhdGlhbFVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgbmFtZSBvZiB0aGUgZ2Vvc3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAbWVtYmVyb2YgVVJMVmFyaWFibGVcclxuICAgICAqL1xyXG4gICAgZ2V0R2Vvc3BhdGlhbE5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU3BhdGlhbFVSTCBpbnN0YW5jZW9mIFVSTCA/IHRoaXMuZ2VvU3BhdGlhbFVSTC5ocmVmIDogdGhpcy5nZW9TcGF0aWFsVVJMLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIGluIGJ5dGVzIG9mIHRoZSBnZW9zcGF0aWFsIFVSTC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gdGhlIHNpemUgaW4gYnl0ZXMgb2YgdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldEdlb3NwYXRpYWxTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb1NwYXRpYWxVUkwgaW5zdGFuY2VvZiBVUkwgPyAwIDogdGhpcy5nZW9TcGF0aWFsVVJMLnNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgaW4gdGhlIGRhdGEgVVJMLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaWQgb2YgdGhlIGdlb21ldHJ5IGluIHRoZSBkYXRhIFVSTC5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRJZE9uRGF0YVVSTCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZE9uRGF0YVVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBnZW9tZXRyeSBpbiB0aGUgZ2Vvc3BhdGlhbCBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBpZCBvZiB0aGUgZ2VvbWV0cnkgaW4gdGhlIGdlb3NwYXRpYWwgVVJMLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldElkT25HZW9TcGF0aWFsVVJMKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkT25HZW9TcGF0aWFsVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRhIGZpbGUgaXMgYSBnZW9qc29uIGZpbGUuIFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSwgaWYgdGhlIGRhdGEgZmlsZSBpcyBhIGdlb2pzb24gZmlsZSwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBkYXRhVVJMaXNHZW9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0dlb0pTT04odGhpcy5nZXREYXRhTmFtZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF0YVVSTCBpcyBhbiBpbnN0YW5jZSBvZiBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBkYXRhVVJMIGlzIGFuIGluc3RhbmNlIG9mIFVSTCwgZmFsc2UsIG90aGVyd2lzZVxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGRhdGFVUkxpc1JlbW90ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVVJMIGluc3RhbmNlb2YgVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkYXRhIFVSTCBpcyBhIHJlbW90ZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHRoZSBkYXRhIFVSTCBpcyBhIHJlbW90ZSBmaWxlLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdlb1NwYXRpYWxVUkxpc0dlb0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvU3BhdGlhbFVSTCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzR2VvSlNPTih0aGlzLmdldEdlb3NwYXRpYWxOYW1lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnZW9zcGF0aWFsIFVSTCBpcyBhIHJlbW90ZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIHRoZSBnZW9zcGF0aWFsIFVSTCBpcyBhIHJlbW90ZSBmaWxlLCBmYWxzZSwgb3RoZXJ3aXNlLlxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIGdlb1NwYXRpYWxVUkxpc1JlbW90ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9TcGF0aWFsVVJMIGluc3RhbmNlb2YgVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgaWYgdGhlIGdpdmVuIG5hbWUgaXMgYSBHZW9KU09OIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUsIGlmIGl0J3MgYSBnZW9qc29uIGZpbGUsIGZhbHNlLCBvdGhlcndpc2UuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlcm9mIFVSTFZhcmlhYmxlXHJcbiAgICAgKi9cclxuICAgIF9pc0dlb0pTT04obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lLmVuZHNXaXRoKCcuanNvbicpIHx8IG5hbWUuZW5kc1dpdGgoJy5nZW9qc29uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUsIGlmIGJvdGggaWRzIGV4aXN0LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlLCBpZiBib3RoIGlkcyBleGlzdCwgZmFsc2UsIG90aGVyd2lzZS5cclxuICAgICAqIEBtZW1iZXJvZiBVUkxWYXJpYWJsZVxyXG4gICAgICovXHJcbiAgICBoYXNJZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRPbkRhdGFVUkwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlkT25HZW9TcGF0aWFsVVJMICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvVlZzL1VSTFZhcmlhYmxlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/* no static exports found */
/* all exports used */
/*!*********************************************************************************************!*\
  !*** ./~/babel-loader/lib?{"presets":["es2015"]}!./src/Gisplay/Parser/CSV/CSVDataWorker.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataVariable = __webpack_require__(/*! ../../VVs/DataVariable */ 1);\n\nvar _URLVariable = __webpack_require__(/*! ../../VVs/URLVariable */ 7);\n\nvar _TimeVariable = __webpack_require__(/*! ../../VVs/TimeVariable */ 6);\n\nvar _CategoricalVariable = __webpack_require__(/*! ../../VVs/CategoricalVariable */ 3);\n\nvar _ContinuousVariable = __webpack_require__(/*! ../../VVs/ContinuousVariable */ 5);\n\nvar _GisplayDefaults = __webpack_require__(/*! ../../GisplayDefaults */ 0);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar worker = self;\n\nvar CSVDataWorker = function () {\n    function CSVDataWorker() {\n        var _this = this;\n\n        _classCallCheck(this, CSVDataWorker);\n\n        // console.log(\"-------------------CSV Data Worker-------------------\");\n        /**\r\n         * The first row read by this data worker.\r\n         * @type {string}\r\n         */\n        this.firstWorkerRow = '';\n        /**\r\n         * The last row of the last chunk read by the parser.\r\n         * @type {string}\r\n         */\n        this.lastWorkerRow = '';\n        /**\r\n         * Save the remaining of the last row from the chunk that was read.\r\n         * It's used when a chunk didn't end in a row delimitir character.\r\n         * @type {string}\r\n         */\n        this.remainingChunkRow = '';\n\n        /**\r\n         * The data file.\r\n         * @type {File}\r\n         */\n        this.dataFile = null;\n        /**\r\n         * The start byte for this worker.\r\n         * @type {number}\r\n         */\n        this.startByte = 0;\n        /**\r\n         * The end byte for this worker.\r\n         * @type {number}\r\n         */\n        this.endByte = 0;\n        /**\r\n         * The size of each chunk to read from the file.\r\n         * @type {number}\r\n         */\n        this.chunkSize = 0;\n        /**\r\n         * The index of this worker. DELETE?\r\n         * @type {number}\r\n         */\n        this.workerIndex = -1;\n        /**\r\n         * Number of columns for each row. DELETE?\r\n         * @type {number}\r\n         */\n        this.numColumnsPerRow = -1; //NOT USED ATM\n\n        /**\r\n         * The row delimiter.\r\n         * @type {string}\r\n         */\n        this.rowDelimiter = '';\n        /**\r\n         * The column delimiter.\r\n         * @type {string}\r\n         */\n        this.columnDelimiter = '';\n\n        /**\r\n         * The header indices. \r\n         * The array is split into 5 positions: [0]categorical, [1]continuous, [2]geometry, [3]time and [4]optional variables. \r\n         * @type {Array<Array<number>>}\r\n         */\n        this.headerIndices = [];\n\n        //TIME \n        /**\r\n         * The time variable.\r\n         * @type {TimeVariable}\r\n         */\n        this.timeVariable = null;\n        /**\r\n         * The granularity of the time variable.\r\n         * @type {string}\r\n         */\n        this.timeGranularity = '';\n\n        //CATEGORICAL\n        /**\r\n         * The categorical variables present in the user options.\r\n         * @type {Array<CategoricalVariable>}\r\n         */\n        this.categoricalVariables = [];\n        /**\r\n         * If the options contain any categorical variable.\r\n         * @type {boolean}\r\n         */\n        this.hasCategoricalVariables = false;\n\n        //CONTINUOUS\n        /**\r\n         * The continuous variables.\r\n         * @type {Array<ContinuousVariable>}\r\n         */\n        this.continuousVariables = [];\n\n        //OPTIONAL\n        /**\r\n         * The optional variables.\r\n         * @type {Array<DataVariable>}\r\n         */\n        this.optionalVariables = [];\n\n        /**\r\n         * The FileReader used to read a portion of the file.\r\n         * @type {FileReader}\r\n         */\n        this.reader = this.createFileReader();\n        worker.onmessage = function (e) {\n            _this.onMessage(e.data);\n        };\n\n        //SAVE INFORMATION\n        /**\r\n         * Used to save the rows directly read from the file\r\n         * @type {Array<Array<string|number>>}\r\n         */\n        this.dataRowsSaved = []; //Save rows read by this Worker\n        /**\r\n         * The final data rows which contain all information to be sent to the main thread.\r\n         * @type {Array<Array<{continuousData: Array<Array<number>>, spatialData: Array<number>,optionalData: Array<Array<number|string>>, RGBA: Array<number>, numberRGBA: Array<number>}>>}\r\n         */\n        this.finalDataRows = [];\n        // this.numRowsRead = 0;\n\n        /** \r\n         * Will be true when we want to process the last line.\r\n         * @type {boolean}\r\n         */\n        this.isLastLine = false;\n    }\n\n    /**\r\n     * Create file reader.\r\n     * @returns {FileReader} - the FileReader used to read a portion of the file.\r\n     * @memberof CSVDataWorker\r\n     */\n\n\n    _createClass(CSVDataWorker, [{\n        key: 'createFileReader',\n        value: function createFileReader() {\n            var _this2 = this;\n\n            var reader = new FileReader();\n            reader.onload = function (e) {\n                _this2.chunkReadFromFile(e);\n            };\n            reader.onerror = function (e) {\n                console.error(e);\n            };\n            return reader;\n        }\n\n        /**\r\n         * When the worker receives a message. \r\n         * @param {{protocolMessage: string, messageData:Object}} dataMessage - The data message that was sent by the main Thread.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'onMessage',\n        value: function onMessage(dataMessage) {\n            // console.log(\"-------------------CSV Data Worker-------------------\");\n            // console.log(dataMessage);\n            var protocolMessages = _GisplayDefaults.GisplayDefaults.MESSAGES_CSV();\n            switch (dataMessage.protocolMessage) {\n                case protocolMessages.TO_START:\n                    {\n                        //Worker processed it's part\n                        //File and chunk information\n                        var workerOptions = dataMessage.messageData.workerOptions;\n                        this.dataFile = workerOptions.dataFile;\n                        this.startByte = workerOptions.startByte;\n                        this.endByte = workerOptions.endByte;\n                        this.chunkSize = workerOptions.chunkSize;\n                        this.workerIndex = workerOptions.workerIndex;\n                        this.numColumnsPerRow = workerOptions.numColumnsPerRow;\n                        this.rowDelimiter = workerOptions.rowDelimiter;\n                        this.columnDelimiter = workerOptions.columnDelimiter;\n                        //Indices and class calc\n                        this.headerIndices = workerOptions.headerIndices;\n                        //Save Categorical/Continuous and time Vars\n                        this._saveVariables(dataMessage.messageData.workerOptions);\n                        //Start reading file\n                        this.readNextChunk();\n                        break;\n                    }\n                case protocolMessages.TO_LIMITS_CAT:\n                    {\n                        console.log(\"TO_LIMIT_CAT\");\n                        var catVarsCategoriesMap = new Map();\n                        var _iteratorNormalCompletion = true;\n                        var _didIteratorError = false;\n                        var _iteratorError = undefined;\n\n                        try {\n                            for (var _iterator = this.categoricalVariables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                                var catVar = _step.value;\n\n                                catVarsCategoriesMap.set(catVar.getInternalName(), catVar.getCategories());\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return) {\n                                    _iterator.return();\n                                }\n                            } finally {\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n\n                        var contVarsMinMaxMap = new Map();\n                        var _iteratorNormalCompletion2 = true;\n                        var _didIteratorError2 = false;\n                        var _iteratorError2 = undefined;\n\n                        try {\n                            for (var _iterator2 = this.continuousVariables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                var contVar = _step2.value;\n\n                                contVarsMinMaxMap.set(contVar.getInternalName(), [contVar.getMin(), contVar.getMax()]);\n                            } // console.log(this.workerIndex, catVarsCategoriesMap, contVarsMinMaxMap, this.timeVariable, this.timeVariable.getTemporalGranulesSet())\n                        } catch (err) {\n                            _didIteratorError2 = true;\n                            _iteratorError2 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                    _iterator2.return();\n                                }\n                            } finally {\n                                if (_didIteratorError2) {\n                                    throw _iteratorError2;\n                                }\n                            }\n                        }\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_LIMITS_CAT,\n                            messageData: {\n                                categoricalVariables: catVarsCategoriesMap,\n                                continousVariables: contVarsMinMaxMap,\n                                timeVariable: this.timeVariable ? this.timeVariable.getTemporalGranulesSet() : this.timeVariable\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_LIMITS_CAT_RES:\n                    {\n                        var continousVarsMinMax = dataMessage.messageData;\n                        var _iteratorNormalCompletion3 = true;\n                        var _didIteratorError3 = false;\n                        var _iteratorError3 = undefined;\n\n                        try {\n                            for (var _iterator3 = this.continuousVariables.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                                var _step3$value = _slicedToArray(_step3.value, 2),\n                                    i = _step3$value[0],\n                                    _contVar = _step3$value[1];\n\n                                _contVar.setMinMax(continousVarsMinMax[i][0]);\n                                _contVar.setMinMax(continousVarsMinMax[i][1]);\n                                _contVar.setStep(); //Update step value\n                            }\n\n                            //Loop through data and calculate bins for each continuous variable\n                        } catch (err) {\n                            _didIteratorError3 = true;\n                            _iteratorError3 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                    _iterator3.return();\n                                }\n                            } finally {\n                                if (_didIteratorError3) {\n                                    throw _iteratorError3;\n                                }\n                            }\n                        }\n\n                        var contPosStart = this.categoricalVariables.length;\n                        var contPosEnd = contPosStart + this.continuousVariables.length;\n                        var _iteratorNormalCompletion4 = true;\n                        var _didIteratorError4 = false;\n                        var _iteratorError4 = undefined;\n\n                        try {\n                            for (var _iterator4 = this.dataRowsSaved[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                                var data = _step4.value;\n\n                                for (var i = contPosStart; i < contPosEnd; i++) {\n                                    this.continuousVariables[i - contPosStart].addValueToBins(data[i]);\n                                }\n                            }\n                        } catch (err) {\n                            _didIteratorError4 = true;\n                            _iteratorError4 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                    _iterator4.return();\n                                }\n                            } finally {\n                                if (_didIteratorError4) {\n                                    throw _iteratorError4;\n                                }\n                            }\n                        }\n\n                        var histograms = [];\n                        var _iteratorNormalCompletion5 = true;\n                        var _didIteratorError5 = false;\n                        var _iteratorError5 = undefined;\n\n                        try {\n                            for (var _iterator5 = this.continuousVariables[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                                var _contVar2 = _step5.value;\n\n                                histograms.push(_contVar2.getHistogram());\n                            } // console.log(this.continuousVariables[0].getHistogram());\n                        } catch (err) {\n                            _didIteratorError5 = true;\n                            _iteratorError5 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                    _iterator5.return();\n                                }\n                            } finally {\n                                if (_didIteratorError5) {\n                                    throw _iteratorError5;\n                                }\n                            }\n                        }\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_LIMITS_CAT_RES,\n                            messageData: {\n                                histograms: histograms\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_JOIN_DATA:\n                    {\n                        //Process data and then send the res data\n                        if (this.workerIndex === 0) {\n                            console.log(\"I will process the data....NOT\");\n                            console.log(dataMessage.messageData);\n                        }\n\n                        var catVars = dataMessage.messageData.categoricalVariables;\n                        var _iteratorNormalCompletion6 = true;\n                        var _didIteratorError6 = false;\n                        var _iteratorError6 = undefined;\n\n                        try {\n                            for (var _iterator6 = catVars.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                                var _step6$value = _slicedToArray(_step6.value, 2),\n                                    _i2 = _step6$value[0],\n                                    _catVar = _step6$value[1];\n\n                                this.categoricalVariables[_i2].valueToIndexMap = _catVar.valueToIndexMap;\n                            }\n                        } catch (err) {\n                            _didIteratorError6 = true;\n                            _iteratorError6 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                    _iterator6.return();\n                                }\n                            } finally {\n                                if (_didIteratorError6) {\n                                    throw _iteratorError6;\n                                }\n                            }\n                        }\n\n                        var contVars = dataMessage.messageData.continuousVariables;\n                        var _iteratorNormalCompletion7 = true;\n                        var _didIteratorError7 = false;\n                        var _iteratorError7 = undefined;\n\n                        try {\n                            for (var _iterator7 = contVars.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                                var _step7$value = _slicedToArray(_step7.value, 2),\n                                    _i3 = _step7$value[0],\n                                    _contVar3 = _step7$value[1];\n\n                                this.continuousVariables[_i3].classIntervals = _contVar3.classIntervals;\n                            }\n                        } catch (err) {\n                            _didIteratorError7 = true;\n                            _iteratorError7 = err;\n                        } finally {\n                            try {\n                                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                    _iterator7.return();\n                                }\n                            } finally {\n                                if (_didIteratorError7) {\n                                    throw _iteratorError7;\n                                }\n                            }\n                        }\n\n                        var tVar = dataMessage.messageData.timeVariable;\n                        if (tVar) this.timeVariable.temporalGranulesMap = tVar.temporalGranulesMap;\n\n                        var msgData = dataMessage.messageData;\n                        var mvcs = msgData.mvcs,\n                            numberMVCs = mvcs.size,\n                            numberTGs = msgData.numberTGs;\n                        this._joinData(mvcs, numberTGs);\n\n                        var numTotalElements = 0; //Create array to send information about this worker\n                        console.error(this.finalDataRows);\n                        /*    if (this.continuousVariables.length > 0) {\r\n                               for (let i = 0; i < numberMVCs; i++)\r\n                                   for (let j = 0; j < numberTGs; j++)\r\n                                       numTotalElements += this.finalDataRows[i][j].continuousData[0].length;\r\n                           } else {\r\n                               // throw new Error(\"\"); */\n                        for (var _i = 0; _i < numberMVCs; _i++) {\n                            for (var j = 0; j < numberTGs; j++) {\n                                if (this.headerIndices[2].length) numTotalElements += this.finalDataRows[_i][j].spatialData.length / 2; //Lat/Lng\n                                else numTotalElements += this.finalDataRows[_i][j].spatialData.length; //Ids\n                            }\n                        }\n                        // }\n                        console.warn(numTotalElements);\n\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_JOIN_DATA,\n                            messageData: {\n                                numTotalElements: numTotalElements,\n                                workerIndex: this.workerIndex\n                            }\n                        });\n                        break;\n                    }\n                case protocolMessages.TO_GENERATE_RGBA:\n                    {\n                        // Should Generate RGBAs for all MVCs/TGs \n                        this._generateRGBACodes(dataMessage.messageData);\n                        worker.postMessage({ protocolMessage: protocolMessages.END_GENERATE_RGBA });\n                        break;\n                    }\n                case protocolMessages.TO_SEND_DATA:\n                    {\n                        worker.postMessage({\n                            protocolMessage: protocolMessages.END_SEND_DATA,\n                            messageData: {\n                                finalDataRows: this.finalDataRows\n                            }\n                        });\n                        break;\n                    }\n            }\n        }\n\n        /**\r\n         * Generate RGBA codes for each element in each MVC/TG.\r\n         * @param {Array<Array<number>} startRGBANum - The start RGBA number for this worker.. \r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_generateRGBACodes',\n        value: function _generateRGBACodes(startRGBANum) {\n            var numMVCs = this.finalDataRows.length,\n                numTGs = this.finalDataRows[0].length;\n            for (var i = 0; i < numMVCs; i++) {\n                // let startRGBA = startingRGBANumber[i],\n                // let startRGBANum = GisplayDefaults.RGBAToNumber(...startRGBA);\n                for (var j = 0; j < numTGs; j++) {\n                    var numberOfElements = 0;\n                    if (this.headerIndices[2].length) numberOfElements = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\n                    else numberOfElements = this.finalDataRows[i][j].spatialData.length; //Ids\n                    // let continuousDataLength = this.finalDataRows[i][j].continuousData[0].length; //Using continuous data that might not exist\n                    if (numberOfElements > 0) {\n                        for (var k = 0; k < numberOfElements; k++) {\n                            var _finalDataRows$i$j$RG;\n\n                            var RGBA = _GisplayDefaults.GisplayDefaults.numberToRGBA(startRGBANum);\n                            (_finalDataRows$i$j$RG = this.finalDataRows[i][j].RGBA).push.apply(_finalDataRows$i$j$RG, _toConsumableArray(RGBA));\n                            this.finalDataRows[i][j].numberRGBA.push(startRGBANum++);\n                        }\n                    }\n                }\n            }\n            this.verifyIntegrityRGBA(numMVCs, numTGs);\n        }\n    }, {\n        key: 'verifyIntegrityRGBA',\n        value: function verifyIntegrityRGBA(numMVCs, numTGs) {\n            // console.warn(\"VERIFY INTEGRITY\")\n            for (var i = 0; i < numMVCs; i++) {\n                for (var j = 0; j < numTGs; j++) {\n                    var continuousDataLength = 0;\n                    if (this.headerIndices[2].length) continuousDataLength = this.finalDataRows[i][j].spatialData.length / 2; //Lat/Lng\n                    else continuousDataLength = this.finalDataRows[i][j].spatialData.length; //Ids\n                    if (continuousDataLength > 0) for (var k = 0; k < continuousDataLength - 1; k++) {\n                        console.assert(this.finalDataRows[i][j].numberRGBA[k] + 1 === this.finalDataRows[i][j].numberRGBA[k + 1]);\n                    }\n                }\n            }\n        }\n\n        /**\r\n         * Join the data into MVCs and TGs.\r\n         * @param {Map<string, number>} mvcs - The generated MVCs map and respective index.\r\n         * @param {number} numberTGs - The number of temporal granules.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_joinData',\n        value: function _joinData(mvcs, numberTGs) {\n            //Loop through rows and copy them to the final array\n            //categorical vars and time var can be ignored (they are known by the arrays indices)\n            //Save cont vars, geometry, opt vars and RGBA value\n\n            var hasIds = this.headerIndices[2].length ? false : true;\n            var geoPositions = hasIds ? 1 : 2;\n\n            // console.warn(this.timeVariable, mvcs);\n            var numberMVCs = mvcs.size,\n                numCatVars = this.categoricalVariables.length,\n                numContVars = this.continuousVariables.length,\n                geoStartPos = numCatVars + numContVars,\n                geoEndPos = geoStartPos + geoPositions,\n                timePos = geoEndPos;\n\n            this.finalDataRows = this._createFinalRows(numberMVCs, numberTGs);\n            //For each row saved then split it to its place\n            var _iteratorNormalCompletion8 = true;\n            var _didIteratorError8 = false;\n            var _iteratorError8 = undefined;\n\n            try {\n                for (var _iterator8 = this.dataRowsSaved[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                    var rowSaved = _step8.value;\n\n                    var finalRow = [];\n                    var combination = '';\n\n                    var _iteratorNormalCompletion9 = true;\n                    var _didIteratorError9 = false;\n                    var _iteratorError9 = undefined;\n\n                    try {\n                        for (var _iterator9 = this.categoricalVariables.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                            var _step9$value = _slicedToArray(_step9.value, 2),\n                                _i6 = _step9$value[0],\n                                catVar = _step9$value[1];\n\n                            combination += catVar.findIndex(rowSaved[_i6]);\n                        }\n                    } catch (err) {\n                        _didIteratorError9 = true;\n                        _iteratorError9 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                                _iterator9.return();\n                            }\n                        } finally {\n                            if (_didIteratorError9) {\n                                throw _iteratorError9;\n                            }\n                        }\n                    }\n\n                    var contValues = [];\n                    var _iteratorNormalCompletion10 = true;\n                    var _didIteratorError10 = false;\n                    var _iteratorError10 = undefined;\n\n                    try {\n                        for (var _iterator10 = this.continuousVariables.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                            var _step10$value = _slicedToArray(_step10.value, 2),\n                                j = _step10$value[0],\n                                contVar = _step10$value[1];\n\n                            var contValue = rowSaved[j + numCatVars];\n                            combination += contVar.findClassIntervalIndex(contValue);\n                            contValues.push(contValue);\n                        }\n                    } catch (err) {\n                        _didIteratorError10 = true;\n                        _iteratorError10 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                                _iterator10.return();\n                            }\n                        } finally {\n                            if (_didIteratorError10) {\n                                throw _iteratorError10;\n                            }\n                        }\n                    }\n\n                    var mvcIndex = mvcs.get(combination);\n                    var tgIndex = this.timeVariable !== undefined ? this.timeVariable.getTGMapIndex(rowSaved[timePos]) : 0;\n                    if (tgIndex === undefined) console.error(\"HERE\");\n                    for (var i = 0; i < contValues.length; i++) {\n                        this.finalDataRows[mvcIndex][tgIndex].continuousData[i].push(contValues[i]);\n                    }for (var _i4 = geoStartPos; _i4 < geoEndPos; _i4++) {\n                        this.finalDataRows[mvcIndex][tgIndex].spatialData.push(rowSaved[_i4]);\n                    }for (var _i5 = timePos + 1; _i5 < rowSaved.length; _i5++) {\n                        this.finalDataRows[mvcIndex][tgIndex].optionalData[_i5 - timePos - 1].push(rowSaved[_i5]);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError8 = true;\n                _iteratorError8 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                        _iterator8.return();\n                    }\n                } finally {\n                    if (_didIteratorError8) {\n                        throw _iteratorError8;\n                    }\n                }\n            }\n\n            this.dataRowsSaved = undefined; //Allows Garbage collection\n        }\n\n        /**\r\n         * Create the final row to hold the information that the worker should send at the end to the main thread.\r\n         * @param {number} numberMVCs - Number of existing map variable combinations.\r\n         * @param {number} numberTGs - Number of existing temporal granules . \r\n         * @returns {Array<any>} - the final row to hold the information that the worker should send at the end to the main thread.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_createFinalRows',\n        value: function _createFinalRows(numberMVCs, numberTGs) {\n            var finalRows = [];\n\n            //Create arrays for optionalData\n            var optionalDataArrays = [];\n            for (var i = 0; i < this.optionalVariables.length; i++) {\n                //Create multiple arrays one for each optional variable\n                optionalDataArrays[i] = [];\n            }var continuosDataArrays = [];\n            for (var _i7 = 0; _i7 < this.continuousVariables.length; _i7++) {\n                //Create multiple arrays one for each optional variable\n                continuosDataArrays[_i7] = [];\n            } //Create array for final Rows\n            for (var _i8 = 0; _i8 < numberMVCs; _i8++) {\n                finalRows[_i8] = [];\n                for (var j = 0; j < numberTGs; j++) {\n                    finalRows[_i8][j] = {\n                        continuousData: _GisplayDefaults.GisplayDefaults.cloneNestedArray(continuosDataArrays),\n                        spatialData: [],\n                        optionalData: _GisplayDefaults.GisplayDefaults.cloneNestedArray(optionalDataArrays),\n                        RGBA: [],\n                        numberRGBA: []\n                    };\n                }\n            }\n            // console.log(finalRows);\n            return finalRows;\n        }\n\n        /**\r\n         * Recreate the variables sent by the main thread.\r\n         * @param {{continousVariables: Array<ContinuousVariable>, categoricalVariables: Array<CategoricalVariable>, timeVariable: TimeVariable}} data - Data sent by the main thread.\r\n         * @memberof CSVNewDataWorker\r\n         */\n\n    }, {\n        key: '_saveVariables',\n        value: function _saveVariables(data) {\n            var contVars = [];\n            var _iteratorNormalCompletion11 = true;\n            var _didIteratorError11 = false;\n            var _iteratorError11 = undefined;\n\n            try {\n                for (var _iterator11 = data.continuousVariables[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                    var contVar = _step11.value;\n\n                    console.log(contVar);\n                    contVars.push(new _ContinuousVariable.ContinuousVariable(contVar.externalName, contVar.internalName, contVar.typeOfVisualVariable, contVar.shaderVariableQualifier, contVar.visualVariableMapping, contVar.classBreaks, contVar.numberOfClasses, contVar.classBreakMethod, contVar.classBreakMethodParams));\n                }\n                // let doa = true;\n                // if (doa) {\n            } catch (err) {\n                _didIteratorError11 = true;\n                _iteratorError11 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                        _iterator11.return();\n                    }\n                } finally {\n                    if (_didIteratorError11) {\n                        throw _iteratorError11;\n                    }\n                }\n            }\n\n            var catVars = [];\n            var _iteratorNormalCompletion12 = true;\n            var _didIteratorError12 = false;\n            var _iteratorError12 = undefined;\n\n            try {\n                for (var _iterator12 = data.categoricalVariables[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n                    var catVar = _step12.value;\n\n                    catVars.push(new _CategoricalVariable.CategoricalVariable(catVar.externalName, catVar.internalName, catVar.typeOfVisualVariable, catVar.shaderVariableQualifier, catVar.visualVariableMapping, null));\n                }\n            } catch (err) {\n                _didIteratorError12 = true;\n                _iteratorError12 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                        _iterator12.return();\n                    }\n                } finally {\n                    if (_didIteratorError12) {\n                        throw _iteratorError12;\n                    }\n                }\n            }\n\n            var tVar = data.timeVariable;\n            var timeVariable = void 0;\n            if (tVar !== undefined) {\n                timeVariable = new _TimeVariable.TimeVariable(tVar.externalName, tVar.internalName, tVar.granularity, tVar.timeControl);\n            }\n            var optVars = [];\n            var _iteratorNormalCompletion13 = true;\n            var _didIteratorError13 = false;\n            var _iteratorError13 = undefined;\n\n            try {\n                for (var _iterator13 = data.optionalVariables[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                    var optVar = _step13.value;\n\n                    optVars.push(new _DataVariable.DataVariable(optVar.externalName, optVar.internalName));\n                } //TIME\n                // this.timeVariable = workerOptions.timeVariable;\n            } catch (err) {\n                _didIteratorError13 = true;\n                _iteratorError13 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                        _iterator13.return();\n                    }\n                } finally {\n                    if (_didIteratorError13) {\n                        throw _iteratorError13;\n                    }\n                }\n            }\n\n            this.timeVariable = timeVariable;\n            this.timeGranularity = this.timeVariable ? this.timeVariable.getGranularity() : '';\n            //CATEGORICAL\n            this.categoricalVariables = catVars; //workerOptions.categoricalVariables;\n            this.hasCategoricalVariables = this.categoricalVariables.length > 0;\n            //CONTINOUS \n            this.continuousVariables = contVars; //workerOptions.continuousVariables;\n            //OPTIONAL VARS\n            this.optionalVariables = optVars;\n            // }\n        }\n\n        /**\r\n         * Reads a chunk of bytes from the file.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'readNextChunk',\n        value: function readNextChunk() {\n            var start = Math.min(this.startByte, this.endByte);\n            var end = Math.min(this.startByte + this.chunkSize, this.endByte);\n            this.reader.readAsText(this.dataFile.slice(start, end));\n        }\n\n        /**\r\n         * Reads more 1000 bytes to finish the last line of the worker.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'readLastLine',\n        value: function readLastLine() {\n            if (this.lastWorkerRow.length === 0) return true;\n            var start = Math.min(this.startByte, this.endByte);\n            var end = this.endByte + 1000;\n            this.reader.readAsText(this.dataFile.slice(start, end));\n        }\n\n        /**\r\n         * Called after a chunk is read from the file.\r\n         * @param {ProgressEvent} e - Event associated with the read data.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'chunkReadFromFile',\n        value: function chunkReadFromFile(e) {\n            if (this.isLastLine) {\n                // console.warn(\"last line\", this.workerIndex, e.target.result);\n                var rows = (this.lastWorkerRow + e.target.result).split(this.rowDelimiter);\n                // console.warn(this.workerIndex, rows);\n                this.processRows(rows, 0, 1);\n                this.sendENDStartMessage();\n            } else {\n                this.startByte += this.chunkSize;\n                this.processChunk(e.target.result);\n                if (this.startByte >= this.endByte) {\n                    // console.log(\"END\");\n                    // console.log(\"NumRows Worker\", this.workerIndex, \"is:\", this.numRowsRead, \"\\nFIRSTROW = \", this.firstWorkerRow, \"\\nLASTROW = \", this.lastWorkerRow);\n                    //Post message with first and last row\n                    // console.warn(\"worker Terminated\", this.workerIndex, this.firstWorkerRow, this.lastWorkerRow);\n                    this.isLastLine = true;\n                    var isDone = this.readLastLine();\n                    if (isDone) //Only the ones that returned true from the readLastLine() method will send back to the \n                        this.sendENDStartMessage();\n                } else this.readNextChunk();\n            }\n        }\n    }, {\n        key: 'sendENDStartMessage',\n        value: function sendENDStartMessage() {\n            console.warn(\"END\", this.workerIndex, this.dataRowsSaved.length);\n            worker.postMessage({\n                protocolMessage: _GisplayDefaults.GisplayDefaults.MESSAGES_CSV().END_START,\n                messageData: {\n                    workerIndex: this.workerIndex\n                    // firstWorkerRow: this.firstWorkerRow,\n                    // lastWorkerRow: this.lastWorkerRow\n                }\n            });\n        }\n\n        /**\r\n         * Process the chunk that was read from the file.\r\n         * @see https://developer.mozilla.org/pt-PT/docs/Web/JavaScript/Reference/Global_Objects/String/split\r\n         * @see https://image.prntscr.com/image/BkaRp8qSQuyt9phoSh71ZA.png\r\n         * @see https://image.prntscr.com/image/FAQ8CVH9S1W6X0RoZrOWfw.png - Edge case for \\r\\n.\r\n         * @see https://image.prntscr.com/image/yYXWcZwLQjSNYqIiuQEcKQ.png - Edge case example.\r\n         * @param {any} chunkText  - The text read from the file.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'processChunk',\n        value: function processChunk(chunkText) {\n            var rows = (this.remainingChunkRow + chunkText).split(this.rowDelimiter); //May not have the best performance (has to create new string due to string immutability). Could be changed but solution has to solve the EDGE CASE.\n            this.remainingChunkRow = rows[rows.length - 1];\n            var startRowIndex = 0,\n                endRowIndex = rows.length - 1; //The index to start and end the rows processing\n\n            if (!this.firstWorkerRow) {\n                //Save 1st row of this worker \n                this.firstWorkerRow = rows[0];\n                startRowIndex = 1; //Ignore first row of first chunk in any worker\n            }\n            if (!this.lastWorkerRow && this.startByte >= this.endByte) {\n                // console.log(this.workerIndex, this.lastWorkerRow);\n                this.lastWorkerRow = this.remainingChunkRow; //Save last row if it's the last chunk (See split image) \n                // console.log(this.workerIndex, rows, this.dataRowsSaved, this.firstWorkerRow, this.lastWorkerRow);\n\n                // console.error(this.workerIndex, this.remainingChunkRow);\n            }\n            this.processRows(rows, startRowIndex, endRowIndex);\n        }\n\n        /**\r\n         * Process the rows that are in the rows array. The first row of the 1st chunk read from the file should be ignored.\r\n         * @param {Array<string>} rows - The rows, each one in a position of the array. \r\n         * @param {number} startRowIndex - The row to start processing.\r\n         * @param {number} endRowIndex - The last row to process.\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'processRows',\n        value: function processRows(rows, startRowIndex, endRowIndex) {\n            var resRows = [];\n            // this.numRowsRead += (endRowIndex - startRowIndex); //DELETE\n            var categoricalIndices = this.headerIndices[0];\n            var continuousIndices = this.headerIndices[1];\n            var geometryIndices = this.headerIndices[2];\n            var hasIdGeometry = false;\n            if (+geometryIndices === +geometryIndices) {\n                geometryIndices = [geometryIndices];\n                hasIdGeometry = true;\n            }\n            var timeIndex = this.headerIndices[3];\n            var hasTime = this.timeGranularity !== ''; //OR this.timeVariable !== undefined\n            var optinalIndices = this.headerIndices[4];\n            for (var i = startRowIndex; i < endRowIndex; i++) {\n                this.numRowsRead++;\n                var columns = rows[i].split(this.columnDelimiter);\n                /* if (columns.length !== this.numColumnsPerRow) //Check for errors\r\n                    throw new Error(\"Wrong number of columns\");\r\n                 */\n                var row = [];\n\n                var _iteratorNormalCompletion14 = true;\n                var _didIteratorError14 = false;\n                var _iteratorError14 = undefined;\n\n                try {\n                    for (var _iterator14 = categoricalIndices.entries()[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                        var _step14$value = _slicedToArray(_step14.value, 2),\n                            _i9 = _step14$value[0],\n                            catIndex = _step14$value[1];\n\n                        var category = columns[catIndex];\n                        if (this.categoricalVariables[_i9].classCalculationRequired()) this.categoricalVariables[_i9].addCategory(category);\n                        row.push(category);\n                    }\n                } catch (err) {\n                    _didIteratorError14 = true;\n                    _iteratorError14 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion14 && _iterator14.return) {\n                            _iterator14.return();\n                        }\n                    } finally {\n                        if (_didIteratorError14) {\n                            throw _iteratorError14;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion15 = true;\n                var _didIteratorError15 = false;\n                var _iteratorError15 = undefined;\n\n                try {\n                    for (var _iterator15 = continuousIndices.entries()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                        var _step15$value = _slicedToArray(_step15.value, 2),\n                            _i10 = _step15$value[0],\n                            contIndex = _step15$value[1];\n\n                        var value = +columns[contIndex];\n                        /* if (value >= 80000.10)\r\n                            console.warn(\"WUUUT\"); */\n                        this.continuousVariables[_i10].setMinMax(value);\n                        row.push(value); //String to number\n                    }\n                } catch (err) {\n                    _didIteratorError15 = true;\n                    _iteratorError15 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion15 && _iterator15.return) {\n                            _iterator15.return();\n                        }\n                    } finally {\n                        if (_didIteratorError15) {\n                            throw _iteratorError15;\n                        }\n                    }\n                }\n\n                var _iteratorNormalCompletion16 = true;\n                var _didIteratorError16 = false;\n                var _iteratorError16 = undefined;\n\n                try {\n                    for (var _iterator16 = geometryIndices[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                        var geoIndex = _step16.value;\n\n                        if (hasIdGeometry) {\n                            var _value = columns[geoIndex];\n                            if (+_value === +_value) row.push(+_value);else row.push(_value.toUpperCase());\n                        } else row.push(+columns[geoIndex]);\n                    }\n                } catch (err) {\n                    _didIteratorError16 = true;\n                    _iteratorError16 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion16 && _iterator16.return) {\n                            _iterator16.return();\n                        }\n                    } finally {\n                        if (_didIteratorError16) {\n                            throw _iteratorError16;\n                        }\n                    }\n                }\n\n                if (hasTime) {\n                    var granule = this.getGranule(columns[timeIndex]);\n                    this.timeVariable.addTemporalGranule(granule);\n                    this.timeVariable.addTemporalGranuleToSet(granule);\n                    row.push(granule);\n                }\n\n                var _iteratorNormalCompletion17 = true;\n                var _didIteratorError17 = false;\n                var _iteratorError17 = undefined;\n\n                try {\n                    for (var _iterator17 = optinalIndices[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                        var optionalIndex = _step17.value;\n\n                        if (+columns[optionalIndex] === +columns[optionalIndex]) //It's a number?\n                            row.push(+columns[optionalIndex]);else row.push(columns[optionalIndex]);\n                    }\n                    // resRows.push(row);\n                } catch (err) {\n                    _didIteratorError17 = true;\n                    _iteratorError17 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion17 && _iterator17.return) {\n                            _iterator17.return();\n                        }\n                    } finally {\n                        if (_didIteratorError17) {\n                            throw _iteratorError17;\n                        }\n                    }\n                }\n\n                this.dataRowsSaved.push(row);\n            }\n            // console.log(this.workerIndex, this.dataRowsSaved.length);\n        }\n\n        /**\r\n         * TODO: DELETE AND Replace with GisplayDefaults.getGranule(timeString)\r\n         * Convert the time string to the granularity we want.\r\n         * @param {string} timeString - The time as it was read from the file. \r\n         * @returns {number} - The granul\r\n         * @memberof CSVDataWorker\r\n         */\n\n    }, {\n        key: 'getGranule',\n        value: function getGranule(timeString) {\n            var value = void 0;\n            // console.warn(timeString, this.timeGranularity);\n            /*\r\n            //if cyclic then ...\r\n            day of year -> dayOfYear (n temos )\r\n            month of year -> monthOfYear (temos)\r\n            day of month -> dayOfMonth (temos)\r\n            hour of day -> hourOfDay (temos)\r\n            minute of hour -> minuteOfHour (temos)\r\n            \r\n            //else continuous\r\n            year -> 2015, 2016 ...\r\n            month -> 2015_01, 2015_02 ... 2016_01 etc\r\n            day -> 2015_01_01, 2015_01_02 ...\r\n            hour -> 2015_01_01_01, 2015_01_01_01 ...\r\n            minute\r\n            value\r\n            */\n\n            switch (this.timeGranularity) {\n                //CYCLIC\n                case 'monthOfYear':\n                    //Mes do ano\n                    value = new Date(timeString).getMonth() + 1; //GOOD\n                    break;\n                case 'dayOfYear':\n                    value = -1; //CHANGE to calculate day of year\n                    break;\n                case 'dayOfMonth':\n                    value = new Date(timeString).getDate(); //GOOD\n                    break;\n                case 'hourOfDay':\n                    value = new Date(timeString).getHours(); //GOOD\n                    break;\n                case 'minuteOfHour':\n                    value = new Date(timeString).getMinutes(); //GOOD\n                    break;\n\n                //CONTINUOUS\n                case 'year':\n                    value = new Date(timeString).getFullYear();\n                    break;\n                case 'month':\n                    //Mes do ano\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1);\n                    break;\n                case 'day':\n                    value = new Date(timeString).getFullYear() + \"_\" + (new Date(timeString).getMonth() + 1) + \"_\" + new Date(timeString).getDate();\n                    // value = Number(new Date(timeString).getFullYear() + \"\" + new Date(timeString).getMonth() + \"\" + new Date(timeString).getDay());\n                    break;\n                case 'value':\n                    value = +timeString;\n                    break;\n            }\n            // console.log(value);\n            return value;\n        }\n    }]);\n\n    return CSVDataWorker;\n}();\n\nnew CSVDataWorker();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9QYXJzZXIvQ1NWL0NTVkRhdGFXb3JrZXIuanM/N2FjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgd29ya2VyID0gc2VsZjtcclxuXHJcbmltcG9ydCB7IERhdGFWYXJpYWJsZSB9IGZyb20gJy4uLy4uL1ZWcy9EYXRhVmFyaWFibGUnO1xyXG5pbXBvcnQgeyBVUkxWYXJpYWJsZSB9IGZyb20gJy4uLy4uL1ZWcy9VUkxWYXJpYWJsZSc7XHJcbmltcG9ydCB7IFRpbWVWYXJpYWJsZSB9IGZyb20gJy4uLy4uL1ZWcy9UaW1lVmFyaWFibGUnO1xyXG5pbXBvcnQgeyBDYXRlZ29yaWNhbFZhcmlhYmxlIH0gZnJvbSAnLi4vLi4vVlZzL0NhdGVnb3JpY2FsVmFyaWFibGUnO1xyXG5pbXBvcnQgeyBDb250aW51b3VzVmFyaWFibGUgfSBmcm9tICcuLi8uLi9WVnMvQ29udGludW91c1ZhcmlhYmxlJztcclxuaW1wb3J0IHsgR2lzcGxheURlZmF1bHRzIH0gZnJvbSAnLi4vLi4vR2lzcGxheURlZmF1bHRzJztcclxuXHJcbmNsYXNzIENTVkRhdGFXb3JrZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLS0tQ1NWIERhdGEgV29ya2VyLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZmlyc3Qgcm93IHJlYWQgYnkgdGhpcyBkYXRhIHdvcmtlci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlyc3RXb3JrZXJSb3cgPSAnJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCByb3cgb2YgdGhlIGxhc3QgY2h1bmsgcmVhZCBieSB0aGUgcGFyc2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0V29ya2VyUm93ID0gJyc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2F2ZSB0aGUgcmVtYWluaW5nIG9mIHRoZSBsYXN0IHJvdyBmcm9tIHRoZSBjaHVuayB0aGF0IHdhcyByZWFkLlxyXG4gICAgICAgICAqIEl0J3MgdXNlZCB3aGVuIGEgY2h1bmsgZGlkbid0IGVuZCBpbiBhIHJvdyBkZWxpbWl0aXIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZW1haW5pbmdDaHVua1JvdyA9ICcnO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGF0YSBmaWxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtGaWxlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YUZpbGUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdGFydCBieXRlIGZvciB0aGlzIHdvcmtlci5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRCeXRlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZW5kIGJ5dGUgZm9yIHRoaXMgd29ya2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmRCeXRlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiBlYWNoIGNodW5rIHRvIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2h1bmtTaXplID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhpcyB3b3JrZXIuIERFTEVURT9cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud29ya2VySW5kZXggPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgY29sdW1ucyBmb3IgZWFjaCByb3cuIERFTEVURT9cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubnVtQ29sdW1uc1BlclJvdyA9IC0xOyAvL05PVCBVU0VEIEFUTVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcm93IGRlbGltaXRlci5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucm93RGVsaW1pdGVyID0gJyc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbHVtbiBkZWxpbWl0ZXIuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbHVtbkRlbGltaXRlciA9ICcnO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGVhZGVyIGluZGljZXMuIFxyXG4gICAgICAgICAqIFRoZSBhcnJheSBpcyBzcGxpdCBpbnRvIDUgcG9zaXRpb25zOiBbMF1jYXRlZ29yaWNhbCwgWzFdY29udGludW91cywgWzJdZ2VvbWV0cnksIFszXXRpbWUgYW5kIFs0XW9wdGlvbmFsIHZhcmlhYmxlcy4gXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGVhZGVySW5kaWNlcyA9IFtdO1xyXG5cclxuICAgICAgICAvL1RJTUUgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRpbWUgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHR5cGUge1RpbWVWYXJpYWJsZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpbWVWYXJpYWJsZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGdyYW51bGFyaXR5IG9mIHRoZSB0aW1lIHZhcmlhYmxlLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50aW1lR3JhbnVsYXJpdHkgPSAnJztcclxuXHJcbiAgICAgICAgLy9DQVRFR09SSUNBTFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjYXRlZ29yaWNhbCB2YXJpYWJsZXMgcHJlc2VudCBpbiB0aGUgdXNlciBvcHRpb25zLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxDYXRlZ29yaWNhbFZhcmlhYmxlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIG9wdGlvbnMgY29udGFpbiBhbnkgY2F0ZWdvcmljYWwgdmFyaWFibGUuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYXNDYXRlZ29yaWNhbFZhcmlhYmxlcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvL0NPTlRJTlVPVVNcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29udGludW91cyB2YXJpYWJsZXMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PENvbnRpbnVvdXNWYXJpYWJsZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250aW51b3VzVmFyaWFibGVzID0gW107XHJcblxyXG4gICAgICAgIC8vT1BUSU9OQUxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwgdmFyaWFibGVzLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxEYXRhVmFyaWFibGU+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWxWYXJpYWJsZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIEZpbGVSZWFkZXIgdXNlZCB0byByZWFkIGEgcG9ydGlvbiBvZiB0aGUgZmlsZS5cclxuICAgICAgICAgKiBAdHlwZSB7RmlsZVJlYWRlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlYWRlciA9IHRoaXMuY3JlYXRlRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4geyB0aGlzLm9uTWVzc2FnZShlLmRhdGEpOyB9O1xyXG5cclxuICAgICAgICAvL1NBVkUgSU5GT1JNQVRJT05cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIHRvIHNhdmUgdGhlIHJvd3MgZGlyZWN0bHkgcmVhZCBmcm9tIHRoZSBmaWxlXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEFycmF5PHN0cmluZ3xudW1iZXI+Pn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRhdGFSb3dzU2F2ZWQgPSBbXTsgLy9TYXZlIHJvd3MgcmVhZCBieSB0aGlzIFdvcmtlclxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmaW5hbCBkYXRhIHJvd3Mgd2hpY2ggY29udGFpbiBhbGwgaW5mb3JtYXRpb24gdG8gYmUgc2VudCB0byB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEFycmF5PHtjb250aW51b3VzRGF0YTogQXJyYXk8QXJyYXk8bnVtYmVyPj4sIHNwYXRpYWxEYXRhOiBBcnJheTxudW1iZXI+LG9wdGlvbmFsRGF0YTogQXJyYXk8QXJyYXk8bnVtYmVyfHN0cmluZz4+LCBSR0JBOiBBcnJheTxudW1iZXI+LCBudW1iZXJSR0JBOiBBcnJheTxudW1iZXI+fT4+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmluYWxEYXRhUm93cyA9IFtdO1xyXG4gICAgICAgIC8vIHRoaXMubnVtUm93c1JlYWQgPSAwO1xyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogV2lsbCBiZSB0cnVlIHdoZW4gd2Ugd2FudCB0byBwcm9jZXNzIHRoZSBsYXN0IGxpbmUuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc0xhc3RMaW5lID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgZmlsZSByZWFkZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7RmlsZVJlYWRlcn0gLSB0aGUgRmlsZVJlYWRlciB1c2VkIHRvIHJlYWQgYSBwb3J0aW9uIG9mIHRoZSBmaWxlLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgY3JlYXRlRmlsZVJlYWRlcigpIHtcclxuICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHsgdGhpcy5jaHVua1JlYWRGcm9tRmlsZShlKTsgfTtcclxuICAgICAgICByZWFkZXIub25lcnJvciA9IChlKSA9PiB7IGNvbnNvbGUuZXJyb3IoZSk7IH07XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdGhlIHdvcmtlciByZWNlaXZlcyBhIG1lc3NhZ2UuIFxyXG4gICAgICogQHBhcmFtIHt7cHJvdG9jb2xNZXNzYWdlOiBzdHJpbmcsIG1lc3NhZ2VEYXRhOk9iamVjdH19IGRhdGFNZXNzYWdlIC0gVGhlIGRhdGEgbWVzc2FnZSB0aGF0IHdhcyBzZW50IGJ5IHRoZSBtYWluIFRocmVhZC5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIG9uTWVzc2FnZShkYXRhTWVzc2FnZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiLS0tLS0tLS0tLS0tLS0tLS0tLUNTViBEYXRhIFdvcmtlci0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YU1lc3NhZ2UpO1xyXG4gICAgICAgIGxldCBwcm90b2NvbE1lc3NhZ2VzID0gR2lzcGxheURlZmF1bHRzLk1FU1NBR0VTX0NTVigpO1xyXG4gICAgICAgIHN3aXRjaCAoZGF0YU1lc3NhZ2UucHJvdG9jb2xNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xNZXNzYWdlcy5UT19TVEFSVDogeyAvL1dvcmtlciBwcm9jZXNzZWQgaXQncyBwYXJ0XHJcbiAgICAgICAgICAgICAgICAvL0ZpbGUgYW5kIGNodW5rIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICBsZXQgd29ya2VyT3B0aW9ucyA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLndvcmtlck9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFGaWxlID0gd29ya2VyT3B0aW9ucy5kYXRhRmlsZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRCeXRlID0gd29ya2VyT3B0aW9ucy5zdGFydEJ5dGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZEJ5dGUgPSB3b3JrZXJPcHRpb25zLmVuZEJ5dGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IHdvcmtlck9wdGlvbnMuY2h1bmtTaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53b3JrZXJJbmRleCA9IHdvcmtlck9wdGlvbnMud29ya2VySW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm51bUNvbHVtbnNQZXJSb3cgPSB3b3JrZXJPcHRpb25zLm51bUNvbHVtbnNQZXJSb3c7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0RlbGltaXRlciA9IHdvcmtlck9wdGlvbnMucm93RGVsaW1pdGVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EZWxpbWl0ZXIgPSB3b3JrZXJPcHRpb25zLmNvbHVtbkRlbGltaXRlcjtcclxuICAgICAgICAgICAgICAgIC8vSW5kaWNlcyBhbmQgY2xhc3MgY2FsY1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJJbmRpY2VzID0gd29ya2VyT3B0aW9ucy5oZWFkZXJJbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgLy9TYXZlIENhdGVnb3JpY2FsL0NvbnRpbnVvdXMgYW5kIHRpbWUgVmFyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhcmlhYmxlcyhkYXRhTWVzc2FnZS5tZXNzYWdlRGF0YS53b3JrZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIC8vU3RhcnQgcmVhZGluZyBmaWxlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWROZXh0Q2h1bmsoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xNZXNzYWdlcy5UT19MSU1JVFNfQ0FUOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPX0xJTUlUX0NBVFwiKVxyXG4gICAgICAgICAgICAgICAgbGV0IGNhdFZhcnNDYXRlZ29yaWVzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYXRWYXIgb2YgdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlcylcclxuICAgICAgICAgICAgICAgICAgICBjYXRWYXJzQ2F0ZWdvcmllc01hcC5zZXQoY2F0VmFyLmdldEludGVybmFsTmFtZSgpLCBjYXRWYXIuZ2V0Q2F0ZWdvcmllcygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY29udFZhcnNNaW5NYXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRWYXIgb2YgdGhpcy5jb250aW51b3VzVmFyaWFibGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRWYXJzTWluTWF4TWFwLnNldChjb250VmFyLmdldEludGVybmFsTmFtZSgpLCBbY29udFZhci5nZXRNaW4oKSwgY29udFZhci5nZXRNYXgoKV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMud29ya2VySW5kZXgsIGNhdFZhcnNDYXRlZ29yaWVzTWFwLCBjb250VmFyc01pbk1heE1hcCwgdGhpcy50aW1lVmFyaWFibGUsIHRoaXMudGltZVZhcmlhYmxlLmdldFRlbXBvcmFsR3JhbnVsZXNTZXQoKSlcclxuXHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZTogcHJvdG9jb2xNZXNzYWdlcy5FTkRfTElNSVRTX0NBVCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWNhbFZhcmlhYmxlczogY2F0VmFyc0NhdGVnb3JpZXNNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbm91c1ZhcmlhYmxlczogY29udFZhcnNNaW5NYXhNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVWYXJpYWJsZTogdGhpcy50aW1lVmFyaWFibGUgPyB0aGlzLnRpbWVWYXJpYWJsZS5nZXRUZW1wb3JhbEdyYW51bGVzU2V0KCkgOiB0aGlzLnRpbWVWYXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBwcm90b2NvbE1lc3NhZ2VzLlRPX0xJTUlUU19DQVRfUkVTOiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udGlub3VzVmFyc01pbk1heCA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2ksIGNvbnRWYXJdIG9mIHRoaXMuY29udGludW91c1ZhcmlhYmxlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250VmFyLnNldE1pbk1heChjb250aW5vdXNWYXJzTWluTWF4W2ldWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250VmFyLnNldE1pbk1heChjb250aW5vdXNWYXJzTWluTWF4W2ldWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250VmFyLnNldFN0ZXAoKTsgLy9VcGRhdGUgc3RlcCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vTG9vcCB0aHJvdWdoIGRhdGEgYW5kIGNhbGN1bGF0ZSBiaW5zIGZvciBlYWNoIGNvbnRpbnVvdXMgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIGxldCBjb250UG9zU3RhcnQgPSB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxldCBjb250UG9zRW5kID0gY29udFBvc1N0YXJ0ICsgdGhpcy5jb250aW51b3VzVmFyaWFibGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGRhdGEgb2YgdGhpcy5kYXRhUm93c1NhdmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb250UG9zU3RhcnQ7IGkgPCBjb250UG9zRW5kOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludW91c1ZhcmlhYmxlc1tpIC0gY29udFBvc1N0YXJ0XS5hZGRWYWx1ZVRvQmlucyhkYXRhW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaGlzdG9ncmFtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250VmFyIG9mIHRoaXMuY29udGludW91c1ZhcmlhYmxlcylcclxuICAgICAgICAgICAgICAgICAgICBoaXN0b2dyYW1zLnB1c2goY29udFZhci5nZXRIaXN0b2dyYW0oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb250aW51b3VzVmFyaWFibGVzWzBdLmdldEhpc3RvZ3JhbSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZTogcHJvdG9jb2xNZXNzYWdlcy5FTkRfTElNSVRTX0NBVF9SRVMsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9ncmFtczogaGlzdG9ncmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBwcm90b2NvbE1lc3NhZ2VzLlRPX0pPSU5fREFUQToge1xyXG4gICAgICAgICAgICAgICAgLy9Qcm9jZXNzIGRhdGEgYW5kIHRoZW4gc2VuZCB0aGUgcmVzIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLndvcmtlckluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJIHdpbGwgcHJvY2VzcyB0aGUgZGF0YS4uLi5OT1RcIilcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhTWVzc2FnZS5tZXNzYWdlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNhdFZhcnMgPSBkYXRhTWVzc2FnZS5tZXNzYWdlRGF0YS5jYXRlZ29yaWNhbFZhcmlhYmxlcztcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ksIGNhdFZhcl0gb2YgY2F0VmFycy5lbnRyaWVzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlc1tpXS52YWx1ZVRvSW5kZXhNYXAgPSBjYXRWYXIudmFsdWVUb0luZGV4TWFwO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBjb250VmFycyA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLmNvbnRpbnVvdXNWYXJpYWJsZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCBjb250VmFyXSBvZiBjb250VmFycy5lbnRyaWVzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51b3VzVmFyaWFibGVzW2ldLmNsYXNzSW50ZXJ2YWxzID0gY29udFZhci5jbGFzc0ludGVydmFscztcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdFZhciA9IGRhdGFNZXNzYWdlLm1lc3NhZ2VEYXRhLnRpbWVWYXJpYWJsZTtcclxuICAgICAgICAgICAgICAgIGlmICh0VmFyKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVZhcmlhYmxlLnRlbXBvcmFsR3JhbnVsZXNNYXAgPSB0VmFyLnRlbXBvcmFsR3JhbnVsZXNNYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IG1zZ0RhdGEgPSBkYXRhTWVzc2FnZS5tZXNzYWdlRGF0YTtcclxuICAgICAgICAgICAgICAgIGxldCBtdmNzID0gbXNnRGF0YS5tdmNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck1WQ3MgPSBtdmNzLnNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyVEdzID0gbXNnRGF0YS5udW1iZXJUR3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9qb2luRGF0YShtdmNzLCBudW1iZXJUR3MpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtVG90YWxFbGVtZW50cyA9IDA7IC8vQ3JlYXRlIGFycmF5IHRvIHNlbmQgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyB3b3JrZXJcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5maW5hbERhdGFSb3dzKTtcclxuICAgICAgICAgICAgICAgIC8qICAgIGlmICh0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyTVZDczsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bWJlclRHczsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVG90YWxFbGVtZW50cyArPSB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0uY29udGludW91c0RhdGFbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJcIik7ICovXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck1WQ3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyVEdzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVySW5kaWNlc1syXS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Ub3RhbEVsZW1lbnRzICs9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5zcGF0aWFsRGF0YS5sZW5ndGggLyAyOyAvL0xhdC9MbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVG90YWxFbGVtZW50cyArPSB0aGlzLmZpbmFsRGF0YVJvd3NbaV1bal0uc3BhdGlhbERhdGEubGVuZ3RoOyAvL0lkc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihudW1Ub3RhbEVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZTogcHJvdG9jb2xNZXNzYWdlcy5FTkRfSk9JTl9EQVRBLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRvdGFsRWxlbWVudHM6IG51bVRvdGFsRWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlckluZGV4OiB0aGlzLndvcmtlckluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHByb3RvY29sTWVzc2FnZXMuVE9fR0VORVJBVEVfUkdCQToge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIEdlbmVyYXRlIFJHQkFzIGZvciBhbGwgTVZDcy9UR3MgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVJHQkFDb2RlcyhkYXRhTWVzc2FnZS5tZXNzYWdlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBwcm90b2NvbE1lc3NhZ2U6IHByb3RvY29sTWVzc2FnZXMuRU5EX0dFTkVSQVRFX1JHQkEgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIHByb3RvY29sTWVzc2FnZXMuVE9fU0VORF9EQVRBOiB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sTWVzc2FnZTogcHJvdG9jb2xNZXNzYWdlcy5FTkRfU0VORF9EQVRBLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YVJvd3M6IHRoaXMuZmluYWxEYXRhUm93c1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBSR0JBIGNvZGVzIGZvciBlYWNoIGVsZW1lbnQgaW4gZWFjaCBNVkMvVEcuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj59IHN0YXJ0UkdCQU51bSAtIFRoZSBzdGFydCBSR0JBIG51bWJlciBmb3IgdGhpcyB3b3JrZXIuLiBcclxuICAgICAqIEBtZW1iZXJvZiBDU1ZOZXdEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIF9nZW5lcmF0ZVJHQkFDb2RlcyhzdGFydFJHQkFOdW0pIHtcclxuICAgICAgICBsZXQgbnVtTVZDcyA9IHRoaXMuZmluYWxEYXRhUm93cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIG51bVRHcyA9IHRoaXMuZmluYWxEYXRhUm93c1swXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NVkNzOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gbGV0IHN0YXJ0UkdCQSA9IHN0YXJ0aW5nUkdCQU51bWJlcltpXSxcclxuICAgICAgICAgICAgLy8gbGV0IHN0YXJ0UkdCQU51bSA9IEdpc3BsYXlEZWZhdWx0cy5SR0JBVG9OdW1iZXIoLi4uc3RhcnRSR0JBKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1UR3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bWJlck9mRWxlbWVudHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVySW5kaWNlc1syXS5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZFbGVtZW50cyA9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5zcGF0aWFsRGF0YS5sZW5ndGggLyAyOyAvL0xhdC9MbmdcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkVsZW1lbnRzID0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLnNwYXRpYWxEYXRhLmxlbmd0aDsgLy9JZHNcclxuICAgICAgICAgICAgICAgIC8vIGxldCBjb250aW51b3VzRGF0YUxlbmd0aCA9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5jb250aW51b3VzRGF0YVswXS5sZW5ndGg7IC8vVXNpbmcgY29udGludW91cyBkYXRhIHRoYXQgbWlnaHQgbm90IGV4aXN0XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyT2ZFbGVtZW50cyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG51bWJlck9mRWxlbWVudHM7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgUkdCQSA9IEdpc3BsYXlEZWZhdWx0cy5udW1iZXJUb1JHQkEoc3RhcnRSR0JBTnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLlJHQkEucHVzaCguLi5SR0JBKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLm51bWJlclJHQkEucHVzaChzdGFydFJHQkFOdW0rKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmVyaWZ5SW50ZWdyaXR5UkdCQShudW1NVkNzLCBudW1UR3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHZlcmlmeUludGVncml0eVJHQkEobnVtTVZDcywgbnVtVEdzKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS53YXJuKFwiVkVSSUZZIElOVEVHUklUWVwiKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTVZDczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtVEdzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250aW51b3VzRGF0YUxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJJbmRpY2VzWzJdLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzRGF0YUxlbmd0aCA9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5zcGF0aWFsRGF0YS5sZW5ndGggLyAyOyAvL0xhdC9MbmdcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzRGF0YUxlbmd0aCA9IHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5zcGF0aWFsRGF0YS5sZW5ndGg7IC8vSWRzXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGludW91c0RhdGFMZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY29udGludW91c0RhdGFMZW5ndGggLSAxOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuZmluYWxEYXRhUm93c1tpXVtqXS5udW1iZXJSR0JBW2tdICsgMSA9PT0gdGhpcy5maW5hbERhdGFSb3dzW2ldW2pdLm51bWJlclJHQkFbayArIDFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEpvaW4gdGhlIGRhdGEgaW50byBNVkNzIGFuZCBUR3MuXHJcbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIG51bWJlcj59IG12Y3MgLSBUaGUgZ2VuZXJhdGVkIE1WQ3MgbWFwIGFuZCByZXNwZWN0aXZlIGluZGV4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclRHcyAtIFRoZSBudW1iZXIgb2YgdGVtcG9yYWwgZ3JhbnVsZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWTmV3RGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICBfam9pbkRhdGEobXZjcywgbnVtYmVyVEdzKSB7XHJcbiAgICAgICAgLy9Mb29wIHRocm91Z2ggcm93cyBhbmQgY29weSB0aGVtIHRvIHRoZSBmaW5hbCBhcnJheVxyXG4gICAgICAgIC8vY2F0ZWdvcmljYWwgdmFycyBhbmQgdGltZSB2YXIgY2FuIGJlIGlnbm9yZWQgKHRoZXkgYXJlIGtub3duIGJ5IHRoZSBhcnJheXMgaW5kaWNlcylcclxuICAgICAgICAvL1NhdmUgY29udCB2YXJzLCBnZW9tZXRyeSwgb3B0IHZhcnMgYW5kIFJHQkEgdmFsdWVcclxuXHJcbiAgICAgICAgbGV0IGhhc0lkcyA9IHRoaXMuaGVhZGVySW5kaWNlc1syXS5sZW5ndGggPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgbGV0IGdlb1Bvc2l0aW9ucyA9IGhhc0lkcyA/IDEgOiAyO1xyXG5cclxuICAgICAgICAvLyBjb25zb2xlLndhcm4odGhpcy50aW1lVmFyaWFibGUsIG12Y3MpO1xyXG4gICAgICAgIGxldCBudW1iZXJNVkNzID0gbXZjcy5zaXplLFxyXG4gICAgICAgICAgICBudW1DYXRWYXJzID0gdGhpcy5jYXRlZ29yaWNhbFZhcmlhYmxlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIG51bUNvbnRWYXJzID0gdGhpcy5jb250aW51b3VzVmFyaWFibGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgZ2VvU3RhcnRQb3MgPSBudW1DYXRWYXJzICsgbnVtQ29udFZhcnMsXHJcbiAgICAgICAgICAgIGdlb0VuZFBvcyA9IGdlb1N0YXJ0UG9zICsgZ2VvUG9zaXRpb25zLFxyXG4gICAgICAgICAgICB0aW1lUG9zID0gZ2VvRW5kUG9zO1xyXG5cclxuICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3MgPSB0aGlzLl9jcmVhdGVGaW5hbFJvd3MobnVtYmVyTVZDcywgbnVtYmVyVEdzKTtcclxuICAgICAgICAvL0ZvciBlYWNoIHJvdyBzYXZlZCB0aGVuIHNwbGl0IGl0IHRvIGl0cyBwbGFjZVxyXG4gICAgICAgIGZvciAoY29uc3Qgcm93U2F2ZWQgb2YgdGhpcy5kYXRhUm93c1NhdmVkKSB7XHJcbiAgICAgICAgICAgIGxldCBmaW5hbFJvdyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgY29tYmluYXRpb24gPSAnJztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IFtpLCBjYXRWYXJdIG9mIHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMuZW50cmllcygpKVxyXG4gICAgICAgICAgICAgICAgY29tYmluYXRpb24gKz0gY2F0VmFyLmZpbmRJbmRleChyb3dTYXZlZFtpXSk7XHJcbiAgICAgICAgICAgIGxldCBjb250VmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IFtqLCBjb250VmFyXSBvZiB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udFZhbHVlID0gcm93U2F2ZWRbaiArIG51bUNhdFZhcnNdO1xyXG4gICAgICAgICAgICAgICAgY29tYmluYXRpb24gKz0gY29udFZhci5maW5kQ2xhc3NJbnRlcnZhbEluZGV4KGNvbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb250VmFsdWVzLnB1c2goY29udFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IG12Y0luZGV4ID0gbXZjcy5nZXQoY29tYmluYXRpb24pO1xyXG4gICAgICAgICAgICBsZXQgdGdJbmRleCA9IHRoaXMudGltZVZhcmlhYmxlICE9PSB1bmRlZmluZWQgPyB0aGlzLnRpbWVWYXJpYWJsZS5nZXRUR01hcEluZGV4KHJvd1NhdmVkW3RpbWVQb3NdKSA6IDA7XHJcbiAgICAgICAgICAgIGlmICh0Z0luZGV4ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSEVSRVwiKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRWYWx1ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbbXZjSW5kZXhdW3RnSW5kZXhdLmNvbnRpbnVvdXNEYXRhW2ldLnB1c2goY29udFZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBnZW9TdGFydFBvczsgaSA8IGdlb0VuZFBvczsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbERhdGFSb3dzW212Y0luZGV4XVt0Z0luZGV4XS5zcGF0aWFsRGF0YS5wdXNoKHJvd1NhdmVkW2ldKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRpbWVQb3MgKyAxOyBpIDwgcm93U2F2ZWQubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsRGF0YVJvd3NbbXZjSW5kZXhdW3RnSW5kZXhdLm9wdGlvbmFsRGF0YVtpIC0gdGltZVBvcyAtIDFdLnB1c2gocm93U2F2ZWRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGFSb3dzU2F2ZWQgPSB1bmRlZmluZWQ7IC8vQWxsb3dzIEdhcmJhZ2UgY29sbGVjdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoZSBmaW5hbCByb3cgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb24gdGhhdCB0aGUgd29ya2VyIHNob3VsZCBzZW5kIGF0IHRoZSBlbmQgdG8gdGhlIG1haW4gdGhyZWFkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck1WQ3MgLSBOdW1iZXIgb2YgZXhpc3RpbmcgbWFwIHZhcmlhYmxlIGNvbWJpbmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJUR3MgLSBOdW1iZXIgb2YgZXhpc3RpbmcgdGVtcG9yYWwgZ3JhbnVsZXMgLiBcclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxhbnk+fSAtIHRoZSBmaW5hbCByb3cgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb24gdGhhdCB0aGUgd29ya2VyIHNob3VsZCBzZW5kIGF0IHRoZSBlbmQgdG8gdGhlIG1haW4gdGhyZWFkLlxyXG4gICAgICogQG1lbWJlcm9mIENTVk5ld0RhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgX2NyZWF0ZUZpbmFsUm93cyhudW1iZXJNVkNzLCBudW1iZXJUR3MpIHtcclxuICAgICAgICBsZXQgZmluYWxSb3dzID0gW107XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlIGFycmF5cyBmb3Igb3B0aW9uYWxEYXRhXHJcbiAgICAgICAgbGV0IG9wdGlvbmFsRGF0YUFycmF5cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25hbFZhcmlhYmxlcy5sZW5ndGg7IGkrKykgLy9DcmVhdGUgbXVsdGlwbGUgYXJyYXlzIG9uZSBmb3IgZWFjaCBvcHRpb25hbCB2YXJpYWJsZVxyXG4gICAgICAgICAgICBvcHRpb25hbERhdGFBcnJheXNbaV0gPSBbXTtcclxuXHJcbiAgICAgICAgbGV0IGNvbnRpbnVvc0RhdGFBcnJheXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGludW91c1ZhcmlhYmxlcy5sZW5ndGg7IGkrKykgLy9DcmVhdGUgbXVsdGlwbGUgYXJyYXlzIG9uZSBmb3IgZWFjaCBvcHRpb25hbCB2YXJpYWJsZVxyXG4gICAgICAgICAgICBjb250aW51b3NEYXRhQXJyYXlzW2ldID0gW107XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlIGFycmF5IGZvciBmaW5hbCBSb3dzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJNVkNzOyBpKyspIHtcclxuICAgICAgICAgICAgZmluYWxSb3dzW2ldID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtYmVyVEdzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGZpbmFsUm93c1tpXVtqXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzRGF0YTogR2lzcGxheURlZmF1bHRzLmNsb25lTmVzdGVkQXJyYXkoY29udGludW9zRGF0YUFycmF5cyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3BhdGlhbERhdGE6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsRGF0YTogR2lzcGxheURlZmF1bHRzLmNsb25lTmVzdGVkQXJyYXkob3B0aW9uYWxEYXRhQXJyYXlzKSxcclxuICAgICAgICAgICAgICAgICAgICBSR0JBOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXJSR0JBOiBbXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGZpbmFsUm93cyk7XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsUm93cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlIHRoZSB2YXJpYWJsZXMgc2VudCBieSB0aGUgbWFpbiB0aHJlYWQuXHJcbiAgICAgKiBAcGFyYW0ge3tjb250aW5vdXNWYXJpYWJsZXM6IEFycmF5PENvbnRpbnVvdXNWYXJpYWJsZT4sIGNhdGVnb3JpY2FsVmFyaWFibGVzOiBBcnJheTxDYXRlZ29yaWNhbFZhcmlhYmxlPiwgdGltZVZhcmlhYmxlOiBUaW1lVmFyaWFibGV9fSBkYXRhIC0gRGF0YSBzZW50IGJ5IHRoZSBtYWluIHRocmVhZC5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZOZXdEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIF9zYXZlVmFyaWFibGVzKGRhdGEpIHtcclxuICAgICAgICBsZXQgY29udFZhcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRWYXIgb2YgZGF0YS5jb250aW51b3VzVmFyaWFibGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnRWYXIpO1xyXG4gICAgICAgICAgICBjb250VmFycy5wdXNoKG5ldyBDb250aW51b3VzVmFyaWFibGUoXHJcbiAgICAgICAgICAgICAgICBjb250VmFyLmV4dGVybmFsTmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuaW50ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgY29udFZhci50eXBlT2ZWaXN1YWxWYXJpYWJsZSxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuc2hhZGVyVmFyaWFibGVRdWFsaWZpZXIsXHJcbiAgICAgICAgICAgICAgICBjb250VmFyLnZpc3VhbFZhcmlhYmxlTWFwcGluZyxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuY2xhc3NCcmVha3MsXHJcbiAgICAgICAgICAgICAgICBjb250VmFyLm51bWJlck9mQ2xhc3NlcyxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuY2xhc3NCcmVha01ldGhvZCxcclxuICAgICAgICAgICAgICAgIGNvbnRWYXIuY2xhc3NCcmVha01ldGhvZFBhcmFtc1xyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbGV0IGRvYSA9IHRydWU7XHJcbiAgICAgICAgLy8gaWYgKGRvYSkge1xyXG4gICAgICAgIGxldCBjYXRWYXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjYXRWYXIgb2YgZGF0YS5jYXRlZ29yaWNhbFZhcmlhYmxlcykge1xyXG4gICAgICAgICAgICBjYXRWYXJzLnB1c2gobmV3IENhdGVnb3JpY2FsVmFyaWFibGUoXHJcbiAgICAgICAgICAgICAgICBjYXRWYXIuZXh0ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgY2F0VmFyLmludGVybmFsTmFtZSxcclxuICAgICAgICAgICAgICAgIGNhdFZhci50eXBlT2ZWaXN1YWxWYXJpYWJsZSxcclxuICAgICAgICAgICAgICAgIGNhdFZhci5zaGFkZXJWYXJpYWJsZVF1YWxpZmllcixcclxuICAgICAgICAgICAgICAgIGNhdFZhci52aXN1YWxWYXJpYWJsZU1hcHBpbmcsXHJcbiAgICAgICAgICAgICAgICBudWxsXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRWYXIgPSBkYXRhLnRpbWVWYXJpYWJsZTtcclxuICAgICAgICBsZXQgdGltZVZhcmlhYmxlO1xyXG4gICAgICAgIGlmICh0VmFyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGltZVZhcmlhYmxlID0gbmV3IFRpbWVWYXJpYWJsZShcclxuICAgICAgICAgICAgICAgIHRWYXIuZXh0ZXJuYWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgdFZhci5pbnRlcm5hbE5hbWUsXHJcbiAgICAgICAgICAgICAgICB0VmFyLmdyYW51bGFyaXR5LFxyXG4gICAgICAgICAgICAgICAgdFZhci50aW1lQ29udHJvbFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb3B0VmFycyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb3B0VmFyIG9mIGRhdGEub3B0aW9uYWxWYXJpYWJsZXMpXHJcbiAgICAgICAgICAgIG9wdFZhcnMucHVzaChuZXcgRGF0YVZhcmlhYmxlKG9wdFZhci5leHRlcm5hbE5hbWUsIG9wdFZhci5pbnRlcm5hbE5hbWUpKTtcclxuXHJcbiAgICAgICAgLy9USU1FXHJcbiAgICAgICAgLy8gdGhpcy50aW1lVmFyaWFibGUgPSB3b3JrZXJPcHRpb25zLnRpbWVWYXJpYWJsZTtcclxuICAgICAgICB0aGlzLnRpbWVWYXJpYWJsZSA9IHRpbWVWYXJpYWJsZTtcclxuICAgICAgICB0aGlzLnRpbWVHcmFudWxhcml0eSA9IHRoaXMudGltZVZhcmlhYmxlID8gdGhpcy50aW1lVmFyaWFibGUuZ2V0R3JhbnVsYXJpdHkoKSA6ICcnO1xyXG4gICAgICAgIC8vQ0FURUdPUklDQUxcclxuICAgICAgICB0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzID0gY2F0VmFyczsvL3dvcmtlck9wdGlvbnMuY2F0ZWdvcmljYWxWYXJpYWJsZXM7XHJcbiAgICAgICAgdGhpcy5oYXNDYXRlZ29yaWNhbFZhcmlhYmxlcyA9IHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXMubGVuZ3RoID4gMDtcclxuICAgICAgICAvL0NPTlRJTk9VUyBcclxuICAgICAgICB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXMgPSBjb250VmFyczsvL3dvcmtlck9wdGlvbnMuY29udGludW91c1ZhcmlhYmxlcztcclxuICAgICAgICAvL09QVElPTkFMIFZBUlNcclxuICAgICAgICB0aGlzLm9wdGlvbmFsVmFyaWFibGVzID0gb3B0VmFycztcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIGNodW5rIG9mIGJ5dGVzIGZyb20gdGhlIGZpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ1NWRGF0YVdvcmtlclxyXG4gICAgICovXHJcbiAgICByZWFkTmV4dENodW5rKCkge1xyXG4gICAgICAgIGxldCBzdGFydCA9IE1hdGgubWluKHRoaXMuc3RhcnRCeXRlLCB0aGlzLmVuZEJ5dGUpO1xyXG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0aGlzLnN0YXJ0Qnl0ZSArIHRoaXMuY2h1bmtTaXplLCB0aGlzLmVuZEJ5dGUpO1xyXG4gICAgICAgIHRoaXMucmVhZGVyLnJlYWRBc1RleHQodGhpcy5kYXRhRmlsZS5zbGljZShzdGFydCwgZW5kKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBtb3JlIDEwMDAgYnl0ZXMgdG8gZmluaXNoIHRoZSBsYXN0IGxpbmUgb2YgdGhlIHdvcmtlci5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIHJlYWRMYXN0TGluZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXN0V29ya2VyUm93Lmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5taW4odGhpcy5zdGFydEJ5dGUsIHRoaXMuZW5kQnl0ZSk7XHJcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuZW5kQnl0ZSArIDEwMDA7XHJcbiAgICAgICAgdGhpcy5yZWFkZXIucmVhZEFzVGV4dCh0aGlzLmRhdGFGaWxlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciBhIGNodW5rIGlzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZSAtIEV2ZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVhZCBkYXRhLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgY2h1bmtSZWFkRnJvbUZpbGUoZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTGFzdExpbmUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKFwibGFzdCBsaW5lXCIsIHRoaXMud29ya2VySW5kZXgsIGUudGFyZ2V0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGxldCByb3dzID0gKHRoaXMubGFzdFdvcmtlclJvdyArIGUudGFyZ2V0LnJlc3VsdCkuc3BsaXQodGhpcy5yb3dEZWxpbWl0ZXIpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4odGhpcy53b3JrZXJJbmRleCwgcm93cyk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Jvd3Mocm93cywgMCwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZEVORFN0YXJ0TWVzc2FnZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCeXRlICs9IHRoaXMuY2h1bmtTaXplO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDaHVuayhlLnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydEJ5dGUgPj0gdGhpcy5lbmRCeXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVORFwiKTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTnVtUm93cyBXb3JrZXJcIiwgdGhpcy53b3JrZXJJbmRleCwgXCJpczpcIiwgdGhpcy5udW1Sb3dzUmVhZCwgXCJcXG5GSVJTVFJPVyA9IFwiLCB0aGlzLmZpcnN0V29ya2VyUm93LCBcIlxcbkxBU1RST1cgPSBcIiwgdGhpcy5sYXN0V29ya2VyUm93KTtcclxuICAgICAgICAgICAgICAgIC8vUG9zdCBtZXNzYWdlIHdpdGggZmlyc3QgYW5kIGxhc3Qgcm93XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJ3b3JrZXIgVGVybWluYXRlZFwiLCB0aGlzLndvcmtlckluZGV4LCB0aGlzLmZpcnN0V29ya2VyUm93LCB0aGlzLmxhc3RXb3JrZXJSb3cpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0xhc3RMaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGxldCBpc0RvbmUgPSB0aGlzLnJlYWRMYXN0TGluZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRG9uZSkgLy9Pbmx5IHRoZSBvbmVzIHRoYXQgcmV0dXJuZWQgdHJ1ZSBmcm9tIHRoZSByZWFkTGFzdExpbmUoKSBtZXRob2Qgd2lsbCBzZW5kIGJhY2sgdG8gdGhlIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVORFN0YXJ0TWVzc2FnZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZE5leHRDaHVuaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZW5kRU5EU3RhcnRNZXNzYWdlKCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIkVORFwiLCB0aGlzLndvcmtlckluZGV4LCB0aGlzLmRhdGFSb3dzU2F2ZWQubGVuZ3RoKTtcclxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICBwcm90b2NvbE1lc3NhZ2U6IEdpc3BsYXlEZWZhdWx0cy5NRVNTQUdFU19DU1YoKS5FTkRfU1RBUlQsXHJcbiAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXJJbmRleDogdGhpcy53b3JrZXJJbmRleCxcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0V29ya2VyUm93OiB0aGlzLmZpcnN0V29ya2VyUm93LFxyXG4gICAgICAgICAgICAgICAgLy8gbGFzdFdvcmtlclJvdzogdGhpcy5sYXN0V29ya2VyUm93XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGNodW5rIHRoYXQgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcHQtUFQvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3NwbGl0XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vaW1hZ2UucHJudHNjci5jb20vaW1hZ2UvQmthUnA4cVNRdXl0OXBob1NoNzFaQS5wbmdcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9pbWFnZS5wcm50c2NyLmNvbS9pbWFnZS9GQVE4Q1ZIOVMxVzZYMFJvWnJPV2Z3LnBuZyAtIEVkZ2UgY2FzZSBmb3IgXFxyXFxuLlxyXG4gICAgICogQHNlZSBodHRwczovL2ltYWdlLnBybnRzY3IuY29tL2ltYWdlL3lZWFdjWndMUWpTTllxSWl1UUVjS1EucG5nIC0gRWRnZSBjYXNlIGV4YW1wbGUuXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gY2h1bmtUZXh0ICAtIFRoZSB0ZXh0IHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBtZW1iZXJvZiBDU1ZEYXRhV29ya2VyXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NDaHVuayhjaHVua1RleHQpIHtcclxuICAgICAgICBsZXQgcm93cyA9ICh0aGlzLnJlbWFpbmluZ0NodW5rUm93ICsgY2h1bmtUZXh0KS5zcGxpdCh0aGlzLnJvd0RlbGltaXRlcik7IC8vTWF5IG5vdCBoYXZlIHRoZSBiZXN0IHBlcmZvcm1hbmNlIChoYXMgdG8gY3JlYXRlIG5ldyBzdHJpbmcgZHVlIHRvIHN0cmluZyBpbW11dGFiaWxpdHkpLiBDb3VsZCBiZSBjaGFuZ2VkIGJ1dCBzb2x1dGlvbiBoYXMgdG8gc29sdmUgdGhlIEVER0UgQ0FTRS5cclxuICAgICAgICB0aGlzLnJlbWFpbmluZ0NodW5rUm93ID0gcm93c1tyb3dzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGxldCBbc3RhcnRSb3dJbmRleCwgZW5kUm93SW5kZXhdID0gWzAsIHJvd3MubGVuZ3RoIC0gMV07IC8vVGhlIGluZGV4IHRvIHN0YXJ0IGFuZCBlbmQgdGhlIHJvd3MgcHJvY2Vzc2luZ1xyXG4gICAgICAgIGlmICghdGhpcy5maXJzdFdvcmtlclJvdykgeyAvL1NhdmUgMXN0IHJvdyBvZiB0aGlzIHdvcmtlciBcclxuICAgICAgICAgICAgdGhpcy5maXJzdFdvcmtlclJvdyA9IHJvd3NbMF07XHJcbiAgICAgICAgICAgIHN0YXJ0Um93SW5kZXggPSAxOyAvL0lnbm9yZSBmaXJzdCByb3cgb2YgZmlyc3QgY2h1bmsgaW4gYW55IHdvcmtlclxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMubGFzdFdvcmtlclJvdyAmJiB0aGlzLnN0YXJ0Qnl0ZSA+PSB0aGlzLmVuZEJ5dGUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy53b3JrZXJJbmRleCwgdGhpcy5sYXN0V29ya2VyUm93KTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0V29ya2VyUm93ID0gdGhpcy5yZW1haW5pbmdDaHVua1JvdzsgLy9TYXZlIGxhc3Qgcm93IGlmIGl0J3MgdGhlIGxhc3QgY2h1bmsgKFNlZSBzcGxpdCBpbWFnZSkgXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMud29ya2VySW5kZXgsIHJvd3MsIHRoaXMuZGF0YVJvd3NTYXZlZCwgdGhpcy5maXJzdFdvcmtlclJvdywgdGhpcy5sYXN0V29ya2VyUm93KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IodGhpcy53b3JrZXJJbmRleCwgdGhpcy5yZW1haW5pbmdDaHVua1Jvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvY2Vzc1Jvd3Mocm93cywgc3RhcnRSb3dJbmRleCwgZW5kUm93SW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyB0aGUgcm93cyB0aGF0IGFyZSBpbiB0aGUgcm93cyBhcnJheS4gVGhlIGZpcnN0IHJvdyBvZiB0aGUgMXN0IGNodW5rIHJlYWQgZnJvbSB0aGUgZmlsZSBzaG91bGQgYmUgaWdub3JlZC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcm93cyAtIFRoZSByb3dzLCBlYWNoIG9uZSBpbiBhIHBvc2l0aW9uIG9mIHRoZSBhcnJheS4gXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRSb3dJbmRleCAtIFRoZSByb3cgdG8gc3RhcnQgcHJvY2Vzc2luZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRSb3dJbmRleCAtIFRoZSBsYXN0IHJvdyB0byBwcm9jZXNzLlxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc1Jvd3Mocm93cywgc3RhcnRSb3dJbmRleCwgZW5kUm93SW5kZXgpIHtcclxuICAgICAgICBsZXQgcmVzUm93cyA9IFtdO1xyXG4gICAgICAgIC8vIHRoaXMubnVtUm93c1JlYWQgKz0gKGVuZFJvd0luZGV4IC0gc3RhcnRSb3dJbmRleCk7IC8vREVMRVRFXHJcbiAgICAgICAgbGV0IGNhdGVnb3JpY2FsSW5kaWNlcyA9IHRoaXMuaGVhZGVySW5kaWNlc1swXTtcclxuICAgICAgICBsZXQgY29udGludW91c0luZGljZXMgPSB0aGlzLmhlYWRlckluZGljZXNbMV07XHJcbiAgICAgICAgbGV0IGdlb21ldHJ5SW5kaWNlcyA9IHRoaXMuaGVhZGVySW5kaWNlc1syXTtcclxuICAgICAgICBsZXQgaGFzSWRHZW9tZXRyeSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICgrZ2VvbWV0cnlJbmRpY2VzID09PSArZ2VvbWV0cnlJbmRpY2VzKSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5SW5kaWNlcyA9IFtnZW9tZXRyeUluZGljZXNdO1xyXG4gICAgICAgICAgICBoYXNJZEdlb21ldHJ5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRpbWVJbmRleCA9IHRoaXMuaGVhZGVySW5kaWNlc1szXTtcclxuICAgICAgICBsZXQgaGFzVGltZSA9IHRoaXMudGltZUdyYW51bGFyaXR5ICE9PSAnJzsgLy9PUiB0aGlzLnRpbWVWYXJpYWJsZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgbGV0IG9wdGluYWxJbmRpY2VzID0gdGhpcy5oZWFkZXJJbmRpY2VzWzRdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydFJvd0luZGV4OyBpIDwgZW5kUm93SW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLm51bVJvd3NSZWFkKys7XHJcbiAgICAgICAgICAgIGxldCBjb2x1bW5zID0gcm93c1tpXS5zcGxpdCh0aGlzLmNvbHVtbkRlbGltaXRlcik7XHJcbiAgICAgICAgICAgIC8qIGlmIChjb2x1bW5zLmxlbmd0aCAhPT0gdGhpcy5udW1Db2x1bW5zUGVyUm93KSAvL0NoZWNrIGZvciBlcnJvcnNcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIG51bWJlciBvZiBjb2x1bW5zXCIpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IHJvdyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgW2ksIGNhdEluZGV4XSBvZiBjYXRlZ29yaWNhbEluZGljZXMuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2F0ZWdvcnkgPSBjb2x1bW5zW2NhdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhdGVnb3JpY2FsVmFyaWFibGVzW2ldLmNsYXNzQ2FsY3VsYXRpb25SZXF1aXJlZCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2F0ZWdvcmljYWxWYXJpYWJsZXNbaV0uYWRkQ2F0ZWdvcnkoY2F0ZWdvcnkpO1xyXG4gICAgICAgICAgICAgICAgcm93LnB1c2goY2F0ZWdvcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBbaSwgY29udEluZGV4XSBvZiBjb250aW51b3VzSW5kaWNlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICtjb2x1bW5zW2NvbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAvKiBpZiAodmFsdWUgPj0gODAwMDAuMTApXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV1VVVVRcIik7ICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVvdXNWYXJpYWJsZXNbaV0uc2V0TWluTWF4KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHZhbHVlKTsgLy9TdHJpbmcgdG8gbnVtYmVyXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGdlb0luZGV4IG9mIGdlb21ldHJ5SW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0lkR2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjb2x1bW5zW2dlb0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoK3ZhbHVlID09PSArdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKCt2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCh2YWx1ZS50b1VwcGVyQ2FzZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgrY29sdW1uc1tnZW9JbmRleF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzVGltZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGdyYW51bGUgPSB0aGlzLmdldEdyYW51bGUoY29sdW1uc1t0aW1lSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZVZhcmlhYmxlLmFkZFRlbXBvcmFsR3JhbnVsZShncmFudWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZVZhcmlhYmxlLmFkZFRlbXBvcmFsR3JhbnVsZVRvU2V0KGdyYW51bGUpO1xyXG4gICAgICAgICAgICAgICAgcm93LnB1c2goZ3JhbnVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbmFsSW5kZXggb2Ygb3B0aW5hbEluZGljZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICgrY29sdW1uc1tvcHRpb25hbEluZGV4XSA9PT0gK2NvbHVtbnNbb3B0aW9uYWxJbmRleF0pIC8vSXQncyBhIG51bWJlcj9cclxuICAgICAgICAgICAgICAgICAgICByb3cucHVzaCgrY29sdW1uc1tvcHRpb25hbEluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goY29sdW1uc1tvcHRpb25hbEluZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzUm93cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVJvd3NTYXZlZC5wdXNoKHJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMud29ya2VySW5kZXgsIHRoaXMuZGF0YVJvd3NTYXZlZC5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogREVMRVRFIEFORCBSZXBsYWNlIHdpdGggR2lzcGxheURlZmF1bHRzLmdldEdyYW51bGUodGltZVN0cmluZylcclxuICAgICAqIENvbnZlcnQgdGhlIHRpbWUgc3RyaW5nIHRvIHRoZSBncmFudWxhcml0eSB3ZSB3YW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVTdHJpbmcgLSBUaGUgdGltZSBhcyBpdCB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLiBcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGdyYW51bFxyXG4gICAgICogQG1lbWJlcm9mIENTVkRhdGFXb3JrZXJcclxuICAgICAqL1xyXG4gICAgZ2V0R3JhbnVsZSh0aW1lU3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlO1xyXG4gICAgICAgIC8vIGNvbnNvbGUud2Fybih0aW1lU3RyaW5nLCB0aGlzLnRpbWVHcmFudWxhcml0eSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICAvL2lmIGN5Y2xpYyB0aGVuIC4uLlxyXG4gICAgICAgIGRheSBvZiB5ZWFyIC0+IGRheU9mWWVhciAobiB0ZW1vcyApXHJcbiAgICAgICAgbW9udGggb2YgeWVhciAtPiBtb250aE9mWWVhciAodGVtb3MpXHJcbiAgICAgICAgZGF5IG9mIG1vbnRoIC0+IGRheU9mTW9udGggKHRlbW9zKVxyXG4gICAgICAgIGhvdXIgb2YgZGF5IC0+IGhvdXJPZkRheSAodGVtb3MpXHJcbiAgICAgICAgbWludXRlIG9mIGhvdXIgLT4gbWludXRlT2ZIb3VyICh0ZW1vcylcclxuICAgICAgICBcclxuICAgICAgICAvL2Vsc2UgY29udGludW91c1xyXG4gICAgICAgIHllYXIgLT4gMjAxNSwgMjAxNiAuLi5cclxuICAgICAgICBtb250aCAtPiAyMDE1XzAxLCAyMDE1XzAyIC4uLiAyMDE2XzAxIGV0Y1xyXG4gICAgICAgIGRheSAtPiAyMDE1XzAxXzAxLCAyMDE1XzAxXzAyIC4uLlxyXG4gICAgICAgIGhvdXIgLT4gMjAxNV8wMV8wMV8wMSwgMjAxNV8wMV8wMV8wMSAuLi5cclxuICAgICAgICBtaW51dGVcclxuICAgICAgICB2YWx1ZVxyXG4gICAgICAgICovXHJcblxyXG4gICAgICAgIHN3aXRjaCAodGhpcy50aW1lR3JhbnVsYXJpdHkpIHtcclxuICAgICAgICAgICAgLy9DWUNMSUNcclxuICAgICAgICAgICAgY2FzZSAnbW9udGhPZlllYXInOiAvL01lcyBkbyBhbm9cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1vbnRoKCkgKyAxKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGF5T2ZZZWFyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gLTE7IC8vQ0hBTkdFIHRvIGNhbGN1bGF0ZSBkYXkgb2YgeWVhclxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheU9mTW9udGgnOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXREYXRlKCk7IC8vR09PRFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hvdXJPZkRheSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEhvdXJzKCk7IC8vR09PRFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZU9mSG91cic6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldE1pbnV0ZXMoKTsgLy9HT09EXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vQ09OVElOVU9VU1xyXG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodGltZVN0cmluZykuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb250aCc6IC8vTWVzIGRvIGFub1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRGdWxsWWVhcigpICsgXCJfXCIgKyAobmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIl9cIiArIChuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXRNb250aCgpICsgMSkgKyBcIl9cIiArIG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldERhdGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlID0gTnVtYmVyKG5ldyBEYXRlKHRpbWVTdHJpbmcpLmdldEZ1bGxZZWFyKCkgKyBcIlwiICsgbmV3IERhdGUodGltZVN0cmluZykuZ2V0TW9udGgoKSArIFwiXCIgKyBuZXcgRGF0ZSh0aW1lU3RyaW5nKS5nZXREYXkoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSArdGltZVN0cmluZztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbm5ldyBDU1ZEYXRhV29ya2VyKCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L1BhcnNlci9DU1YvQ1NWRGF0YVdvcmtlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQVJBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFOQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBT0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVdBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFmQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBZ0JBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFSQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQVhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQTNJQTtBQTZJQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBRUE7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQWpCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBa0JBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBRUE7QUF6Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQWpCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFpQkE7QUFsQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQW1CQTtBQUFBO0FBQ0E7QUFBQTtBQVFBO0FBNUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUF4Q0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQXlDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBSUE7QUE3Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFQQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQXJCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUJBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFqQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUEwQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFoREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQWlDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/* no static exports found */
/* all exports used */
/*!***********************************!*\
  !*** ./src/Gisplay/defaults.json ***!
  \***********************************/
/***/ (function(module, exports) {

eval("module.exports = {\"figures\":{\"cattle\":0,\"deaths\":1,\"deathsCross\":2,\"fire\":3,\"man\":4,\"person\":5,\"rectangle\":6,\"woman\":7},\"patterns\":{\"crossPattern\":0,\"diagonalLines\":1,\"plusPattern\":2,\"dotPattern\":3,\"wavePattern\":4},\"shapes\":{\"circle\":0,\"cross\":1,\"filled_circle\":2,\"filled_square\":3,\"plus\":4,\"square\":5,\"triangle\":6},\"figuresImageSize\":128,\"patternsImageSize\":32,\"shapesImageSize\":128,\"bgmapsProviders\":[\"Google Maps\",\"GM\",\"Mapbox\",\"MB\",\"Here Maps\",\"HM\",\"Bing Maps\",\"BM\"],\"availableClasssBreakMethods\":[\"quantiles\",\"equalintervals\",\"k-means\"],\"defaultClassBreakMethod\":\"quantiles\",\"reservedKeywords\":{\"longitude\":\"Longitude\",\"latitude\":\"Latitude\"},\"visualVariables\":{\"COLOR\":\"color\",\"SHAPE\":\"shape\",\"TEXTURE\":\"texture\",\"SIZE\":\"size\",\"ORIENTATION\":\"orientation\",\"POSITION\":\"position\",\"OPACITY\":\"opacity\"},\"defaultShadersVariables\":{\"position\":\"position\",\"projectionMatrix\":\"Mproj\"},\"defaultColor\":[0,0,0],\"defaultAlpha\":1,\"defaultShape\":\"triangle\",\"defaultTexture\":\"terrain\",\"defaultFigure\":\"deathsCross\",\"defaultOrientation\":0,\"defaultSize\":10,\"minSize\":15,\"maxSize\":100,\"timeVariables\":{\"INSTANT\":\"instant\",\"INTERVAL\":\"interval\",\"ANIMATION\":\"animation\"},\"bgmapsUrls\":{\"MB\":{\"css\":[\"https://api.mapbox.com/mapbox.js/v2.4.0/mapbox.css\"],\"js\":[\"https://api.mapbox.com/mapbox.js/v2.4.0/mapbox.js\"]},\"MBGL\":{\"css\":[\"https://api.tiles.mapbox.com/mapbox-gl-js/v0.41.0/mapbox-gl.css\"],\"js\":[\"https://api.tiles.mapbox.com/mapbox-gl-js/v0.41.0/mapbox-gl.js\"]},\"GM\":{\"js\":[\"https://maps.googleapis.com/maps/api/js?key=AIzaSyBU70aRzSHEkkEDGM54wxOfz6GBOffjzlE\"]},\"HM\":{\"js\":[\"http://js.api.here.com/v3/3.0/mapsjs-core.js\",\"http://js.api.here.com/v3/3.0/mapsjs-service.js\",\"http://js.api.here.com/v3/3.0/mapsjs-mapevents.js\"]},\"BM\":{\"js\":[\"http://www.bing.com/api/maps/mapcontrol?branch=release\"]}}}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9HaXNwbGF5L2RlZmF1bHRzLmpzb24/Mjg1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcImZpZ3VyZXNcIjp7XCJjYXR0bGVcIjowLFwiZGVhdGhzXCI6MSxcImRlYXRoc0Nyb3NzXCI6MixcImZpcmVcIjozLFwibWFuXCI6NCxcInBlcnNvblwiOjUsXCJyZWN0YW5nbGVcIjo2LFwid29tYW5cIjo3fSxcInBhdHRlcm5zXCI6e1wiY3Jvc3NQYXR0ZXJuXCI6MCxcImRpYWdvbmFsTGluZXNcIjoxLFwicGx1c1BhdHRlcm5cIjoyLFwiZG90UGF0dGVyblwiOjMsXCJ3YXZlUGF0dGVyblwiOjR9LFwic2hhcGVzXCI6e1wiY2lyY2xlXCI6MCxcImNyb3NzXCI6MSxcImZpbGxlZF9jaXJjbGVcIjoyLFwiZmlsbGVkX3NxdWFyZVwiOjMsXCJwbHVzXCI6NCxcInNxdWFyZVwiOjUsXCJ0cmlhbmdsZVwiOjZ9LFwiZmlndXJlc0ltYWdlU2l6ZVwiOjEyOCxcInBhdHRlcm5zSW1hZ2VTaXplXCI6MzIsXCJzaGFwZXNJbWFnZVNpemVcIjoxMjgsXCJiZ21hcHNQcm92aWRlcnNcIjpbXCJHb29nbGUgTWFwc1wiLFwiR01cIixcIk1hcGJveFwiLFwiTUJcIixcIkhlcmUgTWFwc1wiLFwiSE1cIixcIkJpbmcgTWFwc1wiLFwiQk1cIl0sXCJhdmFpbGFibGVDbGFzc3NCcmVha01ldGhvZHNcIjpbXCJxdWFudGlsZXNcIixcImVxdWFsaW50ZXJ2YWxzXCIsXCJrLW1lYW5zXCJdLFwiZGVmYXVsdENsYXNzQnJlYWtNZXRob2RcIjpcInF1YW50aWxlc1wiLFwicmVzZXJ2ZWRLZXl3b3Jkc1wiOntcImxvbmdpdHVkZVwiOlwiTG9uZ2l0dWRlXCIsXCJsYXRpdHVkZVwiOlwiTGF0aXR1ZGVcIn0sXCJ2aXN1YWxWYXJpYWJsZXNcIjp7XCJDT0xPUlwiOlwiY29sb3JcIixcIlNIQVBFXCI6XCJzaGFwZVwiLFwiVEVYVFVSRVwiOlwidGV4dHVyZVwiLFwiU0laRVwiOlwic2l6ZVwiLFwiT1JJRU5UQVRJT05cIjpcIm9yaWVudGF0aW9uXCIsXCJQT1NJVElPTlwiOlwicG9zaXRpb25cIixcIk9QQUNJVFlcIjpcIm9wYWNpdHlcIn0sXCJkZWZhdWx0U2hhZGVyc1ZhcmlhYmxlc1wiOntcInBvc2l0aW9uXCI6XCJwb3NpdGlvblwiLFwicHJvamVjdGlvbk1hdHJpeFwiOlwiTXByb2pcIn0sXCJkZWZhdWx0Q29sb3JcIjpbMCwwLDBdLFwiZGVmYXVsdEFscGhhXCI6MSxcImRlZmF1bHRTaGFwZVwiOlwidHJpYW5nbGVcIixcImRlZmF1bHRUZXh0dXJlXCI6XCJ0ZXJyYWluXCIsXCJkZWZhdWx0RmlndXJlXCI6XCJkZWF0aHNDcm9zc1wiLFwiZGVmYXVsdE9yaWVudGF0aW9uXCI6MCxcImRlZmF1bHRTaXplXCI6MTAsXCJtaW5TaXplXCI6MTUsXCJtYXhTaXplXCI6MTAwLFwidGltZVZhcmlhYmxlc1wiOntcIklOU1RBTlRcIjpcImluc3RhbnRcIixcIklOVEVSVkFMXCI6XCJpbnRlcnZhbFwiLFwiQU5JTUFUSU9OXCI6XCJhbmltYXRpb25cIn0sXCJiZ21hcHNVcmxzXCI6e1wiTUJcIjp7XCJjc3NcIjpbXCJodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC5qcy92Mi40LjAvbWFwYm94LmNzc1wiXSxcImpzXCI6W1wiaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3guanMvdjIuNC4wL21hcGJveC5qc1wiXX0sXCJNQkdMXCI6e1wiY3NzXCI6W1wiaHR0cHM6Ly9hcGkudGlsZXMubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjAuNDEuMC9tYXBib3gtZ2wuY3NzXCJdLFwianNcIjpbXCJodHRwczovL2FwaS50aWxlcy5tYXBib3guY29tL21hcGJveC1nbC1qcy92MC40MS4wL21hcGJveC1nbC5qc1wiXX0sXCJHTVwiOntcImpzXCI6W1wiaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT1BSXphU3lCVTcwYVJ6U0hFa2tFREdNNTR3eE9mejZHQk9mZmp6bEVcIl19LFwiSE1cIjp7XCJqc1wiOltcImh0dHA6Ly9qcy5hcGkuaGVyZS5jb20vdjMvMy4wL21hcHNqcy1jb3JlLmpzXCIsXCJodHRwOi8vanMuYXBpLmhlcmUuY29tL3YzLzMuMC9tYXBzanMtc2VydmljZS5qc1wiLFwiaHR0cDovL2pzLmFwaS5oZXJlLmNvbS92My8zLjAvbWFwc2pzLW1hcGV2ZW50cy5qc1wiXX0sXCJCTVwiOntcImpzXCI6W1wiaHR0cDovL3d3dy5iaW5nLmNvbS9hcGkvbWFwcy9tYXBjb250cm9sP2JyYW5jaD1yZWxlYXNlXCJdfX19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvR2lzcGxheS9kZWZhdWx0cy5qc29uXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ })
/******/ ]);